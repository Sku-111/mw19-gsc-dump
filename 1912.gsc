// IW8 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

init()
{
    level.spawnglobals = spawnstruct();

    if ( scripts\mp\utility\game::isanymlgmatch() )
        level.killstreakspawnshielddelayms = 0;
    else
        level.killstreakspawnshielddelayms = 4000;

    level.forcebuddyspawn = 0;
    level.spawnmins = ( 0, 0, 0 );
    level.spawnmaxs = ( 0, 0, 0 );
    level.mapcenter = findboxcenter( level.spawnmins, level.spawnmaxs );
    level.numplayerswaitingtospawn = 0;
    level.numplayerswaitingtoenterkillcam = 0;
    level.players = [];
    level.playersbyentitynumber = [];
    level.participants = [];
    level.characters = [];
    level.spawnpointarray = [];
    level.grenades = [];
    level.missiles = [];
    level.carepackages = [];
    level.helis = [];
    level.turrets = [];
    level.tanks = [];
    level.scramblers = [];
    level.ugvs = [];
    level.playerkillstreaks = [];
    level.spawnglobals.lowerlimitfullsights = getdvarfloat( "scr_lowerLimitFullSights" );
    level.spawnglobals.lowerlimitcornersights = getdvarfloat( "scr_lowerLimitCornerSights" );
    level.spawnglobals.lastteamspawnpoints = [];
    level.spawnglobals.lastbadspawntime = [];
    level.spawnglobals.influencenodealloccounts = [];
    level.spawnglobals.spawnsets = [];
    level.spawnglobals.activespawnsets = [];
    level.spawnglobals.spawnsetlists = [];
    level.spawnglobals.spawnpointscriptdata = [];
    level thread spawnpointupdate();
    level thread trackgrenades();
    level thread trackmissiles();
    level thread trackhostmigrationend();
    level thread trackcarepackages();
    thread printstartupdebugmessages();
    level thread logextraspawninfothink();

    for ( var_0 = 0; var_0 < level.teamnamelist.size; var_0++ )
    {
        level.teamspawnpoints[level.teamnamelist[var_0]] = [];
        level.teamfallbackspawnpoints[level.teamnamelist[var_0]] = [];
    }

    scripts\mp\spawnfactor::init_spawn_factors();
    loadspawnlogicweights();
    var_1 = getentarray( "trigger_multiple_mp_spawn_lane", "classname" );
    level.spawnglobals.lanetriggers = var_1;

    foreach ( var_4, var_3 in level.spawnglobals.lanetriggers )
    {
        var_3.index = var_4;
        var_3.indexflag = 1 << var_4;
    }

    var_5 = getentarray( "trigger_multiple_mp_spawn_ignore", "classname" );

    foreach ( var_7 in var_5 )
        scripts\mp\utility\trigger::makeenterexittrigger( var_7, ::ignoretriggerenter, ::ignoretriggerexit );
}

codecallbackhandler_spawnpointprecalc( var_0 )
{

}

codecallbackhandler_spawnpointscore( var_0, var_1 )
{
    var_2 = level.spawnglobals.activespawncontext;
    var_3 = level.spawnglobals;
    var_4 = 0.0;
    var_0.scriptdata = level.spawnglobals.spawnpointscriptdata[var_0.index];

    foreach ( var_8, var_6 in var_3.activescriptfactors )
    {
        var_7 = 0.0;

        if ( isdefined( var_6.paramreflist ) )
        {

        }

        var_7 = [[ var_6.func ]]( var_0 );
        var_4 = var_4 + var_7 * var_6.weight;
    }

    return var_4;
}

codecallbackhandler_spawnpointcritscore( var_0, var_1 )
{
    var_2 = scripts\mp\spawnscoring::criticalfactors_callback( var_0 );
    return var_2;
}

getspawnpoint( var_0, var_1, var_2, var_3, var_4, var_5 )
{
    var_6 = createspawnquerycontext( var_0, var_1, var_5 );
    setactivespawnquerycontext( var_6 );

    if ( level.forcebuddyspawn )
    {
        var_7 = scripts\mp\spawnscoring::findbuddyspawn();

        if ( isdefined( var_7 ) )
            return var_7;
    }

    if ( !isdefined( var_4 ) )
        var_4 = "buddy";

    if ( getdvarint( "scr_game_disable_buddy_spawning", 0 ) == 1 )
    {
        if ( var_4 == "buddy" )
            var_4 = "bad";
    }

    var_8 = getspawnbucketfromstring( var_4 );

    if ( isdefined( var_2 ) )
        activatespawnset( var_2, 1 );

    var_9 = getspawnpointfromcode();
    var_9._id_140AD = 0;
    var_10 = var_9._id_140AD;
    var_11 = var_9.threatsight;
    var_12 = var_9.damagemod;

    if ( isdefined( var_3 ) && getspawnsetsize( var_3 ) > 0 && var_9.bucket >= 2 )
    {
        activatespawnset( var_3, 1 );
        var_13 = getspawnpointfromcode();

        if ( isdefined( var_13 ) && ( var_13.bucket < var_9.bucket || var_13.totalscore > var_9.totalscore ) )
        {
            var_9 = var_13;
            var_9._id_140AD = 1;
            var_10 = var_9._id_140AD;
            var_11 = var_9.threatsight;
            var_12 = var_9.damagemod;
        }
    }

    if ( var_9.bucket > var_8 )
        return undefined;

    if ( var_9.bucket >= 2 )
    {
        if ( var_8 >= 3 )
        {
            var_7 = scripts\mp\spawnscoring::findbuddyspawn();

            if ( isdefined( var_7 ) )
            {
                scripts\mp\spawnscoring::logbadspawn( "Using buddy spawn", var_0 );
                var_7.bucket = 3;
                var_7._id_140AD = var_10;
                var_7.threatsight = var_11;
                var_7.damagemod = var_12;
                return var_7;
            }

            scripts\mp\spawnscoring::logbadspawn( "CANNOT BUDDY SPAWN! Using bad code spawn", var_0 );
        }
    }

    if ( !istrue( level.loadoutdefaultfiresalediscount ) && !istrue( var_0.skipspawncamera ) && var_9.bucket >= 2 && var_9.threatsight < 300 )
        var_0._id_132FF = 1;

    return var_9;
}

createspawnquerycontext( var_0, var_1, var_2 )
{
    var_3 = spawnstruct();
    var_3.player = var_0;
    var_3.team = var_1;
    var_3.time = gettime();
    var_3.factorparams = var_2;

    if ( level.teambased )
        var_3.enemyteam = scripts\mp\utility\teams::getenemyteams( var_1 )[0];
    else
        var_3.enemyteam = "none";

    return var_3;
}

setactivespawnquerycontext( var_0 )
{
    level.spawnglobals.activespawncontext = var_0;
}

getactivespawnquerycontext()
{
    return level.spawnglobals.activespawncontext;
}

clearactivespawnquerycontext()
{
    level.spawnglobals.activespawncontext = undefined;
}

trackhostmigrationend()
{
    for (;;)
    {
        self waittill( "host_migration_end" );
        deactivateallspawnsets();
    }
}

clearcodefactors()
{
    foreach ( var_2, var_1 in level.spawnglobals.factors )
        enablefrontlinecriticalfactor( var_2, 0.0 );
}

registercodefactors( var_0 )
{
    foreach ( var_3, var_2 in var_0 )
        enablefrontlinecriticalfactor( var_3, var_2 );

    enablefrontlinecriticalfactor( "script", 1.0 );
}

setactivespawnlogic( var_0, var_1 )
{
    var_2 = level.spawnglobals;
    var_2.logicvariantid = 0;
    var_2.activespawnlogic = var_0;
    var_2.activescriptfactors = [];

    foreach ( var_6, var_4 in var_2.spawnfactorweights[var_0] )
    {
        if ( scripts\mp\spawnfactor::isfactorregistered( var_6 ) && scripts\mp\spawnfactor::isfactorscriptonly( var_6 ) )
        {
            var_5 = spawnstruct();
            var_5.func = scripts\mp\spawnfactor::getfactorfunction( var_6 );
            var_5.paramreflist = scripts\mp\spawnfactor::getfactorparamreflist( var_6 );
            var_5.weight = var_4;
            var_2.activescriptfactors[var_6] = var_5;
        }
    }

    clearcodefactors();
    registercodefactors( var_2.spawnfactorweights[var_0] );

    if ( istrue( var_2.criticalfactortypes[var_1]["frontline"] ) )
    {
        var_7 = scripts\mp\spawnfactor::getglobalfrontlineinfo();

        if ( isdefined( var_7 ) && isdefined( var_7.anchordir ) && isdefined( var_7.primaryanchorpos ) )
            registerspawnteamsmode( var_7.anchordir, var_7.primaryanchorpos );
        else
            registerspawnteamsmode();
    }
    else
    {

    }

    if ( level.teambased )
        createspawninfluencepoint( 1 );
    else
        createspawninfluencepoint( 0 );
}

loadspawnlogicweights()
{
    level.spawnglobals.spawnfactorweights = [];
    level.spawnglobals.criticalfactortypes = [];
    var_0 = -1;

    for (;;)
    {
        var_0++;
        var_1 = tablelookupbyrow( "mp/spawnweights.csv", var_0, 0 );

        if ( !isdefined( var_1 ) || var_1 == "" )
            break;

        var_2 = tablelookupbyrow( "mp/spawnweights.csv", var_0, 2 );
        var_3 = tablelookupbyrow( "mp/spawnweights.csv", var_0, 1 );

        if ( var_3 == "Normal" )
        {
            if ( !isdefined( level.spawnglobals.spawnfactorweights[var_1] ) )
                level.spawnglobals.spawnfactorweights[var_1] = [];

            var_4 = tablelookupbyrow( "mp/spawnweights.csv", var_0, 3 );
            var_4 = float( var_4 );
            level.spawnglobals.spawnfactorweights[var_1][var_2] = var_4;
            continue;
        }

        if ( !isdefined( level.spawnglobals.criticalfactortypes[var_1] ) )
            level.spawnglobals.criticalfactortypes[var_1] = [];

        level.spawnglobals.criticalfactortypes[var_1][var_2] = 1;
    }
}

scorespawnpoint( var_0 )
{
    foreach ( var_3, var_2 in level.spawnglobals.spawnfactorweights[level.spawnglobals.activespawnlogic] )
        scripts\mp\spawnfactor::calculatefactorscore( var_0, var_3, var_2 );
}

isfactorinuse( var_0 )
{
    return isdefined( level.spawnglobals.spawnfactorweights[level.spawnglobals.activespawnlogic][var_0] );
}

addstartspawnpoints( var_0, var_1, var_2 )
{
    var_3 = getspawnpointarray( var_0 );
    var_4 = [];

    if ( isdefined( level.modifiedspawnpoints ) )
    {
        for ( var_5 = 0; var_5 < var_3.size; var_5++ )
        {
            if ( _id_12CC8( var_3[var_5] ) )
                continue;

            if ( checkmodifiedspawnpoint( var_3[var_5] ) )
                continue;

            var_4[var_4.size] = var_3[var_5];
        }
    }
    else
        var_4 = var_3;

    if ( !var_4.size )
    {
        if ( !istrue( var_1 ) )
        {

        }

        return;
    }

    if ( !isdefined( level.startspawnpoints ) )
        level.startspawnpoints = [];

    if ( isdefined( var_2 ) )
    {
        if ( !isdefined( level.teamstartspawnpoints ) )
            level.teamstartspawnpoints = [];

        if ( !isdefined( level.teamstartspawnpoints[var_2] ) )
            level.teamstartspawnpoints[var_2] = [];
    }

    for ( var_5 = 0; var_5 < var_4.size; var_5++ )
    {
        var_4[var_5] spawnpointinit();
        var_4[var_5].selected = 0;
        var_4[var_5].infront = 0;
        level.startspawnpoints[level.startspawnpoints.size] = var_4[var_5];

        if ( isdefined( var_2 ) )
            level.teamstartspawnpoints[var_2][level.teamstartspawnpoints[var_2].size] = var_4[var_5];
    }

    if ( level.teambased )
    {
        foreach ( var_7 in var_4 )
        {
            var_7.infront = 1;
            var_8 = anglestoforward( var_7.angles );

            foreach ( var_10 in var_4 )
            {
                if ( var_7 == var_10 )
                    continue;

                var_11 = vectornormalize( var_10.origin - var_7.origin );
                var_12 = vectordot( var_8, var_11 );

                if ( var_12 > 0.86 )
                {
                    var_7.infront = 0;
                    break;
                }
            }
        }
    }
}

addspawnpoints( var_0, var_1, var_2, var_3 )
{
    if ( !isdefined( var_2 ) )
        var_2 = 0;

    var_4 = getspawnpointarray( var_1 );

    if ( !var_4.size )
    {
        if ( !scripts\cp_mp\utility\game_utility::unlink_on_ai_death() )
        {

        }

        return;
    }

    registerspawnpoints( var_0, var_4, var_3 );
}

registerspawnpoints( var_0, var_1, var_2 )
{
    if ( !isdefined( level.spawnpoints ) )
        level.spawnpoints = [];

    if ( !isdefined( level.teamspawnpoints[var_0] ) )
        level.teamspawnpoints[var_0] = [];

    if ( !isdefined( level.teamfallbackspawnpoints[var_0] ) )
        level.teamfallbackspawnpoints[var_0] = [];

    foreach ( var_4 in var_1 )
    {
        if ( _id_12CC8( var_4 ) )
            continue;

        if ( checkmodifiedspawnpoint( var_4 ) )
            continue;

        if ( !isdefined( var_4.inited ) )
        {
            var_4 spawnpointinit();
            level.spawnpoints[level.spawnpoints.size] = var_4;
        }

        if ( istrue( var_2 ) )
        {
            level.teamfallbackspawnpoints[var_0][level.teamfallbackspawnpoints[var_0].size] = var_4;
            var_4.isfallback = 1;
            continue;
        }

        level.teamspawnpoints[var_0][level.teamspawnpoints[var_0].size] = var_4;
    }
}

spawnpointinit()
{
    var_0 = self;
    var_0.scriptdata = spawnstruct();
    level.spawnglobals.spawnpointscriptdata[var_0.index] = var_0.scriptdata;
    level.spawnmins = expandmins( level.spawnmins, var_0.origin );
    level.spawnmaxs = expandmaxs( level.spawnmaxs, var_0.origin );
    var_0.forward = anglestoforward( var_0.angles );
    var_0.sighttracepoint = var_0.origin + ( 0, 0, 50 );
    var_0.lastspawntime = gettime();
    var_0.outside = 1;
    var_0.inited = 1;
    var_0.alternates = [];
    var_0.lastscore = [];
    var_1 = physics_createcontents( [ "physicscontents_solid", "physicscontents_missileclip", "physicscontents_clipshot" ] );
    var_2 = physics_raycast( var_0.sighttracepoint, var_0.sighttracepoint + ( 0, 0, 1024 ), var_1, [], 0, "physicsquery_any" );

    if ( var_2 > 0 )
    {
        var_3 = var_0.sighttracepoint + var_0.forward * 100;
        var_2 = physics_raycast( var_3, var_0.sighttracepoint + ( 0, 0, 1024 ), var_1, [], 0, "physicsquery_any" );

        if ( var_2 > 0 )
            var_0.outside = 0;
    }

    if ( shoulduseprecomputedlos() || generatinglosdata() )
    {
        var_0.radiuspathnodes = getradiuspathsighttestnodes( var_0.origin );

        if ( var_0.radiuspathnodes.size <= 0 )
        {

        }
    }

    var_0.lanemask = 0;
    var_0.lanes = [];

    foreach ( var_5 in level.spawnglobals.lanetriggers )
    {
        if ( ispointinvolume( var_0.origin, var_5 ) )
        {
            var_0.lanemask = var_0.lanemask | var_5.indexflag;
            var_0.lanes[var_0.lanes.size] = var_5.index;
        }
    }

    initspawnpointvalues( var_0 );
    loginitialspawnposition( var_0 );
}

getspawnpointarray( var_0, var_1 )
{
    if ( !isdefined( level.spawnpointarray ) )
        level.spawnpointarray = [];

    if ( !isdefined( level.spawnpointarray[var_0] ) )
    {
        level.spawnpointarray[var_0] = [];

        if ( isdefined( scripts\cp_mp\utility\game_utility::getlocaleid() ) )
        {
            var_2 = getspawnarray( var_0 );

            foreach ( var_4 in var_2 )
            {
                if ( _id_12CC8( var_4 ) )
                    continue;

                if ( checkmodifiedspawnpoint( var_4 ) )
                    continue;

                if ( isdefined( var_4.script_noteworthy ) && var_4.script_noteworthy == level.localeid )
                    level.spawnpointarray[var_0][level.spawnpointarray[var_0].size] = var_4;
            }

            if ( level.spawnpointarray[var_0].size == 0 )
                level.spawnpointarray[var_0] = var_2;
        }
        else
        {
            var_2 = getspawnarray( var_0 );

            foreach ( var_4 in var_2 )
            {
                if ( _id_12CC8( var_4 ) )
                    continue;

                if ( checkmodifiedspawnpoint( var_4 ) )
                    continue;

                if ( isdefined( var_4.script_noteworthy ) && issubstr( var_4.script_noteworthy, "locale" ) )
                    continue;

                level.spawnpointarray[var_0][level.spawnpointarray[var_0].size] = var_4;
            }
        }
    }

    var_8 = level.spawnpointarray[var_0];

    if ( istrue( var_1 ) )
    {
        level.spawnpointarray[var_0] = level._id_12F8C[var_0];
        return level.spawnpointarray[var_0];
    }

    if ( isdefined( level._id_12F8C ) && isdefined( level._id_12F8C[var_0] ) )
        var_8 = scripts\engine\utility::array_combine( var_8, level._id_12F8C[var_0] );

    return var_8;
}

getspawnpointfromcode()
{
    var_0 = self getspawnpointforplayer();
    getentitylessscriptablearray( "mp_spawn_event", [ "score", var_0.score, "threatsight", var_0.threatsight, "totalscore", var_0.totalscore, "spawnx", var_0.origin[0], "spawny", var_0.origin[1], "spawnz", var_0.origin[2] ] );
    var_0.bucket = getspawnbucketfromstring( var_0.score );
    var_0.isbadspawn = var_0.score == "bad";
    logcodefrontlineupdate( var_0 );
    return var_0;
}

logcodefrontlineupdate( var_0 )
{
    if ( scripts\mp\matchrecording::matchrecording_isenabled() )
    {
        if ( istrue( var_0.frontlineenabled ) )
        {
            var_1 = scripts\engine\utility::ter_op( self.team == "allies", var_0.frontlineused, 1 );
            var_2 = scripts\engine\utility::ter_op( self.team == "axis", var_0.frontlineused, 1 );
            var_3 = rotatevector( var_0.frontlinedir, ( 0, 90, 0 ) );
            scripts\mp\spawnfactor::logfrontlinetomatchrecording( var_0.frontlinepos, var_3, var_1, var_2 );
        }
    }
}

getspawnpoint_random( var_0 )
{
    if ( !isdefined( var_0 ) )
        return undefined;

    var_1 = undefined;
    var_0 = scripts\mp\spawnscoring::checkdynamicspawns( var_0 );
    var_0 = scripts\engine\utility::array_randomize( var_0 );

    foreach ( var_3 in var_0 )
    {
        var_1 = var_3;

        if ( canspawn( var_1.origin ) && !positionwouldtelefrag( var_1.origin ) )
            break;
    }

    return var_1;
}

getspawnpoint_startspawn( var_0, var_1 )
{
    if ( !isdefined( var_0 ) )
        return undefined;

    var_2 = undefined;
    var_0 = scripts\mp\spawnscoring::checkdynamicspawns( var_0 );

    foreach ( var_4 in var_0 )
    {
        if ( !isdefined( var_4.selected ) )
            continue;

        if ( var_4.selected )
            continue;

        if ( var_4.infront )
        {
            var_2 = var_4;
            break;
        }

        var_2 = var_4;
    }

    if ( !isdefined( var_2 ) )
    {
        if ( istrue( var_1 ) )
            return undefined;

        var_2 = getspawnpoint_random( var_0 );
    }

    if ( isdefined( var_2 ) )
        var_2.selected = 1;

    return var_2;
}

trackgrenades()
{
    for (;;)
    {
        level.grenades = getentarray( "grenade", "classname" );
        wait 0.05;
    }
}

trackmissiles()
{
    for (;;)
    {
        level.missiles = getentarray( "rocket", "classname" );
        wait 0.05;
    }
}

trackcarepackages()
{
    for (;;)
    {
        level.carepackages = getentarray( "care_package", "targetname" );
        wait 0.05;
    }
}

getteamspawnpoints( var_0 )
{
    return level.teamspawnpoints[var_0];
}

getteamfallbackspawnpoints( var_0 )
{
    return level.teamfallbackspawnpoints[var_0];
}

ispathdataavailable()
{
    if ( !isdefined( level.pathdataavailable ) )
        level.pathdataavailable = getsentientcounts() > 150;

    return level.pathdataavailable;
}

addtoparticipantsarray()
{
    level.participants[level.participants.size] = self;
}

removefromparticipantsarray()
{
    var_0 = 0;

    for ( var_1 = 0; var_1 < level.participants.size; var_1++ )
    {
        if ( level.participants[var_1] == self )
        {
            for ( var_0 = 1; var_1 < level.participants.size - 1; var_1++ )
                level.participants[var_1] = level.participants[var_1 + 1];

            level.participants[var_1] = undefined;
            break;
        }
    }
}

addtocharactersarray()
{
    level.characters[level.characters.size] = self;
}

removefromcharactersarray()
{
    var_0 = 0;

    for ( var_1 = 0; var_1 < level.characters.size; var_1++ )
    {
        if ( level.characters[var_1] == self )
        {
            for ( var_0 = 1; var_1 < level.characters.size - 1; var_1++ )
                level.characters[var_1] = level.characters[var_1 + 1];

            level.characters[var_1] = undefined;
            break;
        }
    }
}

spawnpointupdate()
{
    while ( !isdefined( level.spawnpoints ) || level.spawnpoints.size == 0 )
        waitframe();

    var_0 = generatinglosdata();

    if ( shoulduseprecomputedlos() || var_0 )
    {
        if ( var_0 )
        {
            wait 1.0;
            var_1 = getentarray();

            foreach ( var_3 in var_1 )
            {
                if ( isdefined( var_3.classname ) && var_3.classname == "script_brushmodel" && var_3.spawnflags & 1 )
                    var_3 connectpaths();

                if ( isdefined( var_3.targetname ) && var_3.targetname == "dynamic_door" )
                    var_3 delete();
            }

            waitframe();
        }

        var_5 = [];

        if ( level.spawnpoints.size == 0 )
            scripts\engine\utility::error( "Spawn System Failure. No Spawnpoints found." );

        for ( var_6 = 0; var_6 < level.spawnpoints.size; var_6++ )
        {
            for ( var_7 = 0; var_7 < level.spawnpoints[var_6].radiuspathnodes.size; var_7++ )
                var_5[var_5.size] = level.spawnpoints[var_6].radiuspathnodes[var_7];
        }

        if ( var_5.size > 0 )
            cachespawnpathnodesincode( var_5 );
        else if ( !istrue( level.nopathnodes ) && !istrue( level.largemap ) )
            scripts\engine\utility::error( "Spawn System Failure. There are no pathnodes near any spawnpoints." );
    }
}

getactiveplayerlist()
{
    var_0 = [];

    foreach ( var_2 in level.characters )
    {
        if ( !scripts\mp\utility\player::isreallyalive( var_2 ) )
            continue;

        if ( isplayer( var_2 ) )
        {
            if ( var_2.sessionstate != "playing" )
                continue;

            if ( !var_2 scripts\mp\utility\player::isplayerallowedforspawnlogic() )
                continue;
        }

        var_2.spawnlogicteam = getspawnteam( var_2 );

        if ( var_2.spawnlogicteam == "spectator" )
            continue;

        if ( isagent( var_2 ) && var_2.agent_type == "seeker" )
            continue;

        var_3 = getplayertraceheight( var_2 );
        var_4 = var_2 geteye();
        var_4 = ( var_4[0], var_4[1], var_2.origin[2] + var_3 );
        var_2.spawnlogictraceheight = var_3;
        var_2.spawntracelocation = var_4;
        var_0[var_0.size] = var_2;
    }

    return var_0;
}

addspawnviewer( var_0 )
{
    var_0 registerentityspawnviewer();
}

removespawnviewer( var_0 )
{
    var_0 clearentityspawnviewer();
}

addspawndangerzone( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8, var_9 )
{
    return influencepoint_add( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8, var_9 );
}

removespawndangerzone( var_0 )
{
    influencepoint_remove( var_0 );
}

isspawndangerzonealive( var_0 )
{
    return influencepoint_isscripthandlevalid( var_0 );
}

getdefaultminedangerzoneradiussize()
{
    return 350;
}

influencepoint_add( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8, var_9 )
{
    if ( !isdefined( var_3 ) && isdefined( var_5 ) )
        var_3 = var_5.team;

    var_10 = undefined;

    if ( isdefined( var_5 ) && isplayer( var_5 ) )
    {
        if ( isdefined( var_6 ) )
            var_10 = destroyspawninfluencepoint( var_0, var_1, var_2, var_3, var_5, var_6 );
        else
            var_10 = destroyspawninfluencepoint( var_0, var_1, var_2, var_3, var_5 );
    }
    else
        var_10 = destroyspawninfluencepoint( var_0, var_1, var_2, var_3 );

    if ( !isdefined( var_10 ) )
        return;

    var_11 = influencepoint_getnewscripthandle( var_10 );

    if ( !istrue( var_9 ) )
        thread influencepoint_cleanupthink( var_11, ::removespawndangerzone, var_7, var_4, var_8 );

    return var_11;
}

influencepoint_remove( var_0 )
{
    var_1 = influencepoint_getcodehandlefromscripthandle( var_0 );
    animsetgetanimfromindex( var_1 );
    influencepoint_invalidatescripthandlesforcodehandle( var_1 );
}

influencepoint_getnewscripthandle( var_0 )
{
    var_1 = level.spawnglobals;

    if ( !isdefined( var_1.influencenodealloccounts[var_0] ) )
        var_1.influencenodealloccounts[var_0] = 0;

    var_2 = var_1.influencenodealloccounts[var_0];
    var_3 = var_2 << 16 | var_0;
    return var_3;
}

influencepoint_invalidatescripthandlesforcodehandle( var_0 )
{
    var_1 = level.spawnglobals;
    var_1.influencenodealloccounts[var_0]++;
    var_2 = var_1.influencenodealloccounts[var_0];

    if ( var_2 >= 65535 )
    {
        var_2 = 0;
        var_1.influencenodealloccounts[var_0] = 0;
    }
}

influencepoint_getcodehandlefromscripthandle( var_0 )
{
    return var_0 & 65535;
}

influencepoint_getalloccountfromscripthandle( var_0 )
{
    return var_0 >> 16;
}

influencepoint_isscripthandlevalid( var_0 )
{
    var_1 = level.spawnglobals;
    var_2 = influencepoint_getalloccountfromscripthandle( var_0 );
    var_3 = influencepoint_getcodehandlefromscripthandle( var_0 );
    var_4 = var_1.influencenodealloccounts[var_3];
    return isdefined( var_4 ) && var_2 == var_4;
}

influencepoint_cleanupthink( var_0, var_1, var_2, var_3, var_4 )
{
    level endon( "game_ended" );
    var_5 = [];

    if ( isdefined( var_4 ) )
        var_5[var_5.size] = "death";

    if ( isdefined( var_3 ) )
    {
        if ( var_5.size > 0 )
            var_2 scripts\engine\utility::waittill_any_in_array_or_timeout_no_endon_death( var_5, var_3 );
        else
            wait( var_3 );
    }
    else if ( isdefined( var_2 ) )
        var_2 scripts\engine\utility::waittill_any_in_array_return( var_5 );

    if ( !influencepoint_isscripthandlevalid( var_0 ) )
        return;

    [[ var_1 ]]( var_0 );
}

updatespawnviewers()
{
    level.spawnviewers = getactiveplayerlist();

    foreach ( var_1 in level.spawnviewers )
        var_1.spawnviewpathnodes = undefined;

    foreach ( var_4 in level.turrets )
    {
        if ( !isdefined( var_4 ) )
            continue;

        var_4.spawnlogicteam = getspawnteam( var_4 );
        level.spawnviewers[level.spawnviewers.size] = var_4;
        var_4.spawnviewpathnodes = undefined;
    }

    foreach ( var_7 in level.ugvs )
    {
        if ( !isdefined( var_7 ) )
            continue;

        var_7.spawnlogicteam = getspawnteam( var_7 );
        level.spawnviewers[level.spawnviewers.size] = var_7;
        var_7.spawnviewpathnodes = undefined;
    }
}

arespawnviewersvalid()
{
    return isdefined( level.spawnviewersupdatetime ) && level.spawnviewersupdatetime == gettime();
}

logspawnpointsightupdate( var_0, var_1 )
{
    if ( istrue( var_0.buddyspawn ) || istrue( var_0.isdynamicspawn ) )
        return;

    if ( isdefined( level.matchrecording_logevent ) )
    {
        if ( isdefined( level.matchrecording_generateid ) && !isdefined( var_0.logid ) )
            var_0.logid = [[ level.matchrecording_generateid ]]();

        if ( isdefined( var_0.logid ) )
        {
            var_2 = 3;

            if ( level.teambased )
            {
                var_3 = 1;
                var_4 = 1;

                if ( var_1 == "allies" )
                {
                    var_3 = var_0.logspawndisabled["allies"] == 0;
                    var_5 = isdefined( var_0.loggedstate ) && ( var_0.loggedstate == 0 || var_0.loggedstate == 2 );
                    var_4 = scripts\engine\utility::ter_op( isdefined( var_0.loggedstate ), var_5, 0 );
                }
                else
                {
                    var_4 = var_0.logspawndisabled["axis"] == 0;
                    var_6 = isdefined( var_0.loggedstate ) && ( var_0.loggedstate == 0 || var_0.loggedstate == 1 );
                    var_3 = scripts\engine\utility::ter_op( isdefined( var_0.loggedstate ), var_6, 0 );
                }

                if ( var_3 && var_4 )
                    var_2 = 0;
                else if ( var_3 )
                    var_2 = 1;
                else if ( var_4 )
                    var_2 = 2;
            }
            else
                var_2 = scripts\engine\utility::ter_op( var_0.fullsights["all"] == 0, 0, 3 );

            if ( !isdefined( var_0.loggedstate ) || var_0.loggedstate != var_2 )
            {
                [[ level.matchrecording_logevent ]]( var_0.logid, "allies", "SPAWN_ENTITY", var_0.origin[0], var_0.origin[1], gettime(), var_2 );
                var_0.loggedstate = var_2;
            }
        }
    }
}

loginitialspawnposition( var_0 )
{
    if ( istrue( var_0.buddyspawn ) || istrue( var_0.isdynamicspawn ) )
        return;

    if ( isdefined( level.matchrecording_logevent ) )
    {
        if ( isdefined( level.matchrecording_generateid ) && !isdefined( var_0.logid ) )
            var_0.logid = [[ level.matchrecording_generateid ]]();

        if ( isdefined( var_0.logid ) && !isdefined( var_0.didinitiallog ) )
        {
            [[ level.matchrecording_logevent ]]( var_0.logid, "allies", "SPAWN_ENTITY", var_0.origin[0], var_0.origin[1], gettime(), 0 );
            var_0.didinitiallog = 1;
        }
    }
}

spawnpointdistanceupdate( var_0 )
{
    foreach ( var_2 in level.spawnviewers )
    {
        var_3 = distancesquared( var_2.origin, var_0.origin );

        if ( var_3 < var_0.mindistsquared[var_2.spawnlogicteam] )
            var_0.mindistsquared[var_2.spawnlogicteam] = var_3;

        if ( var_2.spawnlogicteam == "spectator" )
            continue;

        var_0.distsumsquared[var_2.spawnlogicteam] = var_0.distsumsquared[var_2.spawnlogicteam] + var_3;
        var_0.distsumsquaredcapped[var_2.spawnlogicteam] = var_0.distsumsquaredcapped[var_2.spawnlogicteam] + min( var_3, scripts\mp\spawnfactor::maxplayerspawninfluencedistsquared() );
        var_0.totalplayers[var_2.spawnlogicteam]++;
    }

    var_0.hasdistdata = 1;
}

getspawnteam( var_0 )
{
    var_1 = "all";

    if ( level.teambased )
        var_1 = var_0.team;

    return var_1;
}

initspawnpointvalues( var_0 )
{
    clearspawnpointsightdata( var_0 );
    clearspawnpointdistancedata( var_0 );
}

clearspawnpointsightdata( var_0 )
{
    if ( level.teambased )
    {
        foreach ( var_2 in level.teamnamelist )
            clearteamspawnpointsightdata( var_0, var_2 );
    }
    else
        clearteamspawnpointsightdata( var_0, "all" );
}

setupplayerspawnsightdata( var_0 )
{

}

clearspawnpointdistancedata( var_0 )
{
    if ( level.teambased )
    {
        foreach ( var_2 in level.teamnamelist )
            clearteamspawnpointdistancedata( var_0, var_2 );
    }
    else
        clearteamspawnpointdistancedata( var_0, "all" );
}

clearteamspawnpointsightdata( var_0, var_1 )
{
    var_0.hassightdata[var_1] = 0;
    var_0.fullsights[var_1] = 0;
    var_0.cornersights[var_1] = 0;
    var_0.logspawndisabled[var_1] = 0;
    var_0.maxsightvalue[var_1] = 0.0;
    var_0.maxjumpsightvalue[var_1] = 0.0;
}

clearteamspawnpointdistancedata( var_0, var_1 )
{
    var_0.hasdistdata = 0;
    var_0.distsumsquared[var_1] = 0;
    var_0.distsumsquaredcapped[var_1] = 0;
    var_0.mindistsquared[var_1] = 9999999;
    var_0.totalplayers[var_1] = 0;
}

getplayertraceheight( var_0, var_1 )
{
    if ( isdefined( var_1 ) && var_1 )
        return 64;

    var_2 = var_0 getstance();

    if ( var_2 == "stand" )
        return 64;

    if ( var_2 == "crouch" )
        return 44;

    return 32;
}

additionalsighttraceentities( var_0, var_1 )
{
    foreach ( var_3 in var_1 )
    {
        if ( !isdefined( var_3 ) )
            continue;

        var_4 = getspawnteam( var_3 );

        if ( var_0.fullsights[var_4] )
            continue;

        var_0.hassightdata[var_4] = 1;
        var_5 = var_3.origin + ( 0, 0, 50 );
        var_6 = 0.0;

        if ( !var_6 )
            var_6 = spawnsighttrace( var_0, var_0.sighttracepoint, var_5 );

        if ( !var_6 )
            continue;

        if ( var_6 > 0.95 )
        {
            var_0.fullsights[var_4]++;
            continue;
        }

        var_0.cornersights[var_4]++;
    }
}

finalizespawnpointchoice( var_0 )
{
    if ( !isplayer( self ) )
        return;

    var_1 = gettime();
    self.lastspawnpoint = var_0;
    self.lastspawntime = var_1;
    var_0.lastspawntime = var_1;
    var_0.lastspawnteam = self.team;

    if ( !isdefined( var_0.bucket ) )
        self finalizespawnpointchoiceforplayer( var_0.index );
    else
    {
        if ( !isdefined( var_0._id_140AD ) )
            var_0._id_140AD = 0;

        if ( !isdefined( var_0.threatsight ) )
            var_0.threatsight = -1.0;

        if ( !isdefined( var_0.damagemod ) )
            var_0.damagemod = -1;

        self finalizespawnpointchoiceforplayer( var_0.index, var_0.bucket, var_0._id_140AD, var_0.threatsight, var_0.damagemod );
    }

    var_2 = level.spawnglobals.spawnpointscriptdata[var_0.index];

    if ( isdefined( var_2 ) )
        var_2.used = 1;

    level.spawnglobals.lastteamspawnpoints[self.team] = var_0;
}

expandspawnpointbounds( var_0 )
{
    var_1 = getspawnpointarray( var_0 );

    for ( var_2 = 0; var_2 < var_1.size; var_2++ )
    {
        level.spawnmins = expandmins( level.spawnmins, var_1[var_2].origin );
        level.spawnmaxs = expandmaxs( level.spawnmaxs, var_1[var_2].origin );
    }
}

expandmins( var_0, var_1 )
{
    if ( var_0[0] > var_1[0] )
        var_0 = ( var_1[0], var_0[1], var_0[2] );

    if ( var_0[1] > var_1[1] )
        var_0 = ( var_0[0], var_1[1], var_0[2] );

    if ( var_0[2] > var_1[2] )
        var_0 = ( var_0[0], var_0[1], var_1[2] );

    return var_0;
}

expandmaxs( var_0, var_1 )
{
    if ( var_0[0] < var_1[0] )
        var_0 = ( var_1[0], var_0[1], var_0[2] );

    if ( var_0[1] < var_1[1] )
        var_0 = ( var_0[0], var_1[1], var_0[2] );

    if ( var_0[2] < var_1[2] )
        var_0 = ( var_0[0], var_0[1], var_1[2] );

    return var_0;
}

findboxcenter( var_0, var_1 )
{
    var_2 = ( 0, 0, 0 );
    var_2 = var_1 - var_0;
    var_2 = ( var_2[0] / 2, var_2[1] / 2, var_2[2] / 2 ) + var_0;
    return var_2;
}

setmapcenterfordev()
{
    level.spawnmins = ( 0, 0, 0 );
    level.spawnmaxs = ( 0, 0, 0 );
    expandspawnpointbounds( "mp_tdm_spawn_allies_start" );
    expandspawnpointbounds( "mp_tdm_spawn_axis_start" );
    level.mapcenter = findboxcenter( level.spawnmins, level.spawnmaxs );
    setmapcenter( level.mapcenter );
}

shoulduseteamstartspawn()
{
    if ( getdvarint( "scr_forceStartSpawns", 0 ) == 1 )
        return 1;

    if ( !scripts\mp\flags::gameflag( "prematch_done" ) && isdefined( game["infil"] ) && !scripts\mp\flags::gameflag( "infil_started" ) )
        return 1;

    if ( istrue( level.disableteamstartspawns ) )
        return 0;

    return level.ingraceperiod && ( !isdefined( level.numkills ) || level.numkills == 0 );
}

getpathsighttestnodes( var_0, var_1 )
{
    if ( var_1 )
    {
        var_2 = 0;
        var_3 = getclosenoderadiusdist();
    }
    else
    {
        var_2 = getclosenoderadiusdist();
        var_3 = 250;
    }

    return getnodesinradius( var_0, var_3, var_2, 512, "path" );
}

getradiuspathsighttestnodes( var_0 )
{
    var_1 = [];
    var_2 = getclosestnodeinsight( var_0 );

    if ( isdefined( var_2 ) )
        var_1[0] = var_2;

    if ( !isdefined( var_2 ) )
    {
        var_1 = getnodesinradius( var_0, getclosenoderadiusdist(), 0, 256, "path" );

        if ( var_1.size == 0 )
            var_1 = getnodesinradius( var_0, 250, 0, 256, "path" );
    }

    return var_1;
}

evaluateprecomputedlos( var_0, var_1 )
{
    checkttlosloaded();
    var_2 = "all";

    if ( level.teambased )
        var_2 = scripts\mp\utility\teams::getenemyteams( var_1 )[0];

    if ( !shoulduseprecomputedlos() )
    {
        var_0.hassightdata[var_2] = 1;
        return;
    }

    var_3 = 0.95;
    var_4 = 0;
    var_5 = undefined;
    var_6 = undefined;
    var_3 = level.spawnglobals.lowerlimitfullsights;
    var_4 = level.spawnglobals.lowerlimitcornersights;

    foreach ( var_8 in level.spawnviewers )
    {
        if ( level.teambased && var_8.spawnlogicteam != var_2 )
            continue;

        if ( var_0.fullsights[var_8.spawnlogicteam] )
            break;

        if ( !isdefined( var_8.spawnviewpathnodes ) )
        {
            var_8.spawnviewpathnodes = var_8 getnearnodelistforspawncheck( getfarnoderadiusdist() );

            if ( !isdefined( var_8.spawnviewpathnodes ) || var_8.spawnviewpathnodes.size == 0 )
            {
                if ( isdefined( level.matchrecording_logeventmsg ) && isplayer( var_8 ) )
                {
                    if ( !isdefined( var_8.lastpathnodewarningtime ) || var_8.lastpathnodewarningtime != gettime() )
                    {
                        [[ level.matchrecording_logeventmsg ]]( "LOG_GENERIC_MESSAGE", gettime(), "WARNING: Could not use TTLOS data for player " + var_8.name );
                        var_8.lastpathnodewarningtime = gettime();
                    }
                }
            }
        }

        if ( isdefined( var_8.spawnviewpathnodes ) && var_8.spawnviewpathnodes.size > 0 )
        {
            var_9 = _precomputedlosdatatest( var_8, var_0 );
            var_5 = var_9[0];
            var_6 = var_9[1];
        }

        if ( !isdefined( var_5 ) )
        {
            var_10 = undefined;

            if ( isplayer( var_8 ) )
                var_10 = var_8 geteye();
            else
                var_10 = var_8.origin + ( 0, 0, 50 );

            var_5 = directlineofsighttest( var_0, var_8, var_10 );
            var_6 = var_5;
        }

        if ( !isdefined( var_0.maxsightvalue[var_8.spawnlogicteam] ) || var_5 > var_0.maxsightvalue[var_8.spawnlogicteam] )
            var_0.maxsightvalue[var_8.spawnlogicteam] = var_5;

        if ( isdefined( var_6 ) && isplayer( var_8 ) )
        {
            if ( !isdefined( var_0.maxjumpsightvalue[var_8.spawnlogicteam] ) || var_6 > var_0.maxjumpsightvalue[var_8.spawnlogicteam] )
                var_0.maxjumpsightvalue[var_8.spawnlogicteam] = var_6;
        }

        if ( var_5 > var_3 )
        {
            var_0.fullsights[var_8.spawnlogicteam]++;
            var_0.logspawndisabled[var_8.spawnlogicteam]++;
            continue;
        }

        if ( var_5 > var_4 )
            var_0.cornersights[var_8.spawnlogicteam]++;
    }

    var_0.hassightdata[var_2] = 1;
    logspawnpointsightupdate( var_0, var_2 );
}

_precomputedlosdatatest( var_0, var_1 )
{
    var_2 = checkttlosoverrides( var_0, var_1 );

    if ( !isdefined( var_2 ) )
    {
        if ( checkttlosdeverrors( var_0, var_1 ) )
            return [ 1.0, 1.0 ];

        var_2 = precomputedlosdatatest( var_0.spawnviewpathnodes, var_1.radiuspathnodes );
    }

    return var_2;
}

checkttlosdeverrors( var_0, var_1 )
{
    return 0;
}

checkttlosoverrides( var_0, var_1 )
{
    if ( !isdefined( level.spawnglobals.ttlosoverrides ) )
        return;

    foreach ( var_3 in var_0.spawnviewpathnodes )
    {
        var_4 = var_3 getnodenumber();

        if ( isdefined( level.spawnglobals.ttlosoverrides[var_4] ) )
        {
            foreach ( var_6 in var_1.radiuspathnodes )
            {
                var_7 = var_6 getnodenumber();

                if ( isdefined( level.spawnglobals.ttlosoverrides[var_4][var_7] ) )
                    return level.spawnglobals.ttlosoverrides[var_4][var_7];
            }
        }
    }
}

addttlosoverride( var_0, var_1, var_2, var_3 )
{
    level endon( "game_ended" );

    for (;;)
    {
        if ( isdefined( level.spawnglobals ) )
            break;

        waitframe();
    }

    if ( !isdefined( level.spawnglobals.ttlosoverrides ) )
        level.spawnglobals.ttlosoverrides = [];

    if ( !isdefined( level.spawnglobals.ttlosoverrides[var_0] ) )
        level.spawnglobals.ttlosoverrides[var_0] = [];

    level.spawnglobals.ttlosoverrides[var_0][var_1] = [ var_2, var_3 ];

    if ( !isdefined( level.spawnglobals.ttlosoverrides[var_1] ) )
        level.spawnglobals.ttlosoverrides[var_1] = [];

    level.spawnglobals.ttlosoverrides[var_1][var_0] = [ var_2, var_3 ];
}

getclosenoderadiusdist()
{
    return 130;
}

getfarnoderadiusdist()
{
    return 250;
}

directlineofsighttest( var_0, var_1, var_2 )
{
    var_3 = var_0.sighttracepoint;
    var_4 = var_2;
    var_5 = physics_createcontents( [ "physicscontents_solid", "physicscontents_ainosight" ] );
    var_6 = physics_raycast( var_3, var_4, var_5, var_1, 0, "physicsquery_any" );
    return scripts\engine\utility::ter_op( var_6, 0.0, 1.0 );
}

getmaxdistancetolos()
{
    return 2550;
}

checkttlosloaded()
{
    if ( shoulduseprecomputedlos() && !isttlosdataavailable() )
    {
        if ( isdefined( level.matchrecording_logeventmsg ) )
            [[ level.matchrecording_logeventmsg ]]( "LOG_GENERIC_MESSAGE", gettime(), "ERROR: TTLOS System disabled! Could not access visDistData" );

        if ( !isdefined( level.hasshownvisdistdataerror ) )
            level.hasshownvisdistdataerror = 1;

        level.disableprecomputedlos = 1;
    }
}

shoulduseprecomputedlos()
{
    return getdvarint( "LSQOPROPRS", 0 ) == 1 && !isdefined( level.disableprecomputedlos ) && !generatinglosdata();
}

generatinglosdata()
{
    return getdvarint( "NLRMTTPMTQ", 0 ) > 0;
}

isttlosdataavailable()
{
    return getislosdatafileloaded();
}

printstartupdebugmessages()
{
    level waittill( "prematch_done" );

    if ( getdvarint( "scr_playtest", 0 ) == 1 && isdefined( level.players ) )
    {
        foreach ( var_1 in level.players )
        {
            if ( var_1 ishost() )
            {
                if ( !shoulduseprecomputedlos() )
                    var_1 iprintlnbold( "TTLOS FAILED TO LOAD!" );

                break;
            }
        }
    }

    if ( isdefined( level.matchrecording_logeventmsg ) )
    {
        [[ level.matchrecording_logeventmsg ]]( "LOG_GENERIC_MESSAGE", gettime(), "Spawn Script Version #6" );

        if ( shoulduseprecomputedlos() )
            [[ level.matchrecording_logeventmsg ]]( "LOG_GENERIC_MESSAGE", gettime(), "Attempting to use TTLOS Spawning Data..." );
        else
            [[ level.matchrecording_logeventmsg ]]( "LOG_GENERIC_MESSAGE", gettime(), "No TTLOS Data! Not using TTLOS" );

        [[ level.matchrecording_logeventmsg ]]( "LOG_GENERIC_MESSAGE", gettime(), "CODE spawn logic enabled" );

        if ( isdefined( level.spawnglobals.activespawnlogic ) )
            [[ level.matchrecording_logeventmsg ]]( "LOG_GENERIC_MESSAGE", gettime(), "Spawn Logic: " + level.spawnglobals.activespawnlogic );
        else
            [[ level.matchrecording_logeventmsg ]]( "LOG_GENERIC_MESSAGE", gettime(), "Spawn Logic: None" );
    }
}

isfallbackspawn( var_0 )
{
    return istrue( var_0.isfallback );
}

logextraspawninfothink()
{
    if ( getdvarint( "scr_extra_spawn_logging", 0 ) != 1 )
        return;

    level waittill( "prematch_done" );
    var_0 = undefined;
    var_1 = undefined;

    if ( isdefined( level.matchrecording_generateid ) )
    {
        var_0 = [[ level.matchrecording_generateid ]]();
        var_1 = [[ level.matchrecording_generateid ]]();
    }

    for (;;)
    {
        if ( !shoulduseprecomputedlos() )
            break;

        logextraspawn( "allies", var_0 );
        wait 0.5;
        logextraspawn( "axis", var_1 );
        wait 0.5;
    }
}

logextraspawn( var_0, var_1 )
{
    var_2 = spawnstruct();
    var_2.team = var_0;
    var_2.pers = [];
    var_2.pers["team"] = var_0;
    var_2.disablespawnwarnings = 1;
    var_2.isdynamicspawn = 1;
    var_3 = var_2 [[ level.getspawnpoint ]]();

    if ( isdefined( level.matchrecording_logevent ) && isdefined( var_3 ) && isdefined( var_1 ) )
    {
        var_4 = scripts\engine\utility::ter_op( var_0 == "allies", "BEST_SPAWN_ALLIES", "BEST_SPAWN_AXIS" );
        [[ level.matchrecording_logevent ]]( var_1, var_0, var_4, var_3.origin[0], var_3.origin[1], gettime() );
    }
}

clearlastteamspawns()
{
    level.spawnglobals.lastteamspawnpoints = [];
}

getoriginidentifierstring( var_0 )
{
    return int( var_0.origin[0] ) + " " + int( var_0.origin[1] ) + " " + int( var_0.origin[2] );
}

respawn_delay( var_0 )
{
    return int( var_0.origin[0] ) + " " + int( var_0.origin[1] );
}

checkmodifiedspawnpoint( var_0 )
{
    if ( !isdefined( level.modifiedspawnpoints ) )
        return 0;

    var_1 = undefined;
    var_2 = getoriginidentifierstring( var_0 );

    if ( isdefined( level.modifiedspawnpoints[var_2] ) )
        var_1 = level.modifiedspawnpoints[var_2][var_0.classname];

    if ( !isdefined( var_1 ) )
    {
        var_2 = respawn_delay( var_0 );

        if ( isdefined( level.modifiedspawnpoints[var_2] ) )
            var_1 = level.modifiedspawnpoints[var_2][var_0.classname];

        if ( !isdefined( var_1 ) )
            return 0;
    }

    if ( istrue( var_1["remove"] ) )
        return 1;

    if ( isdefined( var_1["origin"] ) )
        var_0.origin = var_1["origin"];

    if ( isdefined( var_1["angles"] ) )
        var_0.angles = var_1["angles"];

    if ( istrue( var_1["no_alternates"] ) )
        var_0.noalternates = 1;

    return 0;
}

_id_12CC8( var_0 )
{
    if ( isdefined( var_0.script_noteworthy ) && var_0.script_noteworthy != "" )
    {
        var_1 = strtok( var_0.script_noteworthy, " " );

        foreach ( var_3 in var_1 )
        {
            if ( level._id_11AD3 == 1 )
            {
                if ( var_3 == "6v6" )
                    return 1;
            }
            else if ( var_3 == "10v10" )
                return 1;
        }
    }

    return 0;
}

calculateteamclusters( var_0 )
{
    var_1 = spawnstruct();
    var_1.clusterlist = [];

    foreach ( var_3 in level.players )
    {
        if ( !scripts\mp\utility\player::isreallyalive( var_3 ) || var_3.team != var_0 || !var_3 scripts\mp\utility\player::isplayerallowedforspawnlogic() )
            continue;

        var_4 = createcluster( var_3 );
        var_1.clusterlist[var_1.clusterlist.size] = var_4;
    }

    mergeclusterlist( var_1 );
    return var_1;
}

createcluster( var_0 )
{
    var_1 = spawnstruct();
    var_1.center = var_0.origin;
    var_1.players = [ var_0 ];
    return var_1;
}

mergeclusterlist( var_0 )
{
    var_1 = undefined;
    var_2 = undefined;
    var_3 = undefined;
    var_4 = -1;

    for ( var_5 = 0; var_5 < var_0.clusterlist.size; var_5++ )
    {
        var_6 = var_0.clusterlist[var_5];

        for ( var_7 = var_5 + 1; var_7 < var_0.clusterlist.size; var_7++ )
        {
            var_8 = var_0.clusterlist[var_7];
            var_9 = distance2dsquared( var_6.center, var_8.center );

            if ( var_9 > 640000 )
                continue;

            if ( var_4 < 0 || var_9 < var_4 )
            {
                var_4 = var_9;
                var_1 = var_6;
                var_2 = var_8;
                var_3 = var_7;
            }
        }
    }

    if ( isdefined( var_1 ) && isdefined( var_2 ) )
    {
        foreach ( var_11 in var_2.players )
            var_1.players[var_1.players.size] = var_11;

        var_13 = ( 0, 0, 0 );

        foreach ( var_11 in var_1.players )
            var_13 = var_13 + var_11.origin;

        var_13 = var_13 / var_1.players.size;
        var_1.center = var_13;
        var_16 = var_0.clusterlist.size - 1;
        var_0.clusterlist[var_3] = var_0.clusterlist[var_16];
        var_0.clusterlist[var_16] = undefined;
        mergeclusterlist( var_0 );
    }
}

ignoretriggerenter( var_0, var_1 )
{
    if ( !isplayer( var_0 ) )
        return;

    var_0 scripts\mp\utility\player::enableplayerforspawnlogic( 0, "spawnIgnoreTrigger" );
}

ignoretriggerexit( var_0, var_1 )
{
    if ( !isplayer( var_0 ) )
        return;

    var_0 scripts\mp\utility\player::enableplayerforspawnlogic( 1, "spawnIgnoreTrigger" );
}

getspawnbucketfromstring( var_0 )
{
    switch ( var_0 )
    {
        case "good":
            return 0;
        case "ok":
            return 1;
        case "bad":
            return 2;
        case "buddy":
            return 3;
    }

    return 2;
}

enablespawnpointlist( var_0 )
{
    foreach ( var_2 in var_0 )
        registerspawnfactor( var_2.index );
}

disablespawnpointlist( var_0 )
{
    foreach ( var_2 in var_0 )
        enablespawnpoints( var_2.index );
}

registerspawnset( var_0, var_1 )
{
    var_2 = level.spawnglobals;
    var_2.spawnsets[var_0] = var_1;

    if ( isarray( var_1 ) )
        var_2.spawnsetlists[var_0] = var_1;
    else
        var_2.spawnsetlists[var_0] = getspawnpointarray( var_1 );

    return var_0;
}

activatespawnset( var_0, var_1 )
{
    var_2 = level.spawnglobals;

    if ( istrue( var_1 ) )
    {
        if ( var_2.activespawnsets.size == 1 && isdefined( var_2.activespawnsets[var_0] ) )
            return;

        deactivateallspawnsets();
    }
    else if ( isdefined( var_2.activespawnsets[var_0] ) )
        return;

    var_3 = var_2.spawnsets[var_0];

    if ( isarray( var_3 ) )
        enablespawnpointlist( var_3 );
    else
        enablespawnpointbyindex( var_3 );

    var_2.activespawnsets[var_0] = 1;
}

deactivatespawnset( var_0 )
{
    var_1 = level.spawnglobals;
    var_2 = [];

    foreach ( var_6, var_4 in var_1.activespawnsets )
    {
        if ( var_6 != var_0 )
        {
            var_2[var_6] = 1;
            continue;
        }

        var_5 = var_1.spawnsets[var_0];

        if ( isarray( var_5 ) )
            disablespawnpointlist( var_5 );
        else
            disablespawnpointbyindex( var_5 );
    }

    var_1.activespawnsets = var_2;
}

deactivateallspawnsets()
{
    level.spawnglobals.activespawnsets = [];
    disablespawnpointsbyclassname();
}

getspawnsetsize( var_0 )
{
    return level.spawnglobals.spawnsetlists[var_0].size;
}

getrandomspawnpointfromset( var_0 )
{
    var_1 = level.spawnglobals;
    return var_1.spawnsetlists[var_0][randomint( var_1.spawnsetlists[var_0].size )];
}

getrandomspawnpointfromactivesets()
{
    var_0 = getarraykeys( level.spawnglobals.activespawnsets );
    var_1 = undefined;

    while ( !isdefined( var_1 ) && var_0.size > 0 )
    {
        var_1 = scripts\engine\utility::random( var_0 );

        if ( getspawnsetsize( var_1 ) <= 0 )
        {
            var_0 = scripts\engine\utility::array_remove( var_0, var_1 );
            var_1 = undefined;
        }
    }

    return level.spawnglobals.spawnsetlists[var_1][randomint( level.spawnglobals.spawnsetlists[var_1].size )];
}

init_trap_room_doors( var_0, var_1, var_2, var_3, var_4 )
{
    var_5 = spawnstruct();
    var_5.classname = var_0;
    var_5.origin = var_1;
    var_5.angles = var_2;
    var_5.target = var_3;
    var_5.script_noteworthy = var_4;
    return var_5;
}

bdiedonce( var_0 )
{
    if ( !isdefined( level._id_12F8C ) )
        level._id_12F8C = [];

    foreach ( var_2 in var_0 )
    {
        var_3 = var_2.classname;
        var_4 = var_2.origin;
        var_5 = var_2.angles;

        if ( isdefined( var_2.target ) )
            var_6 = var_2.target;
        else
            var_6 = "";

        if ( isdefined( var_2.script_noteworthy ) )
            var_7 = var_2.script_noteworthy;
        else
            var_7 = "";

        if ( !isdefined( level._id_12F8C[var_3] ) )
            level._id_12F8C[var_3] = [];

        var_8 = spawnstruct();
        var_8.classname = var_3;
        var_8.origin = var_4;
        var_8.angles = var_5;
        var_9 = getoriginforanimtime( var_3, var_4, var_5, var_6, var_7 );

        if ( !isdefined( var_9 ) || var_9 < 0 )
            continue;

        var_8.index = var_9;

        if ( var_6 != "" )
            var_8.target = var_6;

        if ( var_7 != "" )
            var_8.script_noteworthy = var_7;

        level._id_12F8C[var_3][level._id_12F8C[var_3].size] = var_8;
    }

    level thread _id_12F8D();
}

_id_12F8D()
{
    level notify( "scriptedSpawnpointsOnMigration" );
    level endon( "scriptedSpawnpointsOnMigration" );

    for (;;)
    {
        level waittill( "host_migration_begin" );

        foreach ( var_1 in level._id_12F8C )
        {
            foreach ( var_3 in var_1 )
            {
                if ( isdefined( var_3.target ) )
                    var_4 = var_3.target;
                else
                    var_4 = "";

                if ( isdefined( var_3.script_noteworthy ) )
                    var_5 = var_3.script_noteworthy;
                else
                    var_5 = "";

                var_6 = getoriginforanimtime( var_3.classname, var_3.origin, var_3.angles, var_4, var_5 );
            }
        }
    }
}
