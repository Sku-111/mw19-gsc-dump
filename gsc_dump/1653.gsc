// IW8 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

vehicle_initlevelvariables()
{
    setdvarifuninitialized( "enable_vehicle_ai_using_BT", 1 );

    if ( !isdefined( level.vehicle ) )
        level.vehicle = spawnstruct();

    level.vehicle.templates = spawnstruct();
    level.vehicle.helicopter_crash_locations = getentarray( "helicopter_crash_location", "targetname" );
    level.vehicle.helicopter_crash_locations = scripts\engine\utility::array_combine( level.vehicle.helicopter_crash_locations, scripts\engine\utility::getstructarray_delete( "helicopter_crash_location", "targetname" ) );
    level.vehicle.templates.team = [];
    level.vehicle.templates.deathmodel = [];
    level.vehicle.templates.death_thread = [];
    level.vehicle.templates.driveidle = [];
    level.vehicle.templates.driveidle_r = [];
    level.vehicle.templates.rumble = [];
    level.vehicle.templates.mainturret = [];
    level.vehicle.templates.mgturret = [];
    level.vehicle.templates.death_earthquake = [];
    level.vehicle.templates.surface_effects = [];
    level.vehicle.templates.unloadgroups = [];
    level.vehicle.templates.aianims = [];
    level.vehicle.templates.landanims = [];
    level.vehicle.templates.exhaust_fx = [];
    level.vehicle.templates.engine_fx = [];
    level.vehicle.templates.shoot_shock = [];
    level.vehicle.templates.hide_part_list = [];
    level.vehicle.templates.destructible_model = [];
    level.vehicle.templates.grenade_shield = [];
    level.vehicle.templates.bullet_shield = [];
    level.vehicle.templates.death_jolt = [];
    level.vehicle.templates.death_badplace = [];
    level.vehicle.templates.idle_anim = [];
    level.vehicle.templates.helicopter_list = [];
    level.vehicle.templates.airplane_list = [];
    level.vehicle.templates.single_tread_list = [];
    level.vehicle.templates.deathanimations = [];
    level.vehicle.templates.vehicle_death_fx = [];
    level.vehicle.templates.vehicle_rocket_death_fx = [];
    level.vehicle.templates.death_radiusdamage = [];
    level.vehicle.templates.model = [];
}

ishelicopter_internal()
{
    if ( isdefined( self.isheli ) )
        return 1;

    if ( !isdefined( self.vehicletype ) )
        return 0;

    return isdefined( level.vehicle.templates.helicopter_list[self.vehicletype] );
}

isairplane_internal()
{
    return isdefined( level.vehicle.templates.airplane_list[self.vehicletype] );
}

vehicle_setuplevelvariables()
{
    if ( !scripts\engine\utility::add_init_script( "vehicle_vars", ::vehicle_setuplevelvariables ) )
        return;

    scripts\engine\utility::init_struct_class();
    vehicle_initlevelvariables();
    scripts\common\vehicle_aianim::setup_aianimthreads();
}

vehicle_precachescripts()
{
    var_0 = [];
    level.needsprecaching = [];

    if ( !isdefined( level.vehicleinitthread ) )
        level.vehicleinitthread = [];

    var_1 = getentarray( "script_vehicle", "code_classname" );

    foreach ( var_3 in var_1 )
    {
        var_3.vehicletype = tolower( var_3.vehicletype );

        if ( var_3.vehicletype == "empty" || var_3.vehicletype == "empty_heli" )
            continue;

        var_0[var_0.size] = var_3;
        vehicle_precachesetup( var_3.classname, var_3 );
    }

    if ( level.needsprecaching.size > 0 )
    {
        var_5 = "    ";

        foreach ( var_14, var_7 in level.needsprecaching )
        {
            foreach ( var_9 in var_7 )
            {
                foreach ( var_11 in var_9.reasons )
                {

                }
            }
        }

        level waittill( "never" );
    }

    return var_0;
}

vehicle_precachesetup( var_0, var_1 )
{
    if ( isdefined( level.vehicleinitthread[var_1.vehicletype] ) && isdefined( level.vehicleinitthread[var_1.vehicletype][var_1.classname] ) )
        return;

    if ( var_1.classname == "script_vehicle" )
        return;

    var_2 = [];

    if ( isdefined( level.needsprecaching[var_0] ) )
        var_2 = level.needsprecaching[var_0];

    var_3 = spawnstruct();
    var_3.pos = var_1.origin;
    var_3.reasons = [];

    if ( !isdefined( level.vehicleinitthread[var_1.vehicletype] ) )
        var_3.reasons[var_3.reasons.size] = "vehicletype \"" + var_1.vehicletype + "\" is not setup properly. Maybe you just need to re-package? Or you have a Radiant copy/paste issue where you have the wrong vehicletype set?";
    else if ( !isdefined( level.vehicleinitthread[var_1.vehicletype][var_1.classname] ) )
        var_3.reasons[var_3.reasons.size] = "classname \"" + var_1.classname + "\"  is not setup properly. Maybe you just need to re-package? Or the vehicle's Quaked is not setup properly";

    var_2[var_2.size] = var_3;
    level.needsprecaching[var_0] = var_2;
}

vehicle_setupspawners()
{
    var_0 = _getvehiclespawnerarray();

    foreach ( var_2 in var_0 )
        var_2 thread vehicle_spawnerlogic();
}

vehicle_spawnerlogic()
{
    self endon( "entitydeleted" );

    if ( isdefined( self.script_deathflag ) )
        thread scripts\engine\utility::script_func( "vehicle_spawner_deathflag" );

    self.count = 1;
    self.spawn_functions = [];

    for (;;)
    {
        self waittill( "spawned", var_0 );
        self.count--;

        if ( !isdefined( var_0 ) )
            continue;

        var_0.spawn_funcs = self.spawn_functions;
        var_0.spawner = self;
        var_0 thread scripts\engine\utility::script_func( "run_spawn_functions" );
    }
}

vehicle_triggerkillspawner( var_0 )
{
    var_0 waittill( "trigger" );

    foreach ( var_2 in vehicle_getspawnerarray() )
    {
        if ( scripts\engine\utility::is_equal( var_2.script_kill_vehicle_spawner, var_0.script_kill_vehicle_spawner ) )
            var_2 delete();
    }
}

vehicle_spawnaiarray( var_0 )
{
    var_1 = [];
    var_2 = scripts\engine\utility::ent_flag_exist( "no_riders_until_unload" ) && scripts\engine\utility::ent_flag( "no_riders_until_unload" );

    foreach ( var_4 in var_0 )
    {
        var_4.count = 1;
        var_5 = 0;

        if ( isdefined( var_4.script_drone ) )
        {
            var_5 = 1;
            var_6 = scripts\engine\utility::script_func( "dronespawn_bodyonly", var_4 );
            var_6 scripts\engine\utility::script_func( "drone_give_soul" );
        }
        else if ( isdefined( var_4.script_fakeactor ) || isdefined( var_4.script_bodyonly ) )
        {
            var_5 = 1;
            var_6 = scripts\engine\utility::script_func( "bodyonlyspawn", var_4 );
            var_6 scripts\engine\utility::script_func( "fakeactor_give_soul" );
        }
        else
            var_6 = var_4 scripts\engine\utility::script_func( "spawn_ai", var_2 );

        if ( !var_5 && !isalive( var_6 ) )
            continue;

        var_1 = scripts\engine\utility::array_add( var_1, var_6 );
    }

    var_8 = vehicle_removenonridersfromaiarray( var_1 );
    return var_8;
}

vehicle_removenonridersfromaiarray( var_0 )
{
    var_1 = [];

    foreach ( var_3 in var_0 )
    {
        if ( !ai_should_be_added( var_3 ) )
            continue;

        var_1[var_1.size] = var_3;
    }

    return var_1;
}

ai_should_be_added( var_0 )
{
    if ( isalive( var_0 ) )
        return 1;

    if ( !isdefined( var_0 ) )
        return 0;

    if ( !isdefined( var_0.classname ) )
        return 0;

    return var_0.classname == "script_model";
}

spawn_riders()
{
    if ( scripts\engine\utility::ent_flag_exist( "no_riders_until_unload" ) && !scripts\engine\utility::ent_flag( "no_riders_until_unload" ) )
    {
        self notify( "spawnedRiders" );
        return [];
    }

    var_0 = get_vehicle_riders_spawners();

    if ( !var_0.size )
    {
        self notify( "spawnedRiders" );
        return [];
    }

    var_1 = spawn_group( var_0 );
    self notify( "spawnedRiders", var_1 );
    return var_1;
}

spawn_group( var_0 )
{
    var_1 = vehicle_spawnaiarray( var_0 );
    var_1 = sort_by_startingpos( var_1 );

    foreach ( var_3 in var_1 )
        thread scripts\common\vehicle_aianim::guy_enter( var_3 );

    thread set_loaded_when_full( var_1 );
    return var_1;
}

set_loaded_when_full( var_0 )
{
    scripts\engine\utility::array_wait( var_0, "loaded", 1 );
    scripts\common\vehicle_aianim::vehicle_loaded_if_full( self );
}

spawn_unload_group( var_0 )
{
    if ( !isdefined( var_0 ) )
        return spawn_riders();

    var_1 = get_vehicle_riders_spawners();

    if ( !var_1.size )
        return [];

    var_2 = [];
    var_3 = get_vehicle_classname();

    if ( isdefined( level.vehicle.templates.unloadgroups[var_3] ) && isdefined( level.vehicle.templates.unloadgroups[var_3][var_0] ) )
    {
        var_4 = level.vehicle.templates.unloadgroups[var_3][var_0];

        for ( var_5 = 0; var_5 < var_4.size; var_5++ )
        {
            if ( isdefined( var_1[var_5] ) )
                var_1[var_5].script_startingposition = var_4[var_5];
        }

        var_1 = sort_by_startingpos( var_1 );

        foreach ( var_7 in var_4 )
        {
            foreach ( var_9 in var_1 )
            {
                if ( var_9.script_startingposition == var_7 )
                    var_2[var_2.size] = var_9;
            }
        }

        var_12 = vehicle_spawnaiarray( var_2 );

        foreach ( var_14 in var_12 )
            thread scripts\common\vehicle_aianim::guy_enter( var_14 );

        self notify( "spawnedRiders", var_12 );
        return var_12;
    }
    else
        return spawn_riders();
}

sort_by_startingpos( var_0 )
{
    var_1 = [];
    var_2 = [];

    foreach ( var_4 in var_0 )
    {
        if ( isdefined( var_4.script_startingposition ) )
        {
            var_1[var_1.size] = var_4;
            continue;
        }

        var_2[var_2.size] = var_4;
    }

    return scripts\engine\utility::array_combine( var_1, var_2 );
}

remove_vehicle_spawned_thisframe()
{
    waitframe();
    self.vehicle_spawned_thisframe = undefined;
}

vehicle_init( var_0 )
{
    var_1 = var_0 get_vehicle_classname();

    if ( isdefined( level.vehicle.templates.hide_part_list[var_1] ) )
    {
        foreach ( var_3 in level.vehicle.templates.hide_part_list[var_1] )
            var_0 hidepart( var_3 );
    }

    if ( var_0.vehicletype == "empty" || var_0.vehicletype == "empty_heli" )
    {
        var_0 thread scripts\common\vehicle_paths::getonpath();
        return;
    }

    var_0 scripts\engine\utility::set_ai_number();
    var_5 = var_0.vehicletype;
    var_0 vehicle_setstartinghealth();
    var_0 vehicle_setteam();

    if ( !isdefined( level.vehicleinitthread[var_0.vehicletype][var_1] ) )
    {

    }

    var_0 thread [[ level.vehicleinitthread[var_0.vehicletype][var_1] ]]();
    var_0 thread vehicle_playexhausteffect();
    var_0 thread vehicle_playengineeffect();

    if ( !isdefined( var_0.script_avoidplayer ) )
        var_0.script_avoidplayer = 0;

    if ( isdefined( level.vehicle.draw_thermal ) )
    {
        if ( level.vehicle.draw_thermal )
            var_0 thermaldrawenable();
    }

    var_0 scripts\engine\utility::ent_flag_init( "unloaded" );
    var_0 scripts\engine\utility::ent_flag_init( "loaded" );
    var_0 scripts\engine\utility::ent_flag_init( "landed" );
    var_0.riders = [];
    var_0.unloadque = [];
    var_0.unload_group = "default";
    var_0.fastroperig = [];

    if ( isdefined( level.vehicle.templates.attachedmodels ) && isdefined( level.vehicle.templates.attachedmodels[var_1] ) )
    {
        var_6 = level.vehicle.templates.attachedmodels[var_1];
        var_7 = getarraykeys( var_6 );

        foreach ( var_9 in var_7 )
        {
            var_0.fastroperig[var_9] = undefined;
            var_0.fastroperiganimating[var_9] = 0;
        }
    }

    if ( isdefined( var_0.script_vehicle_lights_on ) )
        var_0 thread scripts\common\vehicle_lights::lights_on( var_0.script_vehicle_lights_on );

    if ( isdefined( var_0.script_godmode ) )
        var_0.godmode = 1;

    var_0 thread vehicle_damagelogic();
    var_0 thread scripts\common\vehicle_aianim::handle_attached_guys();

    if ( isdefined( var_0.script_friendname ) )
        var_0 setvehiclelookattext( var_0.script_friendname, &"" );

    var_0 thread vehicle_handleunloadevent();

    if ( isdefined( var_0.script_dontunloadonend ) )
        var_0.dontunloadonend = 1;

    var_0 thread vehicle_rumble();
    var_0 thread scripts\engine\utility::script_func( "vehicle_treads" );
    var_0 thread idle_animations();
    var_0 thread animate_drive_idle();

    if ( isdefined( var_0.script_deathflag ) )
        var_0 thread scripts\engine\utility::script_func( "vehicle_deathflag" );

    var_0 thread mainturretinit();
    var_0 thread mginit();

    if ( isdefined( level.vehicle.spawn_callback_thread ) )
        level thread [[ level.vehicle.spawn_callback_thread ]]( var_0 );

    if ( isdefined( var_0.script_team ) )
        var_0 setvehicleteam( var_0.script_team );

    if ( var_0 scripts\common\vehicle::ishelicopter() )
        var_0 thread vehicle_ai_avoidance_heli();
    else
        var_0 thread vehicle_ai_avoidance_logic();

    var_0 thread scripts\common\vehicle_paths::getonpath();

    if ( isdefined( level.ignorewash ) )
        var_11 = level.ignorewash;
    else
        var_11 = 0;

    if ( scripts\common\utility::issp() && var_0 vehicle_hasdustkickup() && !var_11 )
        var_0 thread aircraft_wash_thread();

    if ( var_0 vehicle_isphysveh() )
    {
        var_0.veh_pathtype = "constrained";

        if ( isdefined( var_0.script_pathtype ) )
            var_0.veh_pathtype = var_0.script_pathtype;
    }

    var_0 spawn_riders();
    var_0 thread vehicle_deathlogic();
}

get_vehicle_classname()
{
    if ( isdefined( self.classname_mp ) )
        return self.classname_mp;

    return self.classname;
}

#using_animtree("vehicles");

vehicle_deathcleanup()
{
    self notify( "stop_looping_death_fx" );
    self notify( "death_finished" );

    if ( isdefined( self.navobstacleid ) )
        destroynavobstacle( self.navobstacleid );

    destroynavrepulsor( "veh_" + self getentitynumber() );

    if ( isdefined( self.rumbletrigger ) )
        self.rumbletrigger delete();

    if ( isdefined( self.mgturret ) )
        scripts\engine\utility::array_delete( self.mgturret );

    if ( isdefined( self.mainturret ) )
        self.mainturret delete();

    if ( istrue( level.vehicle.templates.has_main_turret[self.model] ) )
        self clearturrettarget();

    var_0 = get_vehicle_classname();

    if ( isdefined( level.vehicle.templates.rumble[var_0] ) )
        self stoprumble( level.vehicle.templates.rumble[var_0].rumble );

    if ( !scripts\common\utility::issp() )
        return;

    self useanimtree( #animtree );

    if ( isdefined( level.vehicle.templates.driveidle[self.model] ) )
        self clearanim( level.vehicle.templates.driveidle[self.model], 0 );

    if ( isdefined( level.vehicle.templates.driveidle_r[self.model] ) )
        self clearanim( level.vehicle.templates.driveidle_r[self.model], 0 );
}

vehicle_deathlogic()
{
    self endon( "entitydeleted" );
    self endon( "nodeath_thread" );
    thread helicopter_unloading_watcher();
    self waittill( "death", var_0, var_1, var_2, var_3 );
    vehicle_deathcustomlogic( var_0, var_1, var_2 );
    vehicle_playdeatheffects( var_0, var_1, var_3 );
    thread vehicle_killriders();
    vehicle_setdeathmodel();
    vehicle_docrash( var_0, var_1 );

    if ( vehicle_iscorpse() )
        self notify( "vehicle_deathComplete", self.origin, self.angles );
    else
    {
        vehicle_deathcleanup();
        self notify( "vehicle_deathComplete", self.origin, self.angles );

        if ( istrue( self.vehicle_skipdeathmodel ) )
        {
            if ( scripts\common\utility::iscp() )
                wait 0.1;

            self delete();
            return;
        }

        self makecorpse();
        createnavbadplacebyent( self );
    }
}

vehicle_deathcustomlogic( var_0, var_1, var_2 )
{
    if ( isdefined( self.custom_death_script ) )
        self thread [[ self.custom_death_script ]]();

    if ( isdefined( level.vehicle.templates.death_thread[self.vehicletype] ) )
        thread [[ level.vehicle.templates.death_thread[self.vehicletype] ]]();

    var_3 = isdefined( var_0 ) && isdefined( var_1 ) && isdefined( var_2 );

    if ( var_3 )
    {
        var_4 = createheadicon( var_2 );
        var_0 scripts\engine\utility::script_func( "register_kill", self, var_1, var_4 );
    }
}

vehicle_iscrashing()
{
    return istrue( self.vehiclecrashing );
}

vehicle_killriders()
{
    if ( istrue( self.pilot_killed ) && !istrue( self.unloading ) )
        self waittill( "flavor_done" );

    foreach ( var_1 in self.riders )
    {
        if ( !isalive( var_1 ) )
            continue;

        if ( !isdefined( var_1.ridingvehicle ) )
            continue;

        if ( isdefined( var_1.magic_bullet_shield ) )
            var_1 scripts\common\ai::stop_magic_bullet_shield();

        if ( isdefined( var_1._blackboard ) && isdefined( var_1._blackboard.chosenvehicleanimpos ) && istrue( var_1._blackboard.chosenvehicleanimpos.isincircle ) )
        {
            var_2 = 100.0;
            var_3 = self vehicle_getvelocity();
            var_1.do_immediate_ragdoll = 1;
            var_1.ragdollhitloc = "torso_lower";
            var_1.ragdollimpactvector = ( var_1.origin - self.origin ) * var_2 + var_3;
        }

        if ( scripts\common\utility::iscp() && isdefined( self.is_area_in_verdansk ) )
        {
            if ( isdefined( self.is_area_in_verdansk.attacker ) && isplayer( self.is_area_in_verdansk.attacker ) )
                var_1 dodamage( var_1.maxhealth, self.is_area_in_verdansk.attacker.origin, self.is_area_in_verdansk.attacker, self.is_area_in_verdansk.attacker, self.is_area_in_verdansk.meansofdeath, self.is_area_in_verdansk.objweapon );
            else
                var_1 kill();

            continue;
        }

        var_1 kill();
    }
}

vehicle_rider_death_detection( var_0 )
{
    if ( isdefined( self.vehicle_position ) && self.vehicle_position != 0 )
        return;

    self.health = 1;
    var_0 endon( "death" );
    self.baseaccuracy = 0.15;
    self waittill( "death" );
    var_0 notify( "driver_died" );
    var_0 vehicle_killriders();
}

vehicle_becomes_crashable()
{
    self endon( "death" );
    self endon( "enable_spline_path" );
    waittillframeend;
    self.riders = scripts\engine\utility::array_removedead( self.riders );

    if ( self.riders.size )
    {
        scripts\engine\utility::array_thread( self.riders, ::vehicle_rider_death_detection, self );
        scripts\engine\utility::waittill_either( "veh_collision", "driver_died" );
        vehicle_killriders();
        wait 0.25;
    }

    self notify( "script_crash_vehicle" );
    self vehphys_crash();
}

_vehicle_landvehicle( var_0, var_1 )
{
    self endon( "death" );
    self notify( "newpath" );

    if ( !isdefined( var_0 ) )
        var_0 = 2;

    self setneargoalnotifydist( var_0 );
    self sethoverparams( 0, 0, 0 );
    self cleargoalyaw();
    self settargetyaw( scripts\engine\utility::flat_angle( self.angles )[1] );

    if ( isdefined( self.unload_land_offset ) )
        _setvehgoalpos_wrap( scripts\common\utility::groundpos( self.origin ) + ( 0, 0, self.unload_land_offset ), 1 );
    else
        _setvehgoalpos_wrap( scripts\common\utility::groundpos( self.origin ), 1 );

    self waittill( "goal" );
}

vehicle_landanims( var_0, var_1 )
{
    self endon( "death" );
    var_2 = get_vehicle_classname();

    if ( !isdefined( level.vehicle.templates.landanims[var_2] ) )
        return;

    var_3 = level.vehicle.templates.landanims[var_2];

    foreach ( var_5 in var_3 )
        self setanim( var_5.land, 1, 0.2, 1 );

    if ( !var_1 )
        return;

    if ( isdefined( var_0 ) )
        self waittill( "unloaded" );
    else
        self waittill( "continuepath" );

    foreach ( var_5 in var_3 )
    {
        self clearanim( var_5.land, 0 );
        self setanim( var_5.takeoff, 1, 0.2, 1 );
    }
}

vehicle_landvehicle( var_0, var_1 )
{
    return _vehicle_landvehicle( var_0, var_1 );
}

spawn_vehicle_and_attach_to_spline_path( var_0 )
{
    var_1 = scripts\common\utility::spawn_vehicle();

    if ( isdefined( var_0 ) )
        var_1 vehicle_setspeed( var_0 );

    var_1 thread vehicle_becomes_crashable();
    var_1 endon( "death" );
    var_1.dontunloadonend = 1;
    var_1 scripts\common\vehicle_paths::gopath( var_1 );
    var_1 leave_path_for_spline_path();
}

leave_path_for_spline_path()
{
    self endon( "script_crash_vehicle" );
    scripts\engine\utility::waittill_either( "enable_spline_path", "reached_end_node" );
    var_0 = get_my_spline_node( self.origin );

    if ( isdefined( level.drive_spline_path_fun ) )
        var_0 thread [[ level.drive_spline_path_fun ]]( self );
}

get_my_spline_node( var_0 )
{
    var_0 = ( var_0[0], var_0[1], 0 );
    var_1 = scripts\engine\utility::get_array_of_closest( var_0, level.snowmobile_path );
    var_2 = [];

    for ( var_3 = 0; var_3 < 3; var_3++ )
        var_2[var_3] = var_1[var_3];

    foreach ( var_5 in level.snowmobile_path )
    {
        foreach ( var_7 in var_2 )
        {
            if ( var_7 == var_5 )
                return var_7;
        }
    }
}

waittill_stable( var_0 )
{
    var_1 = 12;
    var_2 = 400;
    var_3 = gettime() + var_2;

    while ( isdefined( self ) )
    {
        if ( abs( self.angles[0] ) > var_1 || abs( self.angles[2] ) > var_1 )
            var_3 = gettime() + var_2;

        if ( gettime() > var_3 )
            break;

        wait 0.05;
    }
}

_vehicle_unload( var_0 )
{
    self endon( "death" );

    if ( isdefined( var_0 ) )
        self.unload_group = var_0;

    if ( scripts\engine\utility::ent_flag_exist( "no_riders_until_unload" ) )
    {
        scripts\engine\utility::ent_flag_set( "no_riders_until_unload" );
        var_1 = spawn_unload_group( self.unload_group );

        foreach ( var_3 in var_1 )
            scripts\common\ai::spawn_failed( var_3 );

        waittillframeend;
    }

    self notify( "unloading" );
    var_1 = [];
    var_5 = level.vehicle.templates.unloadgroups[get_vehicle_classname()];

    if ( isdefined( var_5 ) )
    {
        var_6 = scripts\common\vehicle_aianim::get_unload_group();

        if ( istrue( self.vehiclesetuprope ) )
        {
            for ( var_7 = 0; var_7 < level.vehicle.templates.aianims[get_vehicle_classname()].size; var_7++ )
            {
                var_8 = level.vehicle.templates.aianims[get_vehicle_classname()][var_7];

                if ( istrue( var_8.setuprope ) )
                {
                    var_9 = 0;

                    foreach ( var_11 in self.riders )
                    {
                        if ( isdefined( var_6[var_11.vehicle_position] ) && var_11.vehicle_position != var_7 )
                        {
                            var_12 = scripts\common\vehicle_aianim::anim_pos( self, var_11.vehicle_position );

                            if ( var_12.fastroperig == var_8.fastroperig )
                            {
                                var_9 = 1;
                                break;
                            }
                        }
                    }

                    if ( var_9 )
                    {
                        foreach ( var_11 in self.riders )
                        {
                            if ( var_11.vehicle_position == var_7 )
                            {
                                scripts\common\vehicle_aianim::guy_setup_rope( var_11, var_8 );
                                break;
                            }
                        }
                    }
                }
            }
        }

        foreach ( var_11 in self.riders )
        {
            if ( isalive( var_11 ) && isdefined( var_6[var_11.vehicle_position] ) )
            {
                if ( isdefined( level.vehicle.aianimcheck["unload"] ) && ![[ level.vehicle.aianimcheck["unload"] ]]( var_11, var_11.vehicle_position ) )
                    continue;

                var_8 = scripts\common\vehicle_aianim::anim_pos( self, var_11.vehicle_position );

                if ( isdefined( var_8 ) && istrue( var_8.lootspawnitem ) )
                    continue;

                if ( isdefined( level.vehicle.aianimthread["unload"] ) )
                {
                    if ( !istrue( var_8.setuprope ) )
                    {
                        var_11 notify( "newanim" );
                        thread [[ level.vehicle.aianimthread["unload"] ]]( var_11, var_11.vehicle_position );
                        var_11 notify( "unload" );

                        if ( isdefined( var_8.mgturret ) )
                            var_11 scripts\common\ai::stop_use_turret();

                        var_1 = scripts\engine\utility::array_add( var_1, var_11 );
                    }
                }
            }
        }
    }

    return var_1;
}

_setvehgoalpos_wrap( var_0, var_1 )
{
    if ( self.health <= 0 )
        return;

    if ( isdefined( self.originheightoffset ) )
        var_0 = var_0 + ( 0, 0, self.originheightoffset );

    self setvehgoalpos( var_0, var_1 );
}

vehicle_kill_badplace_forever()
{
    self notify( "kill_badplace_forever" );
}

vehicle_isdestructible()
{
    return isdefined( self.destructible_type );
}

_kill_fx_play_direction( var_0, var_1 )
{
    if ( isdefined( var_0 ) && isdefined( var_1 ) )
    {
        var_2 = self getentityvelocity();
        var_2 = vectornormalize( var_2 );
        var_0 = vectornormalize( var_0 );
        var_3 = vectorlerp( var_2, var_0, var_1 );
        return var_3;
    }
    else
        return undefined;
}

vehicle_playdeatheffects( var_0, var_1, var_2 )
{
    if ( vehicle_isdestructible() )
        return;

    level notify( "vehicle_explosion", self.origin );
    self notify( "explode", self.origin );
    thread vehicle_deathearthquake();
    thread vehicle_deathradiusdamage();
    thread vehicle_deathkilllights();
    thread vehicle_deathjolt( var_2 );
    thread vehicle_deathvfx( var_0, var_1 );
}

vehicle_deathvfx( var_0, var_1 )
{
    var_2 = get_vehicle_classname();

    if ( vehicle_shoulddorocketdeath( var_0, var_1, var_2 ) )
    {
        self.vehicle_skipdeathmodel = 1;
        self.preferred_crash_style = 3;
        var_3 = level.vehicle.templates.vehicle_rocket_death_fx[var_2];
    }
    else if ( istrue( self.pilot_killed ) )
    {
        self.vehicle_skipdeathmodel = 1;
        self.preferred_crash_style = 4;
        var_3 = level.vehicle.templates.vehicle_rocket_death_fx[var_2];
    }
    else
        var_3 = level.vehicle.templates.vehicle_death_fx[var_2];

    foreach ( var_5 in var_3 )
        thread kill_fx_thread( self.model, var_5, self.vehicletype, var_0 );
}

vehicle_deathearthquake()
{
    var_0 = level.vehicle.templates.death_earthquake[get_vehicle_classname()];

    if ( isdefined( var_0 ) )
        earthquake( var_0.scale, var_0.duration, self.origin, var_0.radius );
}

vehicle_deathradiusdamage()
{
    if ( scripts\common\vehicle::ishelicopter() )
        return;

    var_0 = get_vehicle_classname();

    if ( !isdefined( level.vehicle.templates.death_radiusdamage ) || !isdefined( level.vehicle.templates.death_radiusdamage[var_0] ) )
        return;

    var_1 = level.vehicle.templates.death_radiusdamage[var_0].maxdamage;
    var_2 = level.vehicle.templates.death_radiusdamage[var_0].mindamage;
    self radiusdamage( self.origin + level.vehicle.templates.death_radiusdamage[var_0].offset, level.vehicle.templates.death_radiusdamage[var_0].range, var_1, var_2, self );
}

vehicle_deathkilllights()
{
    scripts\common\vehicle_lights::lights_off_internal( "all", self.model, get_vehicle_classname() );
}

vehicle_deathjolt( var_0 )
{
    if ( scripts\common\vehicle::ishelicopter() )
        return;

    if ( !scripts\common\utility::issp() && self issuspendedvehicle() )
        return;

    self joltbody( var_0, 3.0 );
}

vehicle_shoulddorocketdeath( var_0, var_1, var_2 )
{
    if ( !vehicle_hasrocketdeath( var_2 ) )
        return 0;

    if ( istrue( self.vehicle_forcerocketdeath ) )
        return 1;

    if ( scripts\engine\utility::is_equal( var_1, "MOD_PROJECTILE" ) )
        return 1;

    if ( scripts\engine\utility::is_equal( var_1, "MOD_PROJECTILE_SPLASH" ) )
        return 1;

    if ( scripts\engine\utility::is_equal( var_1, "MOD_GRENADE" ) )
        return 1;

    return 0;
}

vehicle_hasrocketdeath( var_0 )
{
    return isdefined( level.vehicle.templates.vehicle_rocket_death_fx[var_0] );
}

kill_fx_thread( var_0, var_1, var_2, var_3 )
{
    if ( isdefined( self.pilot_killed ) )
        self waittill( "flavor_done" );

    if ( isdefined( self.nodeath ) )
        return;

    if ( !isdefined( var_3 ) )
        return;

    if ( isdefined( var_1.waitdelay ) )
    {
        if ( var_1.waitdelay >= 0 )
            wait( var_1.waitdelay );
        else
            self waittill( "death_finished" );
    }

    if ( !isdefined( self ) )
        return;

    if ( isdefined( var_1.notifystring ) )
        self notify( var_1.notifystring );

    var_4 = vectornormalize( self.origin - var_3.origin );

    if ( isdefined( var_1.selfdeletedelay ) )
        scripts\engine\utility::delaycall( var_1.selfdeletedelay, ::delete );

    if ( isdefined( var_1.effect ) )
    {
        if ( var_1.beffectlooping )
        {
            if ( isdefined( var_1.tag ) )
            {
                if ( isdefined( var_1.stayontag ) && var_1.stayontag == 1 )
                    thread loop_fx_on_vehicle_tag( var_1.effect, var_1.delay, var_1.tag );
                else
                    thread playloopedfxontag( var_1.effect, var_1.delay, var_1.tag );
            }
            else
            {
                var_5 = self.origin + ( 0, 0, 100 ) - self.origin;
                playfx( var_1.effect, self.origin, var_5 );
            }
        }
        else if ( isdefined( var_1.tag ) )
        {
            var_5 = _kill_fx_play_direction( var_4, var_1.attacker_velocity_lerp );

            if ( isdefined( var_5 ) )
            {
                var_6 = deathfx_ent();
                playfx( var_1.effect, var_6 gettagorigin( var_1.tag ), var_5 );

                if ( isdefined( var_1.remove_deathfx_entity_delay ) )
                    var_6 scripts\engine\utility::delaycall( var_1.remove_deathfx_entity_delay, ::delete );
            }
            else
            {
                var_6 = deathfx_ent();
                playfxontag( var_1.effect, var_6, var_1.tag );
                thread stop_fx_on_vehicle_watcher( var_1.effect, var_6, var_1.tag );

                if ( isdefined( var_1.remove_deathfx_entity_delay ) )
                    deathfx_ent() scripts\engine\utility::delaycall( var_1.remove_deathfx_entity_delay, ::delete );
            }
        }
        else
        {
            var_5 = _kill_fx_play_direction( var_4, var_1.attacker_velocity_lerp );

            if ( isdefined( var_5 ) )
                playfx( var_1.effect, self.origin, var_5 );
            else
            {
                var_5 = self.origin + ( 0, 0, 100 ) - self.origin;
                playfx( var_1.effect, self.origin, var_5 );
            }
        }
    }

    if ( isdefined( var_1.sound ) )
    {
        if ( var_1.bsoundlooping )
            thread death_firesound( var_1.sound );
        else
            scripts\engine\utility::play_sound_in_space( var_1.sound );
    }
}

stop_fx_on_vehicle_watcher( var_0, var_1, var_2 )
{
    var_1 waittill( "stop_all_death_fx" );
    stopfxontag( var_0, var_1, var_2 );
}

loop_fx_on_vehicle_tag( var_0, var_1, var_2 )
{
    self endon( "stop_looping_death_fx" );

    while ( isdefined( self ) )
    {
        playfxontag( var_0, deathfx_ent(), var_2 );
        wait( var_1 );
    }
}

death_firesound( var_0 )
{
    thread scripts\engine\utility::script_func( "playloopsound_on_tag", var_0, undefined, 0, 1 );
    scripts\engine\utility::_id_143A5( "fire_extinguish", "stop_crash_loop_sound" );

    if ( !isdefined( self ) )
        return;

    self notify( "stop sound" + var_0 );
}

deathfx_ent()
{
    if ( isdefined( self.death_fx_on_self ) && self.death_fx_on_self )
        return self;

    if ( !isdefined( self.deathfx_ent ) )
    {
        var_0 = spawn( "script_model", ( 0, 0, 0 ) );
        var_0 setmodel( self.model );
        var_0.origin = self.origin;
        var_0.angles = self.angles;
        var_0 notsolid();
        var_0 hide();
        var_0 linkto( self );
        var_0.death_fx = 1;
        self.deathfx_ent = var_0;
    }
    else
        self.deathfx_ent setmodel( self.model );

    return self.deathfx_ent;
}

playloopedfxontag( var_0, var_1, var_2 )
{
    var_3 = spawn( "script_origin", self.origin );
    self endon( "fire_extinguish" );
    thread playloopedfxontag_originupdate( var_2, var_3 );

    for (;;)
    {
        playfx( var_0, var_3.origin, var_3.upvec );
        wait( var_1 );
    }
}

playloopedfxontag_originupdate( var_0, var_1 )
{
    var_1.angles = self gettagangles( var_0 );
    var_1.origin = self gettagorigin( var_0 );
    var_1.forwardvec = anglestoforward( var_1.angles );
    var_1.upvec = anglestoup( var_1.angles );

    while ( isdefined( self ) && self.code_classname == "script_vehicle" && self vehicle_getspeed() > 0 )
    {
        var_1.angles = self gettagangles( var_0 );
        var_1.origin = self gettagorigin( var_0 );
        var_1.forwardvec = anglestoforward( var_1.angles );
        var_1.upvec = anglestoup( var_1.angles );
        wait 0.05;
    }
}

_getvehiclespawnerarray( var_0, var_1 )
{
    var_2 = [];

    if ( isdefined( var_0 ) && isdefined( var_1 ) )
    {
        var_3 = 1;
        var_4 = getentarray( var_0, var_1 );
    }
    else
    {
        var_3 = 0;
        var_4 = getentarray( "script_vehicle", "code_classname" );
    }

    foreach ( var_6 in var_4 )
    {
        if ( var_3 && var_6.code_classname != "script_vehicle" )
            continue;

        if ( isspawner( var_6 ) )
            var_2[var_2.size] = var_6;
    }

    return var_2;
}

update_steering( var_0 )
{
    if ( var_0.update_time == gettime() )
        return var_0.steering;

    var_0.update_time = gettime();

    if ( var_0.steering_enable )
    {
        var_1 = clamp( 0 - var_0.angles[2], 0 - var_0.steering_maxroll, var_0.steering_maxroll ) / var_0.steering_maxroll;

        if ( isdefined( var_0.leanasitturns ) && var_0.leanasitturns )
        {
            var_2 = var_0 vehicle_getsteering();
            var_2 = var_2 * -1.0;
            var_1 = var_1 + var_2;

            if ( var_1 != 0 )
            {
                var_3 = 1.0 / abs( var_1 );

                if ( var_3 < 1 )
                    var_1 = var_1 * var_3;
            }
        }

        var_4 = var_1 - var_0.steering;

        if ( var_4 != 0 )
        {
            var_5 = var_0.steering_maxdelta / abs( var_4 );

            if ( var_5 < 1 )
                var_4 = var_4 * var_5;

            var_0.steering = var_0.steering + var_4;
        }
    }
    else
        var_0.steering = 0;

    return var_0.steering;
}

get_from_spawnstruct( var_0 )
{
    return scripts\engine\utility::getstruct( var_0, "targetname" );
}

get_from_entity( var_0 )
{
    var_1 = getentarray( var_0, "targetname" );

    if ( isdefined( var_1 ) && var_1.size > 0 )
        return var_1[randomint( var_1.size )];

    return undefined;
}

get_from_vehicle_node( var_0 )
{
    return getvehiclenode( var_0, "targetname" );
}

set_lookat_from_dest( var_0 )
{
    var_1 = getent( var_0.script_linkto, "script_linkname" );

    if ( !isdefined( var_1 ) )
        return;

    self setlookatent( var_1 );
    self.set_lookat_point = 1;
}

damage_hint_bullet_only()
{
    level.armordamagehints = 0;
    self.displayingdamagehints = 0;
    thread damage_hints_cleanup();

    while ( isdefined( self ) )
    {
        self waittill( "damage", var_0, var_1, var_2, var_3, var_4 );

        if ( !isplayer( var_1 ) )
            continue;

        if ( isdefined( self.has_semtex_on_it ) )
            continue;

        var_4 = tolower( var_4 );

        switch ( var_4 )
        {
            case "bullet":
            case "mod_rifle_bullet":
            case "mod_pistol_bullet":
                if ( !level.armordamagehints )
                {
                    if ( isdefined( level.thrown_semtex_grenades ) && level.thrown_semtex_grenades > 0 )
                        break;

                    level.armordamagehints = 1;
                    self.displayingdamagehints = 1;
                    var_1 scripts\engine\utility::script_func( "display_hint", "invulerable_bullets" );
                    wait 4;
                    level.armordamagehints = 0;

                    if ( isdefined( self ) )
                        self.displayingdamagehints = 0;

                    break;
                }
        }
    }
}

damage_hints()
{
    level.armordamagehints = 0;
    self.displayingdamagehints = 0;
    thread damage_hints_cleanup();

    while ( isdefined( self ) )
    {
        self waittill( "damage", var_0, var_1, var_2, var_3, var_4 );

        if ( !isplayer( var_1 ) )
            continue;

        if ( isdefined( self.has_semtex_on_it ) )
            continue;

        var_4 = tolower( var_4 );

        switch ( var_4 )
        {
            case "mod_grenade_splash":
            case "mod_grenade":
            case "bullet":
            case "mod_rifle_bullet":
            case "mod_pistol_bullet":
                if ( !level.armordamagehints )
                {
                    if ( isdefined( level.thrown_semtex_grenades ) && level.thrown_semtex_grenades > 0 )
                        break;

                    level.armordamagehints = 1;
                    self.displayingdamagehints = 1;

                    if ( var_4 == "mod_grenade" || var_4 == "mod_grenade_splash" )
                        var_1 scripts\engine\utility::script_func( "display_hint", "invulerable_frags", 5 );
                    else
                        var_1 scripts\engine\utility::script_func( "display_hint", "invulerable_bullets", 5 );

                    wait 4;
                    level.armordamagehints = 0;

                    if ( isdefined( self ) )
                        self.displayingdamagehints = 0;

                    break;
                }
        }
    }
}

damage_hints_cleanup()
{
    self waittill( "death" );

    if ( self.displayingdamagehints )
        level.armordamagehints = 0;
}

aircraft_wash_thread( var_0 )
{
    self endon( "death" );
    self endon( "death_finished" );
    self notify( "stop_kicking_up_dust" );
    self endon( "stop_kicking_up_dust" );
    var_1 = 2000;

    if ( isdefined( level.treadfx_maxheight ) )
        var_1 = level.treadfx_maxheight;

    var_2 = 80 / var_1;
    var_3 = 0.5;

    if ( isairplane_internal() )
        var_3 = 0.15;

    var_4 = self;

    if ( isdefined( var_0 ) )
        var_4 = var_0;

    var_5 = 3;

    for (;;)
    {
        wait( var_3 );

        if ( 1 )
        {
            if ( isdefined( self.disable_wash ) && self.disable_wash )
                continue;

            if ( isdefined( self.treadfx_maxheight ) )
                var_1 = self.treadfx_maxheight;

            var_6 = anglestoup( var_4.angles ) * -1;
            var_7 = undefined;
            var_5++;

            if ( var_5 > 3 )
            {
                var_5 = 3;
                var_7 = scripts\engine\trace::ray_trace( var_4.origin, var_4.origin + var_6 * var_1, var_4, undefined, 1 );
            }

            if ( var_7["fraction"] == 1 || var_7["fraction"] < var_2 )
                continue;

            var_8 = distance( var_4.origin, var_7["position"] );
            var_9 = get_wash_fx( self, var_7, var_6, var_8 );

            if ( !isdefined( var_9 ) )
                continue;

            var_3 = ( var_8 - 350 ) / ( var_1 - 350 ) * 0.1 + 0.05;
            var_3 = max( var_3, 0.05 );

            if ( !isdefined( var_7 ) )
                continue;

            if ( !isdefined( var_7["position"] ) )
                continue;

            var_10 = var_7["position"];
            var_11 = var_7["normal"];
            var_8 = vectordot( var_10 - var_4.origin, var_11 );
            var_12 = var_4.origin + ( 0, 0, var_8 );
            var_13 = var_10 - var_12;

            if ( isdefined( self.treadfx_orient_to_player ) )
                var_13 = var_10 - level.player.origin;

            if ( vectordot( var_7["normal"], ( 0, 0, 1 ) ) == -1 )
                continue;

            if ( length( var_13 ) < 1 )
                var_13 = var_4.angles + ( 0, 180, 0 );

            playfx( var_9, var_10, var_11, var_13 );
        }
    }
}

get_wash_fx( var_0, var_1, var_2, var_3 )
{
    var_4 = var_1["surfacetype"];
    var_5 = undefined;
    var_6 = vectordot( ( 0, 0, -1 ), var_2 );

    if ( var_6 >= 0.97 )
        var_5 = undefined;
    else if ( var_6 >= 0.92 )
        var_5 = "_bank";
    else
        var_5 = "_bank_lg";

    return get_wash_effect( var_0 get_vehicle_classname(), var_4, var_5 );
}

get_wash_effect( var_0, var_1, var_2 )
{
    if ( isdefined( var_2 ) )
    {
        var_3 = var_1 + var_2;

        if ( !isdefined( level.vehicle.templates.surface_effects[var_0][var_3] ) && var_1 != "default" )
            return get_wash_effect( var_0, "default", var_2 );
        else
            return level.vehicle.templates.surface_effects[var_0][var_3];
    }

    return get_vehicle_effect( var_0, var_1 );
}

get_vehicle_effect( var_0, var_1 )
{
    if ( !isdefined( level.vehicle.templates.surface_effects[var_0][var_1] ) && var_1 != "default" )
        return get_vehicle_effect( var_0, "default" );
    else
        return level.vehicle.templates.surface_effects[var_0][var_1];

    return undefined;
}

no_treads()
{
    return ishelicopter_internal() || isairplane_internal();
}

vehicle_hasdustkickup()
{
    if ( !ishelicopter_internal() && !isairplane_internal() )
        return 0;

    return 1;
}

hashelicopterturret()
{
    if ( !isdefined( self.vehicletype ) )
        return 0;

    if ( self.vehicletype == "cobra" )
        return 1;

    if ( self.vehicletype == "cobra_player" )
        return 1;

    if ( self.vehicletype == "viper" )
        return 1;

    return 0;
}

_id_14101()
{
    self endon( "stop_ai_avoidance" );
    self waittill( "death" );
    vehicle_remove_navobstacle();
    vehicle_remove_navrepulsor();
}

vehicle_ai_avoidance_logic()
{
    self endon( "death" );
    self endon( "stop_ai_avoidance" );
    thread _id_14101();
    var_0 = self vehicle_isphysveh();
    var_1 = 25.0;

    for (;;)
    {
        vehicle_navobstacle();
        var_2 = self.origin;

        while ( vehicle_is_stopped() && ( !var_0 || self vehicle_isonground() ) )
        {
            wait 0.1;

            if ( lengthsquared( self.origin - var_2 ) > var_1 )
            {
                vehicle_remove_navobstacle();
                vehicle_navobstacle();
                var_2 = self.origin;
            }
        }

        vehicle_remove_navobstacle();
        vehicle_navrepulsor();

        while ( !vehicle_is_stopped() || var_0 && !self vehicle_isonground() )
            wait 0.1;

        vehicle_remove_navrepulsor();
    }
}

vehicle_is_stopped()
{
    if ( !scripts\common\utility::issp() && self issuspendedvehicle() )
        return 1;

    if ( self vehicle_isphysveh() )
        return self vehicle_getspeed() < 0.01;

    return self vehicle_getspeed() == 0;
}

vehicle_ai_avoidance_heli()
{
    self endon( "death" );
    self endon( "stop_ai_avoidance" );
    thread _id_14101();

    for (;;)
    {
        vehicle_navobstacle();

        while ( self vehicle_getspeed() == 0 && ( !isdefined( self.script_disconnectpaths ) || istrue( self.script_disconnectpaths ) ) )
            wait 0.1;

        vehicle_remove_navobstacle();

        while ( self vehicle_getspeed() != 0 || isdefined( self.script_disconnectpaths ) && !istrue( self.script_disconnectpaths ) )
            wait 0.1;
    }
}

vehicle_navrepulsor()
{
    if ( isdefined( self.script_badplace ) && !istrue( self.script_badplace ) )
        return;

    createnavrepulsor( self.unique_id + "vehicle_badplace", -1, self, "allies", "axis" );
}

vehicle_remove_navrepulsor()
{
    destroynavrepulsor( self.unique_id + "vehicle_badplace" );
}

vehicle_navobstacle()
{
    if ( isdefined( self.script_disconnectpaths ) && !istrue( self.script_disconnectpaths ) )
        return;

    self.navobstacleid = createnavbadplacebyent( self );
}

vehicle_remove_navobstacle()
{
    if ( isdefined( self.navobstacleid ) )
    {
        destroynavobstacle( self.navobstacleid );
        self.navobstacleid = undefined;
    }
}

vehicle_disable_navrepulsors()
{
    self.script_badplace = 0;
    vehicle_remove_navrepulsor();
}

vehicle_enable_navrepulsors()
{
    self.script_badplace = undefined;

    if ( !vehicle_is_stopped() )
        vehicle_navrepulsor();
}

vehicle_disable_navobstacles()
{
    self.script_disconnectpaths = 0;
    vehicle_remove_navobstacle();
}

vehicle_enable_navobstacles()
{
    self.script_disconnectpaths = undefined;

    if ( vehicle_is_stopped() )
        vehicle_navobstacle();
}

vehicle_badplace()
{
    vehicle_navrepulsor();
}

vehicle_remove_badplace()
{
    vehicle_remove_navrepulsor();
}

disconnect_paths_whenstopped()
{
    self endon( "death" );
    self.pathsdisconnected = 0;
    var_0 = 0;

    if ( isdefined( self.script_disconnectpaths ) && !self.script_disconnectpaths )
        var_0 = 1;

    if ( var_0 )
    {
        self.dontdisconnectpaths = 1;
        return;
    }

    wait( randomfloat( 1 ) );

    while ( isdefined( self ) )
    {
        if ( self vehicle_getspeed() < 1 )
        {
            if ( !isdefined( self.dontdisconnectpaths ) )
            {
                self disconnectpaths();
                self.pathsdisconnected = 1;
            }
            else
            {

            }

            self notify( "speed_zero_path_disconnect" );

            while ( self vehicle_getspeed() < 1 )
            {
                if ( isdefined( self.dontdisconnectpaths ) && self.dontdisconnectpaths )
                    break;

                wait 0.05;
            }
        }

        self connectpaths();
        self.pathsdisconnected = 0;
        wait 1;
    }
}

vehicle_start_ai_avoidance()
{
    if ( getdvarint( "scr_br_vehicle_ai_avoidance_enabled", 1 ) == 0 )
        return;

    foreach ( var_5, var_1 in level.vehicle.instances )
    {
        foreach ( var_3 in var_1 )
        {
            if ( istrue( var_3.isheli ) )
            {
                var_3 thread vehicle_ai_avoidance_heli();
                continue;
            }

            var_3 thread vehicle_ai_avoidance_logic();
        }
    }
}

vehicle_stop_ai_avoidance()
{
    if ( getdvarint( "scr_br_vehicle_ai_avoidance_enabled", 1 ) == 0 )
        return;

    foreach ( var_5, var_1 in level.vehicle.instances )
    {
        foreach ( var_3 in var_1 )
        {
            var_3 notify( "stop_ai_avoidance" );
            var_3 vehicle_remove_navobstacle();
            var_3 vehicle_remove_navrepulsor();
        }
    }
}

mainturretinit()
{
    var_0 = get_vehicle_classname();

    if ( !isdefined( level.vehicle.templates.mainturret[var_0] ) )
        return;

    var_1 = level.vehicle.templates.mainturret[var_0];

    if ( !isdefined( var_1 ) )
        return;

    var_2 = "";

    if ( isdefined( self.script_turrets ) )
        var_2 = self.script_turrets;

    self.mainturret = turretinitshared( var_1 );

    if ( !isdefined( self.script_turretmain ) )
        self.script_turretmain = 1;

    if ( self.script_turretmain == 0 )
        thread _mainturretoff();
    else
    {
        self.script_turretmain = 1;
        thread _mainturreton();
    }
}

mginit()
{
    var_0 = get_vehicle_classname();

    if ( isdefined( self.script_nomg ) && self.script_nomg > 0 )
        return;

    if ( !isdefined( level.vehicle.templates.mgturret[var_0] ) )
        return;

    var_1 = level.vehicle.templates.mgturret[var_0];

    if ( !isdefined( var_1 ) )
        return;

    var_2 = "";

    if ( isdefined( self.script_turrets ) )
        var_2 = self.script_turrets;

    foreach ( var_5, var_4 in var_1 )
    {
        if ( isdefined( var_4.referencename ) && !issubstr( var_2, var_4.referencename ) )
            continue;

        self.mgturret[var_5] = turretinitshared( var_4 );
    }

    if ( !isdefined( self.script_turretmg ) )
        self.script_turretmg = 1;

    if ( self.script_turretmg == 0 )
        thread _mgoff();
    else
    {
        self.script_turretmg = 1;
        thread _mgon();
    }
}

turretinitshared( var_0 )
{
    var_1 = 0;

    if ( isdefined( self.script_mg_angle ) )
        var_1 = self.script_mg_angle;

    var_2 = spawnturret( "misc_turret", ( 0, 0, 0 ), var_0.info );
    var_3 = ( 0, 0, 0 );

    if ( isdefined( var_0.offset_tag ) )
        var_3 = ( 0, 0, 0 );

    var_4 = self;

    if ( isdefined( var_0.mainturretchild ) )
    {
        if ( !isdefined( self.mainturret ) )
        {

        }

        var_4 = self.mainturret;
    }

    var_2 linkto( var_4, var_0.tag, var_3, ( 0, -1 * var_1, 0 ) );
    var_2 setmodel( var_0.model );
    var_2.angles = self.angles;
    var_2.isvehicleattached = 1;
    var_2.ownervehicle = self;
    var_2.weaponinfo = var_0.info;
    var_2.script_team = self.script_team;
    var_2 makeusable();
    set_turret_team( var_2 );
    level thread vehicle_turret_difficulty( var_2, scripts\common\utility::getdifficulty() );

    if ( isdefined( self.script_fireondrones ) )
        var_2.script_fireondrones = self.script_fireondrones;

    if ( isdefined( var_0.deletedelay ) )
        var_2.deletedelay = var_0.deletedelay;

    if ( isdefined( var_0.defaultdroppitch ) )
        var_2 setdefaultdroppitch( var_0.defaultdroppitch );

    if ( isdefined( var_0.referencename ) )
        var_2.referencename = var_0.referencename;

    if ( isdefined( var_0.defaultonmode ) )
        var_2 turret_set_default_on_mode( var_0.defaultonmode );

    return var_2;
}

vehicle_turret_difficulty( var_0, var_1 )
{
    var_0.convergencetime = level.mgturretsettings[var_1]["convergenceTime"];
    var_0.suppressiontime = level.mgturretsettings[var_1]["suppressionTime"];
    var_0.accuracy = level.mgturretsettings[var_1]["accuracy"];
    var_0.aispread = level.mgturretsettings[var_1]["aiSpread"];
    var_0.playerspread = level.mgturretsettings[var_1]["playerSpread"];
}

turret_set_default_on_mode( var_0 )
{
    self.defaultonmode = var_0;
}

set_turret_team( var_0 )
{
    switch ( self.script_team )
    {
        case "friendly":
        case "allies":
            var_0 setturretteam( "allies" );
            break;
        case "enemy":
        case "axis":
            var_0 setturretteam( "axis" );
            break;
        case "team3":
            var_0 setturretteam( "team3" );
            break;
        default:
            break;
    }
}

animate_drive_idle()
{
    if ( !scripts\common\utility::issp() )
        return;

    self endon( "suspend_drive_anims" );

    if ( !isdefined( self.vehiclewheeldirection ) )
        self.vehiclewheeldirection = 1;

    var_0 = self.model;
    var_1 = -1;
    var_2 = undefined;

    if ( !isdefined( level.vehicle.templates.driveidle[var_0] ) )
        return;

    self useanimtree( #animtree );

    if ( !isdefined( level.vehicle.templates.driveidle_r[var_0] ) )
        level.vehicle.templates.driveidle_r[var_0] = level.vehicle.templates.driveidle[var_0];

    self endon( "death" );
    var_3 = level.vehicle.templates.driveidle_normal_speed[var_0];
    var_4 = 1.0;

    if ( isdefined( level.vehicle.templates.driveidle_animrate ) && isdefined( level.vehicle.templates.driveidle_animrate[var_0] ) )
        var_4 = level.vehicle.templates.driveidle_animrate[var_0];

    var_5 = self.vehiclewheeldirection;
    var_6 = level.vehicle.templates.driveidle[var_0];

    for (;;)
    {
        if ( !var_3 )
        {
            if ( isdefined( self.suspend_driveanims ) )
            {
                wait 0.05;
                continue;
            }

            self setanim( level.vehicle.templates.driveidle[var_0], 1, 0.2, var_4 );
            return;
        }

        var_7 = self vehicle_getspeed();

        if ( var_5 != self.vehiclewheeldirection )
        {
            var_8 = 0;

            if ( self.vehiclewheeldirection )
            {
                var_6 = level.vehicle.templates.driveidle[var_0];
                var_8 = 1 - get_normal_anim_time( level.vehicle.templates.driveidle_r[var_0] );
                self clearanim( level.vehicle.templates.driveidle_r[var_0], 0 );
            }
            else
            {
                var_6 = level.vehicle.templates.driveidle_r[var_0];
                var_8 = 1 - get_normal_anim_time( level.vehicle.templates.driveidle[var_0] );
                self clearanim( level.vehicle.templates.driveidle[var_0], 0 );
            }

            var_2 = 0.01;

            if ( var_2 >= 1 || var_2 == 0 )
                var_2 = 0.01;

            var_5 = self.vehiclewheeldirection;
        }

        var_9 = var_7 / var_3;

        if ( var_9 != var_1 )
        {
            self setanim( var_6, 1, 0.05, var_9 );
            var_1 = var_9;
        }

        if ( isdefined( var_2 ) )
        {
            self setanimtime( var_6, var_2 );
            var_2 = undefined;
        }

        wait 0.05;
    }
}

setup_vehicles( var_0 )
{
    var_1 = [];

    foreach ( var_3 in var_0 )
    {
        if ( isspawner( var_3 ) )
            continue;
        else
            var_1[var_1.size] = var_3;
    }

    foreach ( var_6 in var_1 )
        thread vehicle_init( var_6 );
}

vehicle_setstartinghealth()
{
    var_0 = get_vehicle_classname();

    if ( isdefined( self.script_startinghealth ) )
        self.health = self.script_startinghealth;
    else
    {
        if ( level.vehicle.templates.life[var_0] == -1 )
            return;

        if ( isdefined( level.vehicle.templates.life_range_low[var_0] ) && isdefined( level.vehicle.templates.life_range_high[var_0] ) )
            self.health = randomint( level.vehicle.templates.life_range_high[var_0] - level.vehicle.templates.life_range_low[var_0] ) + level.vehicle.templates.life_range_low[var_0];
        else
            self.health = level.vehicle.templates.life[var_0];
    }
}

get_normal_anim_time( var_0 )
{
    var_1 = self getanimtime( var_0 );
    var_2 = getanimlength( var_0 );

    if ( var_1 == 0 )
        return 0;

    return self getanimtime( var_0 ) / getanimlength( var_0 );
}

suspend_drive_anims()
{
    self notify( "suspend_drive_anims" );
    self clearanim( level.vehicle.templates.driveidle[self.model], 0 );
    self clearanim( level.vehicle.templates.driveidle_r[self.model], 0 );
}

idle_animations()
{
    if ( !isdefined( level.vehicle.templates.idle_anim[self.model] ) )
        return;

    self useanimtree( #animtree );

    foreach ( var_1 in level.vehicle.templates.idle_anim[self.model] )
        self setanim( var_1 );
}

vehicle_rumble()
{
    self endon( "kill_rumble_forever" );
    var_0 = get_vehicle_classname();
    var_1 = level.vehicle.templates.rumble[var_0];

    if ( !isdefined( var_1 ) )
        return;

    var_2 = var_1.radius * 2;
    var_3 = -1 * var_1.radius;
    var_4 = spawn( "trigger_radius", self.origin + ( 0, 0, var_3 ), 0, var_1.radius, var_2 );
    var_4 enablelinkto();
    var_4 linkto( self );
    self.rumbletrigger = var_4;
    self endon( "death" );

    if ( !isdefined( self.rumbleon ) )
        self.rumbleon = 1;

    if ( isdefined( var_1.scale ) )
        self.rumble_scale = var_1.scale;
    else
        self.rumble_scale = 0.15;

    if ( isdefined( var_1.duration ) )
        self.rumble_duration = var_1.duration;
    else
        self.rumble_duration = 4.5;

    if ( isdefined( var_1.radius ) )
        self.rumble_radius = var_1.radius;
    else
        self.rumble_radius = 600;

    if ( isdefined( var_1.basetime ) )
        self.rumble_basetime = var_1.basetime;
    else
        self.rumble_basetime = 1;

    if ( isdefined( var_1.randomaditionaltime ) )
        self.rumble_randomaditionaltime = var_1.randomaditionaltime;
    else
        self.rumble_randomaditionaltime = 1;

    var_4.radius = self.rumble_radius;

    for (;;)
    {
        var_4 waittill( "trigger" );

        if ( vehicle_is_stopped() && !isdefined( self.forcerumble ) || !self.rumbleon )
        {
            wait 0.1;
            continue;
        }

        self playrumblelooponentity( var_1.rumble );

        if ( isdefined( self.vehicletype ) )
        {
            var_5 = self.vehicletype + "_rumble_sfx";

            if ( soundexists( var_5 ) )
                level.player playsound( var_5 );
        }

        while ( level.player istouching( var_4 ) && self.rumbleon && ( !vehicle_is_stopped() || isdefined( self.forcerumble ) ) )
        {
            earthquake( self.rumble_scale, self.rumble_duration, self.origin, self.rumble_radius );
            wait( self.rumble_basetime + randomfloat( self.rumble_randomaditionaltime ) );
        }

        self stoprumble( var_1.rumble );
    }
}

vehicle_setteam()
{
    var_0 = get_vehicle_classname();

    if ( !isdefined( self.script_team ) && isdefined( level.vehicle.templates.team[var_0] ) )
        self.script_team = level.vehicle.templates.team[var_0];
}

vehicle_handleunloadevent()
{
    self endon( "death" );
    var_0 = self.vehicletype;

    if ( !scripts\engine\utility::ent_flag_exist( "unloaded" ) )
        scripts\engine\utility::ent_flag_init( "unloaded" );
}

get_vehiclenode_any_dynamic( var_0 )
{
    var_1 = getvehiclenode( var_0, "targetname" );

    if ( !isdefined( var_1 ) )
        var_1 = getent( var_0, "targetname" );
    else if ( ishelicopter_internal() )
    {

    }

    if ( !isdefined( var_1 ) )
        var_1 = scripts\engine\utility::getstruct( var_0, "targetname" );

    return var_1;
}

vehicle_damagelogic()
{
    self endon( "death" );
    self.damage_functions = [];
    var_0 = get_vehicle_classname();

    if ( isdefined( level.vehicle.templates.bullet_shield[var_0] ) && !isdefined( self.script_bulletshield ) )
        self.script_bulletshield = level.vehicle.templates.bullet_shield[var_0];

    if ( isdefined( level.vehicle.templates.grenade_shield[var_0] ) && !isdefined( self.script_grenadeshield ) )
        self.script_grenadeshield = level.vehicle.templates.bullet_shield[var_0];

    self.healthbuffer = 20000;
    self.health = self.health + self.healthbuffer;
    var_1 = self.health;

    while ( self.health > 0 )
    {
        self waittill( "damage", var_2, var_3, var_4, var_5, var_6, var_7, var_8, var_9, var_10, var_11 );

        if ( istrue( self.interaction_is_jugg_maze_button ) )
            return;

        foreach ( var_13 in self.damage_functions )
            thread [[ var_13 ]]( var_2, var_3, var_4, var_5, var_6, var_7, var_8, var_9, var_10, var_11 );

        if ( isdefined( var_3 ) )
        {
            var_3 scripts\engine\utility::script_func( "register_shot_hit" );

            if ( scripts\engine\utility::func_ref_exist( "vehicle_damage_modifier" ) )
            {
                var_15 = undefined;

                if ( isdefined( level.player_xp ) )
                    var_15 = [[ level.player_xp ]]( var_3, self, var_2, var_11, var_6, undefined, var_5, var_4, var_7, var_9, var_8, var_10 );

                if ( isdefined( var_15 ) )
                    self.is_area_in_verdansk = var_15;
                else
                    self.is_area_in_verdansk = undefined;

                var_16 = scripts\engine\utility::script_func( "vehicle_damage_modifier", var_15 );

                if ( isdefined( var_16 ) )
                    var_2 = var_16;
            }
        }

        if ( vehicle_should_regenerate( var_3, var_6 ) || _is_godmode() )
        {
            if ( isdefined( self.regenerate ) && !istrue( self.regenerate ) )
                var_1 = self.health;
            else
                self.health = var_1;
        }
        else
        {
            if ( scripts\common\utility::issp() && isdefined( var_6 ) )
            {
                var_17 = 0;

                if ( var_6 == "MOD_GRENADE_SPLASH" || var_6 == "MOD_PROJECTILE_SPLASH" )
                    var_17 = var_2 * 12;
                else if ( var_6 == "MOD_GRENADE" || var_6 == "MOD_PROJECTILE" )
                    var_17 = var_2 * 5;

                if ( var_17 )
                    self.health = self.health - int( var_17 );
            }

            var_1 = self.health;
        }

        if ( !istrue( self._id_13DD4 ) && self.health <= self.healthbuffer )
            self notify( "death", var_3, var_6, var_11, var_5 );
    }
}

vehicle_isalive( var_0 )
{
    if ( !isdefined( var_0 ) )
        return 0;

    if ( isdefined( var_0.healthbuffer ) && var_0.health < var_0.healthbuffer )
        return 0;

    if ( var_0.health <= 0 )
        return 0;

    return 1;
}

grenadeshielded( var_0 )
{
    if ( !isdefined( self.script_grenadeshield ) )
        return 0;

    var_0 = tolower( var_0 );

    if ( !isdefined( var_0 ) || !issubstr( var_0, "grenade" ) )
        return 0;

    if ( self.script_grenadeshield )
        return 1;
    else
        return 0;
}

bulletshielded( var_0 )
{
    if ( !isdefined( self.script_bulletshield ) )
        return 0;

    var_0 = tolower( var_0 );

    if ( !isdefined( var_0 ) || !issubstr( var_0, "bullet" ) || issubstr( var_0, "explosive" ) )
        return 0;

    if ( self.script_bulletshield )
        return 1;
    else
        return 0;
}

explosive_bulletshielded( var_0 )
{
    if ( !isdefined( self.script_explosive_bullet_shield ) )
        return 0;

    var_0 = tolower( var_0 );

    if ( !isdefined( var_0 ) || !issubstr( var_0, "explosive" ) )
        return 0;

    if ( self.script_explosive_bullet_shield )
        return 1;
    else
        return 0;
}

vehicle_should_regenerate( var_0, var_1 )
{
    return !isdefined( var_0 ) && self.script_team != "neutral" || attacker_isonmyteam( var_0 ) || attacker_troop_isonmyteam( var_0 ) || is_invulnerable_from_ai( var_0 ) || bulletshielded( var_1 ) || explosive_bulletshielded( var_1 ) || grenadeshielded( var_1 ) || var_1 == "MOD_MELEE";
}

_is_godmode()
{
    return istrue( self.godmode );
}

is_invulnerable_from_ai( var_0 )
{
    if ( !isdefined( self.script_ai_invulnerable ) )
        return 0;

    if ( isdefined( var_0 ) && isai( var_0 ) && self.script_ai_invulnerable == 1 )
        return 1;
    else
        return 0;
}

attacker_troop_isonmyteam( var_0 )
{
    if ( !istrue( self._id_13DD4 ) && isdefined( self.script_team ) && self.script_team == "allies" && isdefined( var_0 ) && isplayer( var_0 ) )
        return 1;
    else if ( isai( var_0 ) && scripts\engine\utility::is_equal( var_0.team, self.script_team ) )
        return 1;
    else
        return 0;
}

attacker_isonmyteam( var_0 )
{
    if ( isdefined( var_0 ) && isdefined( var_0.script_team ) && isdefined( self.script_team ) && var_0.script_team == self.script_team )
        return 1;

    return 0;
}

vehicle_setwheeldirection( var_0 )
{
    self.vehiclewheeldirection = scripts\engine\utility::ter_op( var_0 <= 0, 0, 1 );
}

vehicle_playexhausteffect()
{
    self endon( "entitydeleted" );
    self endon( "death" );

    if ( !isdefined( level.vehicle.templates.exhaust_fx[self.model] ) )
        return;

    for (;;)
    {
        playfxontag( level.vehicle.templates.exhaust_fx[self.model], self, "tag_engine_exhaust" );
        waitframe();
    }
}

vehicle_playengineeffect()
{
    var_0 = level.vehicle.templates.engine_fx[self.classname];

    if ( !isdefined( var_0 ) )
        return;

    var_1 = 0.25;
    var_2 = undefined;
    var_3 = undefined;

    for (;;)
    {
        if ( !vehicle_isalive( self ) )
            return;

        var_4 = var_0.effect;
        var_3 = var_0.effect_tag;
        var_5 = self vehicle_getspeed() / self vehicle_gettopspeedforward();

        if ( isdefined( self.enginefx_effort_scale ) )
            var_5 = var_5 * self.enginefx_effort_scale;

        if ( isdefined( var_0.max_effort_effect ) && var_5 >= var_0.max_effort_ratio )
            var_4 = var_0.max_effort_effect;
        else if ( isdefined( var_0.med_effort_effect ) && var_5 >= var_0.med_effort_ratio )
            var_4 = var_0.med_effort_effect;
        else if ( isdefined( var_0.min_effort_effect ) && var_5 >= var_0.min_effort_ratio )
            var_4 = var_0.min_effort_effect;

        if ( !isdefined( var_2 ) || var_2 != var_4 )
        {
            if ( isdefined( var_2 ) )
            {
                stopfxontag( var_2, self, var_3 );
                waitframe();

                if ( !vehicle_isalive( self ) )
                    return;
            }

            playfxontag( var_4, self, var_3 );
            var_2 = var_4;
        }

        wait( var_1 );
    }
}

vehicle_pathdetach()
{
    self.attachedpath = undefined;
    self notify( "newpath" );

    if ( ishelicopter_internal() )
    {
        self setgoalyaw( scripts\engine\utility::flat_angle( self.angles )[1] );
        self setvehgoalpos( self.origin + ( 0, 0, 4 ), 1 );
    }
}

deathrollon()
{
    if ( self.health > 0 )
        self.rollingdeath = 1;
}

deathrolloff()
{
    self.rollingdeath = undefined;
    self notify( "deathrolloff" );
}

_mainturretoff()
{
    self.script_turretmain = 0;

    if ( !isdefined( self.mainturret ) )
        return;

    _turretoffshared( self.mainturret );
}

_mainturreton()
{
    self.script_turretmain = 1;

    if ( !isdefined( self.mainturret ) )
        return;

    _turretonshared( self.mainturret );
}

_mgoff()
{
    self.script_turretmg = 0;

    if ( ishelicopter_internal() && hashelicopterturret() )
    {
        if ( isdefined( level.chopperturretfunc ) )
        {
            self thread [[ level.chopperturretofffunc ]]();
            return;
        }
    }

    if ( !isdefined( self.mgturret ) )
        return;

    foreach ( var_2, var_1 in self.mgturret )
        _turretoffshared( var_1 );
}

_mgon()
{
    self.script_turretmg = 1;

    if ( ishelicopter_internal() && hashelicopterturret() )
    {
        self thread [[ level.chopperturretonfunc ]]();
        return;
    }

    if ( !isdefined( self.mgturret ) )
        return;

    foreach ( var_1 in self.mgturret )
    {
        var_1 show();
        _turretonshared( var_1 );
    }
}

_turretoffshared( var_0 )
{
    if ( isdefined( var_0.script_fireondrones ) )
        var_0.script_fireondrones = 0;

    var_0 setmode( "manual" );
}

_turretonshared( var_0 )
{
    if ( isdefined( var_0.script_fireondrones ) )
        var_0.script_fireondrones = 1;

    if ( isdefined( var_0.defaultonmode ) )
    {
        if ( var_0.defaultonmode != "sentry" )
            var_0 setmode( var_0.defaultonmode );
    }
    else
        var_0 setmode( "auto_nonai" );

    set_turret_team( var_0 );
}

get_vehicle_riders_spawners()
{
    var_0 = [];

    if ( isdefined( self.target ) )
    {
        var_1 = scripts\engine\utility::noself_func_return( "getspawnerarray", self.target );

        if ( !isdefined( var_1 ) )
            var_1 = scripts\engine\utility::getstructarray( self.target, "targetname" );

        if ( !isdefined( var_1 ) )
            var_1 = [];

        foreach ( var_3 in var_1 )
        {
            if ( isstruct( var_3 ) )
            {
                if ( !isdefined( var_3.script_demeanor ) )
                    continue;
            }
            else
            {
                if ( !issubstr( var_3.code_classname, "actor" ) && !issubstr( var_3.code_classname, "vehicle" ) )
                    continue;

                if ( issubstr( var_3.code_classname, "actor" ) )
                {
                    if ( !isspawner( var_3 ) )
                        continue;
                    else if ( issubstr( var_3.code_classname, "vehicle" ) )
                    {
                        if ( !( var_3.spawnflags & 2 ) )
                            continue;
                    }
                }
            }

            if ( isdefined( var_3.dont_auto_ride ) )
                continue;

            var_0[var_0.size] = var_3;
        }
    }

    return var_0;
}

vehicle_spawn_internal( var_0 )
{
    if ( isdefined( var_0.script_delay_spawn ) )
    {
        var_0 endon( "death" );
        wait( var_0.script_delay_spawn );
    }

    if ( !scripts\common\utility::issp() )
        var_1 = vehicle_spawn_mp_internal( var_0 );
    else
        var_1 = var_0 vehicle_dospawn();

    if ( !isdefined( var_0.spawned_count ) )
        var_0.spawned_count = 0;

    var_0.spawned_count++;
    var_0.vehicle_spawned_thisframe = var_1;
    var_0.last_spawned_vehicle = var_1;
    var_0 thread remove_vehicle_spawned_thisframe();
    var_1.vehicle_spawner = var_0;
    thread vehicle_init( var_1 );
    var_0 notify( "spawned", var_1 );
    return var_1;
}

vehicle_spawn_mp_internal( var_0 )
{
    var_1 = "temp_vehicle_targetname";

    if ( isdefined( var_0.targetname ) )
        var_1 = var_0.targetname;

    if ( !isdefined( var_0.classname_mp ) )
        var_2 = var_0.classname;
    else
        var_2 = var_0.classname_mp;

    var_3 = spawnvehicle( level.vehicle.templates.model[var_2], var_1, var_0.vehicletype, var_0.origin, var_0.angles );
    var_3.vehicletype = var_0.vehicletype;
    var_3.classname_mp = var_2;

    if ( isdefined( var_0.target ) )
        var_3.target = var_0.target;

    return var_3;
}

setvehgoalpos_wrap( var_0, var_1 )
{
    return _setvehgoalpos_wrap( var_0, var_1 );
}

vehicle_liftoffvehicle( var_0 )
{
    if ( !isdefined( var_0 ) )
        var_0 = 512;

    var_1 = self.origin + ( 0, 0, var_0 );
    self setneargoalnotifydist( 10 );
    setvehgoalpos_wrap( var_1, 1 );
    self waittill( "goal" );
}

vehicle_shouldplaydeathanimation( var_0 )
{
    if ( !vehicle_hasdeathanimations( var_0 ) )
        return 0;

    if ( istrue( self.vehicle_skipdeathanimation ) )
        return 0;

    return 1;
}

vehicle_hasdeathanimations( var_0 )
{
    return isdefined( level.vehicle.templates.deathanimations[var_0 get_vehicle_classname()] );
}

vehicle_getdeathanimation( var_0, var_1 )
{
    var_2 = level.vehicle.templates.deathanimations[var_0 get_vehicle_classname()];

    if ( isdefined( var_1 ) )
    {
        var_3 = var_0 getpointinbounds( 0.5, 0.5, 0.5 );
        var_4 = var_1 - var_3;
        var_5 = [];
        var_5["forward"] = anglestoforward( var_0.angles );
        var_5["right"] = anglestoright( var_0.angles );
        var_5["backward"] = var_5["forward"] * -1;
        var_5["left"] = var_5["right"] * -1;
        var_6 = undefined;
        var_7 = -999999;
        var_8 = [ "forward", "right", "backward", "left" ];

        foreach ( var_10 in var_8 )
        {
            var_11 = var_5[var_10];
            var_12 = scripts\engine\math::scalar_projection( var_11, var_4 );

            if ( !isdefined( var_6 ) || var_12 > var_7 )
            {
                var_6 = var_10;
                var_7 = var_12;
            }
        }

        return var_2[var_6];
    }
    else
        return scripts\engine\utility::random( var_2 );
}

vehicle_playdeathanimation( var_0 )
{
    self vehicle_turnengineoff();
    scripts\engine\utility::self_func( "vehicle_orientto", self.origin, self.angles, 0, 0 );
    self useanimtree( #animtree );
    self animscripted( "vehicle_playDeathAnimation", self.origin, self.angles, var_0 );
    self setneargoalnotifydist( 30 );

    if ( scripts\common\vehicle::ishelicopter() )
    {
        self setvehgoalpos( self.origin, 1 );
        self setgoalyaw( self.angles[1] );
    }
}

vehicle_setcrashing( var_0 )
{
    self.vehiclecrashing = var_0;
}

vehicle_docrash( var_0, var_1 )
{
    if ( istrue( self.vehicle_skipdeathcrash ) )
        return;

    vehicle_setcrashing( 1 );

    if ( self vehicle_isphysveh() )
    {
        self vehphys_crash();

        if ( !istrue( self.dontdisconnectpaths ) )
            self disconnectpaths();

        while ( !vehicle_iscorpse() && isdefined( self ) && !vehicle_is_stopped() )
            waitframe();
    }
    else if ( ishelicopter_internal() )
    {
        thread vehicle_helicoptercrash( var_0, var_1 );
        self waittill( "vehicle_crashDone" );
    }

    vehicle_setcrashing( 0 );
}

vehicle_helicoptercrash( var_0, var_1 )
{
    if ( isdefined( var_0 ) && isplayer( var_0 ) )
        self.original_attacker = var_0;

    if ( !isdefined( self ) )
        return;

    detach_getoutrigs();
    thread helicopter_crash_move( var_0, var_1 );
}

helicopter_crash_move( var_0, var_1 )
{
    self endon( "in_air_explosion" );

    if ( isdefined( self.perferred_crash_location ) )
        var_2 = self.perferred_crash_location;
    else
    {
        var_3 = get_unused_crash_locations();
        var_2 = scripts\engine\utility::getclosest( self.origin, var_3 );
    }

    var_2.claimed = 1;
    self notify( "newpath" );
    self notify( "deathspin" );
    var_4 = 0;
    var_5 = 0;

    if ( isdefined( var_2.script_parameters ) && var_2.script_parameters == "direct" )
        var_5 = 1;

    if ( isdefined( self.heli_crash_indirect_zoff ) )
    {
        var_5 = 0;
        var_4 = self.heli_crash_indirect_zoff;
    }

    if ( var_5 )
    {
        var_6 = 40;
        self vehicle_setspeed( var_6, 15, 10 );
        self setneargoalnotifydist( var_2.radius );
        self setvehgoalpos( var_2.origin, 0 );
        thread helicopter_crash_flavor( var_2.origin, var_6 );
        scripts\engine\utility::_id_143A5( "goal", "near_goal" );
        helicopter_crash_path( var_2 );
    }
    else
    {
        var_7 = ( var_2.origin[0], var_2.origin[1], self.origin[2] + var_4 );

        if ( isdefined( self.heli_crash_lead ) )
        {
            var_7 = self.origin + self.heli_crash_lead * self vehicle_getvelocity();
            var_7 = ( var_7[0], var_7[1], var_7[2] + var_4 );
        }

        var_6 = 20;

        if ( isdefined( self.crash_speed ) )
            var_6 = self.crash_speed;

        self vehicle_setspeed( var_6, 10, 10 );
        self setneargoalnotifydist( 350 );
        self setvehgoalpos( var_7, 1 );
        thread helicopter_crash_flavor( var_7, 40 );
        var_8 = "blank";

        while ( var_8 != "death" )
        {
            var_8 = scripts\engine\utility::_id_143A6( "goal", "near_goal", "death" );

            if ( !isdefined( var_8 ) && !isdefined( self ) )
            {
                var_2.claimed = undefined;
                self notify( "vehicle_crashDone" );
                return;
            }
            else
                var_8 = "death";
        }

        self setvehgoalpos( var_2.origin, 0 );
        self waittill( "goal" );
        helicopter_crash_path( var_2 );
    }

    var_2.claimed = undefined;
    self notify( "stop_crash_loop_sound" );
    self notify( "vehicle_crashDone" );
}

helicopter_crash_path( var_0 )
{
    self endon( "death" );
    self endon( "entitydeleted" );

    while ( isdefined( var_0.target ) )
    {
        var_0 = scripts\engine\utility::getstruct( var_0.target, "targetname" );
        var_1 = 56;

        if ( isdefined( var_0.radius ) )
            var_1 = var_0.radius;

        self setneargoalnotifydist( var_1 );
        self setvehgoalpos( var_0.origin, 0 );
        scripts\engine\utility::_id_143A5( "goal", "near_goal" );
    }
}

helicopter_crash_flavor( var_0, var_1 )
{
    self endon( "vehicle_crashDone" );
    self clearlookatent();

    if ( soundexists( "hind_helicopter_dying_loop" ) )
        self playloopsound( "hind_helicopter_dying_loop" );

    var_2 = 0;

    if ( isdefined( self.preferred_crash_style ) )
    {
        var_2 = self.preferred_crash_style;

        if ( self.preferred_crash_style < 0 )
        {
            var_3 = [ 1, 2, 2 ];
            var_4 = 5;
            var_5 = randomint( var_4 );
            var_6 = 0;

            foreach ( var_9, var_8 in var_3 )
            {
                var_6 = var_6 + var_8;

                if ( var_5 < var_6 )
                {
                    var_2 = var_9;
                    break;
                }
            }
        }
    }

    switch ( var_2 )
    {
        case 1:
            thread helicopter_crash_zigzag();
            break;
        case 2:
            thread helicopter_crash_directed( var_0, var_1 );
            break;
        case 3:
            thread helicopter_in_air_explosion();
            break;
        case 4:
            thread helicopter_pilot_death_explosion();
            break;
        case 0:
        default:
            thread helicopter_crash_rotate();
            break;
    }
}

helicopter_in_air_explosion()
{
    var_0 = get_vehicle_classname();

    if ( isdefined( level.vehicle.templates.vehicle_rocket_death_fx[var_0] ) )
    {
        var_1 = level.vehicle.templates.vehicle_rocket_death_fx[var_0];
        var_2 = var_1[1];

        if ( isdefined( var_2.waitdelay ) )
            wait( var_2.waitdelay );

        waitframe();
    }

    self notify( "vehicle_crashDone" );
    self notify( "in_air_explosion" );
}

helicopter_pilot_death_explosion()
{
    thread helicopter_crash_rotate();
    scripts\engine\utility::waittill_notify_or_timeout( "goal", 3 );
    self notify( "flavor_done" );
    thread helicopter_in_air_explosion();
}

helicopter_unloading_watcher()
{
    if ( !scripts\common\vehicle::ishelicopter() )
        return;

    self endon( "vehicle_crashDone" );
    self waittill( "unloading" );
    self.unloading = 1;
    self waittill( "unloaded" );
    self.unloading = 0;
}

helicopter_crash_directed( var_0, var_1 )
{
    self endon( "vehicle_crashDone" );
    self clearlookatent();
    self setmaxpitchroll( randomintrange( 20, 90 ), randomintrange( 5, 90 ) );
    self setyawspeed( 400, 100, 100 );
    var_2 = 90 * randomintrange( -2, 3 );

    for (;;)
    {
        var_3 = var_0 - self.origin;
        var_4 = vectortoyaw( var_3 );
        var_4 = var_4 + var_2;
        self settargetyaw( var_4 );
        wait 0.1;
    }
}

helicopter_crash_zigzag()
{
    self endon( "vehicle_crashDone" );
    self clearlookatent();
    self setyawspeed( 400, 100, 100 );
    var_0 = randomint( 2 );

    for (;;)
    {
        if ( !isdefined( self ) )
            return;

        var_1 = randomintrange( 20, 120 );

        if ( var_0 )
            self settargetyaw( self.angles[1] + var_1 );
        else
            self settargetyaw( self.angles[1] - var_1 );

        var_0 = 1 - var_0;
        var_2 = randomfloatrange( 0.5, 1.0 );
        wait( var_2 );
    }
}

helicopter_crash_rotate()
{
    self endon( "vehicle_crashDone" );
    self clearlookatent();
    self setmaxpitchroll( 60, 90 );
    self setyawspeed( 700, 200, 200 );

    for (;;)
    {
        if ( !isdefined( self ) )
            return;

        var_0 = randomintrange( 140, 170 );
        self settargetyaw( self.angles[1] + var_0 );
        wait 0.5;
    }
}

get_unused_crash_locations()
{
    var_0 = [];
    level.vehicle.helicopter_crash_locations = scripts\engine\utility::array_removeundefined( level.vehicle.helicopter_crash_locations );

    foreach ( var_2 in level.vehicle.helicopter_crash_locations )
    {
        if ( isdefined( var_2.claimed ) )
            continue;

        var_0[var_0.size] = var_2;
    }

    return var_0;
}

vehicle_iscorpse()
{
    return isdefined( self ) && get_vehicle_classname() == "script_vehicle_corpse";
}

detach_getoutrigs()
{
    if ( !isdefined( self.fastroperig ) )
        return;

    if ( !self.fastroperig.size )
        return;

    var_0 = getarraykeys( self.fastroperig );

    for ( var_1 = 0; var_1 < var_0.size; var_1++ )
    {
        if ( isdefined( self.fastroperig[var_0[var_1]] ) )
            self.fastroperig[var_0[var_1]] unlink();
    }
}

vehicle_setdeathmodel()
{
    if ( !isdefined( level.vehicle.templates.deathmodel[self.model] ) )
        return;

    if ( istrue( self.vehicle_skipdeathmodel ) )
        return;

    self setmodel( level.vehicle.templates.deathmodel[self.model] );
}
