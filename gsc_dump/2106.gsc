// IW8 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

set_default_aim_limits( var_0 )
{
    if ( isdefined( var_0 ) )
        self setdefaultaimlimits( var_0 );
    else
        self setdefaultaimlimits();

    if ( scripts\engine\utility::actor_is3d() )
    {
        self.upaimlimit = -65;
        self.downaimlimit = 65;
        self.rightaimlimit = -56;
        self.leftaimlimit = 56;
    }
}

set_aim_and_turn_limits()
{
    set_default_aim_limits();

    if ( self.currentpose == "stand" && !scripts\engine\utility::actor_is3d() )
    {
        self.upaimlimit = -45;
        self.downaimlimit = 80;

        if ( self.unittype == "juggernaut" )
            self.upaimlimit = -80;
    }
    else if ( self.currentpose == "prone" )
    {
        self.rightaimlimit = -45;
        self.leftaimlimit = 45;
    }

    self.turnthreshold = self.defaultturnthreshold;
    self.pitchturnthreshold = self.defaultpitchturnthreshold;
}

chooseanimshoot( var_0, var_1, var_2 )
{
    var_3 = var_2;
    var_4 = self._blackboard.shootstate + "_" + var_3;

    if ( isdefined( self._blackboard.shootstate ) && scripts\asm\asm::asm_hasalias( var_1, var_4 ) )
        return scripts\asm\asm::asm_lookupanimfromalias( var_1, var_4 );

    return scripts\asm\asm::asm_lookupanimfromalias( var_1, var_2 );
}

choosedemeanoranimwithoverride( var_0, var_1, var_2 )
{
    var_3 = scripts\asm\asm::asm_getdemeanor();

    if ( scripts\asm\asm::asm_hasdemeanoranimoverride( var_3, var_2 ) )
    {
        var_4 = scripts\asm\asm::asm_getdemeanoranimoverride( var_3, var_2 );

        if ( isarray( var_4 ) )
            return var_4[randomint( var_4.size )];

        return var_4;
    }

    if ( !scripts\asm\asm::asm_hasalias( var_1, var_3 ) )
        return scripts\asm\asm::asm_lookupanimfromalias( var_1, "default" );

    return scripts\asm\asm::asm_lookupanimfromalias( var_1, var_3 );
}

choosedemeanoranimwithoverridevariants( var_0, var_1, var_2 )
{
    var_3 = scripts\asm\asm::asm_getdemeanor();

    if ( scripts\asm\asm::asm_hasdemeanoranimoverride( var_3, var_2 ) )
    {
        var_4 = scripts\asm\asm::asm_getdemeanoranimoverride( var_3, var_2 );

        if ( isarray( var_4 ) )
            return var_4[randomint( var_4.size )];

        return var_4;
    }

    if ( !scripts\asm\asm::asm_hasalias( var_1, var_3 ) )
    {
        var_5 = [];
        var_5[0] = scripts\asm\asm::asm_lookupanimfromalias( var_1, "trans_to_one_hand_run" );
        var_5[1] = scripts\asm\asm::asm_lookupanimfromalias( var_1, "one_hand_run" );
        var_5[2] = scripts\asm\asm::asm_lookupanimfromalias( var_1, "trans_to_two_hand_run" );
        var_5[3] = scripts\asm\asm::asm_lookupanimfromalias( var_1, "two_hand_run" );
        return var_5;
    }

    return scripts\asm\asm::asm_lookupanimfromalias( var_1, var_3 );
}

chooseanim_exposedreload( var_0, var_1, var_2 )
{
    var_2 = "";

    if ( isdefined( self.node ) && self.node.type == "Cover Stand" )
    {
        if ( !self.node scripts\engine\utility::isvalidpeekoutdir( "over" ) )
            var_2 = var_2 + "_high";
    }

    return chooseanim_weaponclassprepended( var_0, var_1, var_2 );
}

chooseanim_weaponswitch( var_0, var_1, var_2 )
{
    if ( weaponclass( self.weapon ) == "rocketlauncher" && scripts\asm\asm::asm_hasalias( var_1, "drop_rpg" ) )
        return scripts\asm\asm::asm_lookupanimfromalias( var_1, "drop_rpg" );

    var_3 = scripts\asm\asm_bb::bb_getrequestedweapon();

    if ( !scripts\asm\asm::asm_hasalias( var_1, var_3 ) )
        var_3 = "rifle";

    return scripts\asm\asm::asm_lookupanimfromalias( var_1, var_3 );
}

isspeedwithincqbrange( var_0, var_1 )
{
    if ( !getanimspeedthreshold( var_0, "fast" ) || !getanimspeedthreshold( var_0, "jog" ) )
        return 0;

    return var_1 < getcoveranglelimits( var_0, "fast", "jog", 0.1 );
}

isspeedwithinsprintrange( var_0, var_1 )
{
    return var_1 > getcoveranglelimits( var_0, "run", "sprint", 0.1 );
}

isspeedwithincombatrange( var_0, var_1 )
{
    if ( getanimspeedthreshold( var_0, "fast" ) && getanimspeedthreshold( var_0, "jog" ) && var_1 < getcoveranglelimits( var_0, "fast", "jog", 0.9 ) )
        return 0;

    if ( getanimspeedthreshold( var_0, "run" ) && getanimspeedthreshold( var_0, "sprint" ) && var_1 > getcoveranglelimits( var_0, "run", "sprint", 0.1 ) )
        return 0;

    return 1;
}

isspeedwithincombatrangeextended( var_0, var_1 )
{
    if ( getanimspeedthreshold( var_0, "fast" ) && getanimspeedthreshold( var_0, "jog" ) && var_1 < getcoveranglelimits( var_0, "fast", "jog", 0.8 ) )
        return 0;

    if ( getanimspeedthreshold( var_0, "run" ) && getanimspeedthreshold( var_0, "sprint" ) && var_1 > getcoveranglelimits( var_0, "run", "sprint", 0.3 ) )
        return 0;

    return 1;
}

movetypeisnotcasual( var_0, var_1, var_2, var_3 )
{
    var_4 = scripts\asm\asm::asm_getdemeanor();
    return var_4 != "casual" && var_4 != "casual_gun";
}

getnodeforwardyawnodetypelookupoverride( var_0, var_1 )
{
    if ( isdefined( var_0 ) )
    {
        switch ( var_0 )
        {
            case "Cover Left":
                if ( var_1 == "crouch" )
                    return "Cover Left Crouch";

                break;
            case "Cover Right":
                if ( var_1 == "crouch" )
                    return "Cover Right Crouch";

                break;
            case "Conceal Crouch":
            case "Cover Crouch Window":
                return "Cover Crouch";
            case "Conceal Stand":
                return "Cover Stand";
        }
    }

    return undefined;
}

overridecovercrouchnodetype( var_0 )
{
    if ( var_0.type == "Cover Crouch" && isdefined( self._blackboard.croucharrivaltype ) )
        return self._blackboard.croucharrivaltype;

    return var_0.type;
}

getnodeoffsetposeoverride( var_0, var_1, var_2 )
{
    var_3 = self.currentpose;

    if ( isdefined( var_2 ) )
        var_3 = var_2;
    else if ( isnode( var_0 ) && !var_0 doesnodeallowstance( var_3 ) )
        var_3 = var_0 gethighestnodestance();

    var_4 = getnodeforwardyawnodetypelookupoverride( var_1, var_3 );
    return var_4;
}

getnodeyawfromoffsettable( var_0, var_1, var_2 )
{
    var_3 = self.currentpose;

    if ( isdefined( var_2 ) )
        var_3 = var_2;
    else if ( isnode( var_1 ) && !var_1 doesnodeallowstance( var_3 ) )
        var_3 = var_1 gethighestnodestance();

    var_4 = overridecovercrouchnodetype( var_1 );
    var_5 = getnodeforwardyawnodetypelookupoverride( var_4, var_3 );

    if ( isdefined( var_5 ) && isdefined( var_0[var_5] ) )
        return var_0[var_5];

    if ( isdefined( var_0[var_4] ) )
        return var_0[var_4];

    return undefined;
}

allowlmgarrival()
{
    if ( istrue( self.disablelmgmount ) )
        return 0;

    var_0 = weaponclass( self.weapon ) == "mg";

    if ( var_0 )
    {
        if ( !isdefined( self.node ) || self.node isnodelmgmountable() )
            return 1;

        return 0;
    }

    if ( isdefined( self._blackboard.deployedlmgnode ) && isdefined( self.node ) && self.node == self._blackboard.deployedlmgnode && self.node isnodelmgmountable() )
        return 1;

    return 0;
}

getnodeyawoffset( var_0, var_1, var_2 )
{
    if ( isstruct( var_0 ) || !isdefined( var_0.type ) )
        return 0;

    if ( istrue( self._blackboard.inlmgstate ) || istrue( self.asm.usingaturret ) )
        return 0;

    var_3 = overridecovercrouchnodetype( var_0 );
    var_4 = self getnodehideyaw( var_0, var_3, var_1, var_2 );
    return var_4;
}

getnodeforwardyaw( var_0, var_1, var_2 )
{
    if ( !isdefined( var_2 ) )
        var_2 = 1;

    var_3 = getnodeyawoffset( var_0, var_1, var_2 );
    return var_0.angles[1] + var_3;
}

getnodeforwardangles( var_0, var_1 )
{
    var_2 = getnodeyawoffset( var_0, var_1, 1 );
    return combineangles( var_0.angles, ( 0, var_2, 0 ) );
}

getnodeleanyaw( var_0, var_1, var_2 )
{
    if ( !isdefined( var_1 ) )
        var_1 = var_0.type;

    var_3 = getnodeoffsetposeoverride( var_0, var_1, var_2 );

    if ( isdefined( var_3 ) )
        return self getnodeleanaimyawoffset( var_3 );
    else
        return self getnodeleanaimyawoffset( var_1 );
}

getnodeaimpitchoffset( var_0, var_1, var_2 )
{
    var_3 = undefined;

    if ( var_2 == "exposed" )
        var_3 = anim.nodeexposedpitches[var_0];
    else if ( var_2 == "lean" || var_2 == "leanover" )
        var_3 = anim.nodeleanpitches[var_0];
    else if ( var_2 == "overlean" )
        var_3 = anim.nodeoverleanpitches[var_0];

    if ( isdefined( var_3 ) )
    {
        var_4 = getnodeyawfromoffsettable( var_3, var_1, undefined );

        if ( isdefined( var_4 ) )
            return var_4;
    }

    return 0;
}

getnodeaimyawoffset( var_0, var_1, var_2 )
{
    if ( var_2 == "lean" )
    {
        var_3 = overridecovercrouchnodetype( var_1 );
        return self getnodeleanaimyaw( var_1, var_3 );
    }

    return 0;
}

nodeiscoverstand3dtype( var_0 )
{
    if ( var_0.type == "Cover Stand 3D" )
        return !nodeiscoverexposed3dtype( var_0 );

    return 0;
}

nodeiscoverexposed3dtype( var_0 )
{
    if ( var_0.type == "Cover Stand 3D" )
    {
        if ( isdefined( var_0.script_parameters ) && var_0.script_parameters == "exposed" )
            return 1;
    }

    return 0;
}

getnodetypename( var_0 )
{
    if ( isdefined( var_0 ) )
    {
        if ( nodeiscoverexposed3dtype( var_0 ) )
            return "Cover Exposed 3D";
        else
            return var_0.type;
    }

    return "undefined";
}

choosestrongdamagedeath( var_0, var_1, var_2 )
{
    var_3 = undefined;

    if ( abs( self.damageyaw ) > 150 )
    {
        if ( scripts\engine\utility::damagelocationisany( "left_leg_upper", "left_leg_lower", "right_leg_upper", "right_leg_lower", "left_foot", "right_foot" ) )
            var_3 = "legs";
        else if ( self.damagelocation == "torso_lower" )
            var_3 = "torso_lower";
        else
            var_3 = "default";
    }
    else if ( self.damageyaw < 0 )
        var_3 = "right";
    else
        var_3 = "left";

    return scripts\asm\asm::asm_lookupanimfromalias( var_1, var_3 );
}

isatcovernode()
{
    return isdefined( scripts\asm\asm_bb::bb_getcovernode() );
}

setuseanimgoalweight( var_0, var_1 )
{
    self endon( var_0 + "_finished" );
    self.useanimgoalweight = 1;
    thread setuseanimgoalweight_wait( var_0 );

    if ( var_1 > 0 )
        wait( var_1 );

    self.useanimgoalweight = 0;
    self notify( "StopUseAnimGoalWeight" );
}

setuseanimgoalweight_wait( var_0 )
{
    self notify( "StopUseAnimGoalWeight" );
    self endon( "StopUseAnimGoalWeight" );
    self endon( "death" );
    self endon( "entitydeleted" );
    self waittill( var_0 + "_finished" );
    self.useanimgoalweight = 0;
}

shouldleaveanimscripted( var_0, var_1, var_2, var_3 )
{
    if ( scripts\asm\asm_bb::bb_isanimscripted() )
        return 0;

    var_4 = var_3;

    if ( var_4 )
    {
        if ( self.a.movement == "stop" )
            return 0;

        if ( !scripts\asm\asm_bb::bb_moverequested() )
            return 0;
    }
    else if ( scripts\asm\asm_bb::bb_moverequested() && self.a.movement != "stop" )
        return 0;

    return 1;
}

scriptedcoverposerequestis( var_0, var_1, var_2, var_3 )
{
    var_4 = var_3;

    if ( self.a.coverpose_request == var_4 )
    {
        self.a.coverpose_request = undefined;
        return 1;
    }

    return 0;
}

scriptedcoverposerequestisdefined( var_0, var_1, var_2, var_3 )
{
    return isdefined( self.a.coverpose_request );
}

animscriptedaction( var_0, var_1, var_2 )
{
    self endon( var_1 + "_finished" );
    self.a.movement = "run";
    self.gunposeoverride_internal = "disable";
    var_3 = scripts\asm\asm::asm_lookupanimfromalias( var_1, "blank" );
    self aisetanim( var_1, var_3 );
    scripts\asm\asm::asm_donotetracks( var_0, var_1, scripts\asm\asm::asm_getnotehandler( var_0, var_1 ) );
}

randomizepassthroughchildren( var_0, var_1, var_2, var_3 )
{
    var_4 = anim.asm[var_0].states[var_2];

    if ( isdefined( var_4.transitions ) )
    {
        if ( var_4.transitions.size == 2 )
        {
            if ( scripts\engine\utility::cointoss() )
            {
                var_5 = var_4.transitions[0];
                var_4.transitions[0] = var_4.transitions[1];
                var_4.transitions[1] = var_5;
            }
        }
        else
            var_4.transitions = scripts\engine\utility::array_randomize( var_4.transitions );
    }

    return 1;
}

blockedbywall( var_0 )
{
    if ( !isdefined( var_0 ) )
        var_0 = 1;

    if ( isdefined( self._blackboard ) )
    {
        var_1 = gettime();

        if ( isdefined( self._blackboard.gunblockedbywalltime ) )
        {
            if ( var_1 - self._blackboard.gunblockedbywalltime < 300 )
                return 1;

            self._blackboard.gunblockedbywalltime = undefined;
        }

        if ( !var_0 && isdefined( self._blackboard.lastblockedbywallchecktime ) && var_1 - self._blackboard.lastblockedbywallchecktime < 200 )
            return 0;

        self._blackboard.lastblockedbywallchecktime = var_1;

        if ( self isgunblockedbywall() )
        {
            self._blackboard.gunblockedbywalltime = var_1;

            if ( isdefined( scripts\asm\asm_bb::bb_getcovernode() ) && !isdefined( self._blackboard.initialcovergunblockedbywalltime ) && scripts\asm\asm_bb::bb_getrequestedcoverstate() == "exposed" )
                self._blackboard.initialcovergunblockedbywalltime = self._blackboard.gunblockedbywalltime;

            return 1;
        }
        else
            self._blackboard.initialcovergunblockedbywalltime = undefined;
    }

    return 0;
}

nodeshouldfaceangles( var_0 )
{
    if ( !isdefined( var_0 ) )
        return 0;

    if ( isdefined( var_0.angles ) )
        return 1;

    if ( isstruct( var_0 ) )
        return 0;

    return isdefined( var_0.type ) && var_0.type != "Path" && !scripts\engine\utility::isnodeexposed3d( var_0 );
}

choosecrouchorstand( var_0, var_1 )
{
    return int( var_1.origin[0] + var_1.origin[1] + var_1.origin[2] + var_0 getentitynumber() ) % 2;
}

getwincost( var_0, var_1 )
{
    return int( abs( var_1[0] + var_1[1] + var_1[2] + var_0 getentitynumber() ) ) % 2;
}

getarrivalnode()
{
    if ( istrue( self.leavecasualkiller ) )
        return undefined;

    if ( isdefined( self.scriptedarrivalent ) && !self btgoalvalid() )
        return self.scriptedarrivalent;

    if ( isdefined( self.node ) )
        return self.node;

    if ( isdefined( self.prevnode ) && isdefined( self.pathgoalpos ) && distance2dsquared( self.prevnode.origin, self.pathgoalpos ) < 36 )
        return self.prevnode;

    if ( isdefined( self.last_set_goalnode ) )
        return self.last_set_goalnode;

    return self.last_set_goalent;
}

isarrivaltypecivilian( var_0, var_1 )
{
    if ( isdefined( self.asm.customdata.arrivalstate ) )
        return var_1 == "Custom";

    if ( scripts\asm\asm_bb::bb_smartobjectrequested() )
        return var_1 == "Exposed";

    var_2 = getarrivalnode();

    if ( isdefined( var_2 ) && isnode( var_2 ) && var_2 iscovermultinode() )
    {
        var_3 = scripts\engine\utility::getbestcovermultinodetype( var_2 );

        if ( isdefined( var_3 ) )
            var_2 setcovermultinodetype( var_3 );
    }

    if ( !isdefined( var_2 ) || !isdefined( var_2.type ) || var_2.type == "struct" || self.combatmode == "no_cover" )
        return var_1 == "Exposed";

    if ( isdefined( var_2 ) && var_2.type == "Cover Crouch" )
    {
        var_4 = getdvar( "scr_ai_cover_crouch_type" );

        if ( var_4 != "" )
            return var_1 == var_4;

        if ( isdefined( self._blackboard.croucharrivaltype ) )
            return var_1 == self._blackboard.croucharrivaltype;
        else if ( isdefined( var_2.covercrouchtype ) )
            return var_1 == var_2.covercrouchtype;
    }

    var_5 = scripts\asm\asm::asm_getdemeanor();
    var_6 = ( !isnode( var_2 ) || var_2 doesnodeallowstance( "stand" ) ) && self isstanceallowed( "stand" );
    var_7 = ( !isnode( var_2 ) || var_2 doesnodeallowstance( "crouch" ) ) && self isstanceallowed( "crouch" ) && var_5 != "casual" && var_5 != "casual_gun";

    switch ( var_1 )
    {
        case "Exposed":
            if ( var_2.type != "Path" && var_2.type != "Exposed" )
                return 0;

            if ( var_7 && choosecrouchorstand( self, var_2 ) )
                return 0;

            return var_6;
        case "Exposed Crouch":
            if ( var_2.type != "Path" && var_2.type != "Exposed" )
                return 0;

            if ( var_6 && !choosecrouchorstand( self, var_2 ) )
                return 0;

            return var_7;
        case "Cover Crouch":
            return var_2.type == "Cover Crouch" || var_2.type == "Conceal Crouch" || var_2.type == "Cover Crouch Window" || var_2.type == "Cover Stand" || var_2.type == "Conceal Stand" || var_2.type == "Cover Prone" || var_2.type == "Conceal Prone";
        case "Cover Left":
            return var_2.type == "Cover Left";
        case "Cover Right":
            return var_2.type == "Cover Right";
        case "Exposed Moving":
            return var_2.type == "Exposed Moving";
    }

    return var_1 == var_2.type;
}

isarrivaltype( var_0, var_1, var_2, var_3 )
{
    var_4 = var_3;

    if ( isdefined( self.asm.customdata.arrivalstate ) )
        return var_4 == "Custom";

    if ( scripts\asm\asm_bb::bb_smartobjectrequested() )
        return var_4 == "Exposed";

    var_5 = getarrivalnode();

    if ( isdefined( var_5 ) && isnode( var_5 ) && var_5 iscovermultinode() )
    {
        var_6 = scripts\engine\utility::getbestcovermultinodetype( var_5 );

        if ( isdefined( var_6 ) && var_5.type != var_6 && var_4 == var_6 )
            var_5 setcovermultinodetype( var_6 );
    }

    if ( !isdefined( var_5 ) || !isdefined( var_5.type ) || var_5.type == "struct" || self.combatmode == "no_cover" )
    {
        if ( scripts\engine\utility::actor_is3d() )
            return var_4 == "Exposed 3D";
        else
            return var_4 == "Exposed";
    }

    var_7 = allowlmgarrival();

    if ( isdefined( var_5 ) && var_5.type == "Cover Crouch" && !var_7 )
    {
        var_8 = getdvar( "scr_ai_cover_crouch_type" );

        if ( var_8 != "" )
            return var_4 == var_8;

        if ( isdefined( self._blackboard.croucharrivaltype ) )
            return var_4 == self._blackboard.croucharrivaltype;
        else if ( isdefined( var_5.covercrouchtype ) )
            return var_4 == var_5.covercrouchtype;
    }

    var_9 = scripts\asm\asm::asm_getdemeanor();
    var_10 = ( !isnode( var_5 ) || var_5 doesnodeallowstance( "stand" ) ) && self isstanceallowed( "stand" );
    var_11 = ( !isnode( var_5 ) || var_5 doesnodeallowstance( "crouch" ) ) && self isstanceallowed( "crouch" ) && var_9 != "casual" && var_9 != "casual_gun";

    if ( var_0 == "zero_gravity_space" )
    {
        switch ( var_4 )
        {
            case "Exposed 3D":
                return scripts\engine\utility::isnodeexposed3d( var_5 ) && var_10;
            case "Cover 3D":
                return var_5.type == "Cover 3D";
            case "Cover Stand 3D":
                return nodeiscoverstand3dtype( var_5 );
            case "Cover Exposed 3D":
                return nodeiscoverexposed3dtype( var_5 );
            case "Cover Prone":
            case "Exposed Crouch":
            case "Exposed":
            case "Path":
            case "Cover Right Crouch":
            case "Cover Right":
            case "Cover Left Crouch":
            case "Cover Left":
            case "Cover Crouch":
                break;
        }
    }
    else if ( var_0 == "zero_gravity" )
    {
        switch ( var_4 )
        {
            case "Exposed":
                return ( var_5.type == "Path" || var_5.type == "Exposed" ) && var_10;
            case "Exposed Crouch":
                return ( var_5.type == "Path" || var_5.type == "Exposed" ) && var_11;
            case "Cover Crouch":
                return var_5.type == "Cover Crouch" || var_5.type == "Conceal Crouch";
            case "Cover Stand":
                return var_5.type == "Cover Stand" || var_5.type == "Conceal Stand";
            case "Cover Prone":
            case "Cover Right Crouch":
            case "Cover Right":
            case "Cover Left Crouch":
            case "Cover Left":
                break;
        }
    }
    else
    {
        switch ( var_4 )
        {
            case "Exposed":
                if ( var_5.type != "Path" && var_5.type != "Exposed" )
                    return 0;

                if ( var_11 && choosecrouchorstand( self, var_5 ) )
                    return 0;

                return var_10;
            case "Exposed Crouch":
                if ( var_5.type != "Path" && var_5.type != "Exposed" )
                    return 0;

                if ( var_10 && !choosecrouchorstand( self, var_5 ) )
                    return 0;

                return var_11;
            case "Cover Crouch":
                return var_5.type == "Cover Crouch" || var_5.type == "Conceal Crouch" || var_5.type == "Cover Crouch Window";
            case "Cover Stand":
                return var_5.type == "Cover Stand" || var_5.type == "Conceal Stand";
            case "Cover Prone":
                return var_5.type == "Cover Prone" || var_5.type == "Conceal Prone";
            case "Cover Left":
                if ( var_5.type != "Cover Left" )
                    return 0;

                if ( var_11 && choosecrouchorstand( self, var_5 ) )
                    return 0;

                return var_10;
            case "Cover Left Crouch":
                if ( var_5.type != "Cover Left" )
                    return 0;

                if ( var_10 && !choosecrouchorstand( self, var_5 ) )
                    return 0;

                return var_11;
            case "Cover Right":
                if ( var_5.type != "Cover Right" )
                    return 0;

                if ( var_11 && choosecrouchorstand( self, var_5 ) )
                    return 0;

                return var_10;
            case "Cover Right Crouch":
                if ( var_5.type != "Cover Right" )
                    return 0;

                if ( var_10 && !choosecrouchorstand( self, var_5 ) )
                    return 0;

                return var_11;
            case "Cover Crouch LMG":
                return ( var_5.type == "Cover Crouch" || var_5.type == "Cover Prone" ) && allowlmgarrival();
            case "Cover Stand LMG":
                return var_5.type == "Cover Stand" && allowlmgarrival();
            case "Exposed Moving":
                return var_5.type == "Exposed Moving";
        }
    }

    return var_4 == var_5.type;
}

playmoveloop( var_0, var_1, var_2 )
{
    self endon( var_1 + "_finished" );
    thread waitforcoverapproach( var_0, var_1 );
    thread waitforsharpturn( var_0, var_1 );
    thread waitfordooropen( var_0, var_1, 0 );
    var_3 = 1.0;
    scripts\asm\asm::asm_updatefrantic();
    scripts\asm\asm::asm_loopanimstate( var_0, var_1, var_3, 1 );
    scripts\asm\asm::asm_updatefrantic();
}

playmoveloopcasual( var_0, var_1, var_2 )
{
    playmoveloop( var_0, var_1, var_2 );
}

_id_1244E( var_0, var_1, var_2 )
{
    thread waitfordooropen( var_0, var_1, 1 );
    playanim( var_0, var_1, var_2 );
}

waitforcoverapproach( var_0, var_1 )
{
    self endon( var_1 + "_finished" );

    for (;;)
    {
        self.requestarrivalnotify = 1;
        self waittill( "cover_approach", var_2 );
        scripts\asm\asm::asm_fireevent( var_0, "cover_approach", var_2 );
        self.a.approachdir = var_2;
    }
}

waitforsharpturn( var_0, var_1 )
{
    self endon( var_1 + "_finished" );
    self waittill( "path_changed", var_2, var_3, var_4, var_5, var_6 );
    var_7 = [ var_2, var_3, var_4, var_5, var_6 ];
    scripts\asm\asm::asm_fireevent( var_0, "sharp_turn", var_7 );
    thread waitforsharpturn( var_0, var_1 );
}

playmoveloopcasualcleanup( var_0, var_1, var_2 )
{

}

calcdooropenspeed()
{
    if ( scripts\common\utility::iscp() )
        return 0.8;

    var_0 = 0.75;
    var_1 = length( self.velocity );

    if ( var_1 > 0 )
        var_0 = 24 / var_1;

    if ( var_0 < 0.15 )
        var_0 = 0.15;
    else if ( var_0 > 1 )
        var_0 = 1;

    return var_0;
}

opendooratreasonabletime()
{
    var_0 = self._blackboard.doortoopen;
    var_1 = self.fndooropen;

    if ( !isdefined( var_0 ) || !isdefined( var_1 ) )
        return;

    self._blackboard.door_opened = 1;
    self endon( "death" );
    var_0 endon( "death" );
    self endon( "path_has_door" );
    var_2 = self [[ self.fngetdoorcenter ]]( var_0 );
    var_3 = distance2dsquared( var_2, self.origin );
    var_4 = 4096;

    if ( scripts\common\utility::iscp() )
    {
        var_5 = 0.8 * length( self.velocity );
        var_5 = var_5 * 0.9;
        var_4 = max( var_5 * var_5, var_4 );
    }

    while ( var_3 > var_4 )
    {
        if ( isdefined( self._blackboard.doortoopen ) && var_0 != self._blackboard.doortoopen )
            return;

        var_3 = distance2dsquared( var_2, self.origin );
        waitframe();
    }

    var_6 = calcdooropenspeed();
    self notify( "opening_door" );
    self thread [[ var_1 ]]( var_0, var_6 );
    return var_6;
}

opendooratreasonabletime_waitforabort( var_0 )
{
    self endon( "opening_door_done" );
    self waittill( var_0 + "_finished" );

    if ( !isalive( self ) )
        return;

    self._blackboard.doortoopen = undefined;
    self.isopeningdoor = undefined;
    self notify( "opening_door_done" );
}

closedoorifnecessary( var_0 )
{
    if ( self [[ self.fndoorneedstoclose ]]( var_0 ) )
        self [[ self.fndoorclose ]]( var_0 );
}

waitfordooropen( var_0, var_1, var_2 )
{
    self endon( var_1 + "_finished" );
    self endon( "death" );
    self endon( "terminate_ai_threads" );
    waitframe();

    for (;;)
    {
        if ( isdefined( self._blackboard.doortoopen ) )
        {
            var_3 = 0;

            if ( self [[ self.fndooralreadyopen ]]( self._blackboard.doortoopen ) )
                var_3 = 1;

            if ( !var_3 && !isent( self._blackboard.doortoopen ) )
            {
                if ( !isdefined( self getmodifierlocationonpath( "door", 200 ) ) )
                    var_3 = 1;
            }

            if ( var_3 )
            {
                self._blackboard.doortoopen = undefined;
                waitframe();
                continue;
            }

            if ( !self.facemotion )
            {
                var_4 = self.lookaheaddir;
                var_4 = vectornormalize( ( var_4[0], var_4[1], 0 ) );
                var_5 = anglestoforward( self.angles );

                if ( vectordot( var_4, var_5 ) < 0.966 )
                {
                    self.isopeningdoor = 1;
                    var_6 = opendooratreasonabletime();

                    if ( isdefined( var_6 ) )
                    {
                        thread opendooratreasonabletime_waitforabort( var_1 );
                        wait( var_6 );
                    }

                    self notify( "opening_door_done" );
                    self._blackboard.doortoopen = undefined;
                    self.isopeningdoor = undefined;
                    continue;
                }
            }

            var_7 = self._blackboard.doortoopen;
            self._blackboard.door_opened = undefined;
            var_8 = 1;
            var_9 = 160;
            var_10 = 2;
            var_11 = length2d( self.velocity );

            if ( !istrue( var_2 ) )
            {
                var_12 = var_1;
                var_13 = scripts\asm\asm::asm_lookupanimfromaliasifexists( var_1, "2" );

                if ( !isdefined( var_13 ) )
                {
                    var_11 = self aigettargetspeed();
                    var_14 = getnextlowestspeedthresholdstring( self.basearchetype, var_11 );

                    if ( isdefined( var_14 ) )
                    {
                        var_15 = var_14 + "2";
                        var_13 = scripts\asm\asm::asm_lookupanimfromaliasifexists( var_1, var_15 );

                        if ( !isdefined( var_13 ) )
                        {
                            var_12 = "door_open";
                            var_13 = scripts\asm\asm::asm_lookupanimfromaliasifexists( "door_open", var_15 );
                        }
                    }
                }

                if ( !isdefined( var_13 ) )
                    var_13 = scripts\asm\asm::asm_lookupanimfromaliasifexists( "door_open", "2" );

                if ( isdefined( var_13 ) )
                {
                    var_16 = scripts\asm\asm::asm_getxanim( var_12, var_13 );
                    var_17 = getnotetracktimes( var_16, "door_touch" );
                    var_18 = ( var_17[0] * getanimlength( var_16 ) + 2 * level.framedurationseconds ) * var_11;
                    var_9 = var_18 + 24;
                }
            }

            var_19 = var_8 + var_9 + var_10;
            var_20 = self [[ self.fngetdoorcenter ]]( var_7 );
            var_21 = distance2d( var_20, self.origin );

            if ( var_21 < var_19 )
            {
                self.isopeningdoor = 1;
                thread closedoorifnecessary( var_7 );

                if ( istrue( var_2 ) || var_21 < var_19 - var_11 * 2 * level.framedurationseconds )
                {
                    var_6 = opendooratreasonabletime();

                    if ( isdefined( var_6 ) )
                    {
                        thread opendooratreasonabletime_waitforabort( var_1 );
                        wait( var_6 );
                    }

                    self notify( "opening_door_done" );
                    self._blackboard.doortoopen = undefined;
                    self.isopeningdoor = undefined;
                }
                else
                {
                    self setupdooropen( var_7, var_19, getdooropenspeedlookup() );
                    thread handledooropennotetrack( var_0, var_1 );
                    thread handledooropenterminate( var_0, var_1 );
                    self waittill( "opening_door_done" );
                }
            }
        }

        waitframe();
    }
}

handledooropennotetrack( var_0, var_1 )
{
    self endon( var_1 + "_finished" );
    self endon( "opening_door_done" );

    for (;;)
    {
        self waittill( "door_open", var_2 );

        if ( !isarray( var_2 ) )
            var_2 = [ var_2 ];

        for ( var_3 = 0; var_3 < var_2.size; var_3++ )
        {
            if ( var_2[var_3] == "door_open" )
            {
                if ( isdefined( self.fndooropen ) && isdefined( self._blackboard.doortoopen ) )
                {
                    self notify( "opening_door" );
                    var_4 = calcdooropenspeed();
                    self thread [[ self.fndooropen ]]( self._blackboard.doortoopen, var_4 );
                    self._blackboard.door_opened = 1;
                }

                continue;
            }

            if ( var_2[var_3] == "end" )
            {
                self._blackboard.doortoopen = undefined;
                self.isopeningdoor = undefined;
                self cleardooropen();
                self notify( "opening_door_done" );
            }
        }

        waitframe();
    }
}

handledooropenterminate( var_0, var_1 )
{
    self endon( "opening_door_done" );
    self waittill( var_1 + "_finished" );

    if ( !isdefined( self ) || !isalive( self ) )
        return;

    if ( !istrue( self._blackboard.door_opened ) )
        thread opendooratreasonabletime();

    self._blackboard.doortoopen = undefined;
    self.isopeningdoor = undefined;
    self cleardooropen();
}

getdooropenspeedlookup()
{
    if ( self.asm.archetype == "civilian_panic" )
        return "civilian_panic";
    else if ( self.unittype == "civilian" )
        return "civilian";
    else if ( self.asm.archetype == "juggernaut" )
        return "juggernaut";
    else
        return "soldier";
}

playanim( var_0, var_1, var_2 )
{
    scripts\asm\asm::asm_playanimstate( var_0, var_1, var_2 );
}

playanimwithsound( var_0, var_1, var_2 )
{
    self playsound( var_2 );
    scripts\asm\asm::asm_playanimstate( var_0, var_1, var_2 );
}

loopanim( var_0, var_1, var_2 )
{
    scripts\asm\asm::asm_loopanimstate( var_0, var_1, 1.0 );
}

chooseanimidle( var_0, var_1, var_2 )
{
    var_3 = scripts\asm\asm::asm_getdemeanor();

    if ( scripts\asm\asm::asm_hasdemeanoranimoverride( var_3, "idle" ) )
    {
        var_4 = scripts\asm\asm::asm_getdemeanoranimoverride( var_3, "idle" );

        if ( isarray( var_4 ) )
            return var_4[randomint( var_4.size )];

        return var_4;
    }

    if ( isdefined( self.node ) && self.node.type == "Cover Stand" )
    {
        if ( !self.node scripts\engine\utility::isvalidpeekoutdir( "over" ) )
            var_2 = var_2 + "_high";
    }

    return chooseanim_weaponclassprepended( var_0, var_1, var_2 );
}

chooseanim_weaponclassprepended( var_0, var_1, var_2 )
{
    var_3 = weaponclass( self.weapon );
    var_4 = undefined;

    if ( !isdefined( var_2 ) )
        return scripts\asm\asm::asm_getrandomanim( var_0, var_1 );
    else
        var_4 = var_2;

    if ( !scripts\asm\asm::asm_hasalias( var_1, var_3 + var_4 ) )
        var_3 = "rifle";

    return scripts\asm\asm::asm_lookupanimfromalias( var_1, var_3 + var_4 );
}

calcarrivaltype( var_0, var_1, var_2 )
{
    self._blackboard.runpassthroughtype = getarrivaltype();
}

getarrivaltype()
{
    if ( isdefined( self.asm.customdata.arrivalstate ) )
        return "Custom";

    if ( scripts\asm\asm_bb::bb_smartobjectrequested() )
        return "Exposed";

    var_0 = getarrivalnode();

    if ( !isdefined( var_0 ) || !isnode( var_0 ) || !isdefined( var_0.type ) || var_0.type == "struct" || self.combatmode == "no_cover" )
    {
        var_1 = self setcorpsemodel();

        if ( isdefined( var_1 ) )
        {
            var_2 = scripts\asm\asm::asm_getdemeanor();
            var_3 = self isstanceallowed( "crouch" ) && var_2 == "combat";

            if ( var_3 && getwincost( self, var_1 ) )
                return "Exposed Crouch";

            return "Exposed";
        }

        if ( scripts\asm\asm_bb::bb_getrequestedstance() == "crouch" || isfixednodeinbadplaceandshouldcrouch() && self isstanceallowed( "crouch" ) )
            return "Exposed Crouch";

        return "Exposed";
    }

    if ( isdefined( self.enemy ) && iscoverinvalidagainstenemy( var_0 ) || shouldinitiallyattackfromexposed( var_0 ) )
    {
        if ( var_0 doesnodeallowstance( "stand" ) && self isstanceallowed( "stand" ) )
            return "Exposed";
        else if ( var_0 doesnodeallowstance( "crouch" ) && self isstanceallowed( "crouch" ) )
            return "Exposed Crouch";
        else
            return "Cover Prone";
    }

    if ( isnode( var_0 ) && var_0 iscovermultinode() )
    {
        var_4 = scripts\engine\utility::getbestcovermultinodetype( var_0 );

        if ( isdefined( var_4 ) && var_4 != var_0.type )
            var_0 setcovermultinodetype( var_4 );
    }

    var_5 = var_0.type;
    var_6 = allowlmgarrival();

    if ( var_6 )
    {
        switch ( var_5 )
        {
            case "Cover Prone":
            case "Cover Crouch":
                return "Cover Crouch LMG";
            case "Cover Stand":
                return "Cover Stand LMG";
        }
    }

    if ( isdefined( self._blackboard.croucharrivaltype ) && !var_6 )
        return self._blackboard.croucharrivaltype;

    return self choosearrivaltype( var_0, var_5 );
}

shouldstrafe( var_0, var_1, var_2, var_3 )
{
    return scripts\asm\asm_bb::bb_moverequested() && !self.facemotion && self.allowstrafe;
}

shouldabortstrafe( var_0, var_1, var_2, var_3 )
{
    if ( !shouldstrafe( var_0, var_1, var_2, var_3 ) )
        return 1;

    if ( !scripts\asm\asm_bb::bb_movetyperequested( "combat" ) )
        return 1;

    if ( scripts\asm\asm_bb::bb_meleechargerequested() )
        return 1;

    return 0;
}

chooseanimmovetype( var_0, var_1, var_2 )
{
    var_3 = scripts\asm\asm::asm_getdemeanor();

    if ( !scripts\asm\asm::asm_hasalias( var_1, var_3 ) )
        return scripts\asm\asm::asm_chooseanim( var_0, var_1, var_2 );

    return scripts\asm\asm::asm_lookupanimfromalias( var_1, var_3 );
}

transition_isflashed( var_0, var_1, var_2, var_3 )
{
    return scripts\engine\utility::isflashed();
}

transition_isburning( var_0, var_1, var_2, var_3 )
{
    return isdefined( self._blackboard.isburning ) && !istrue( self.damageshield );
}

isdeafened( var_0, var_1, var_2, var_3 )
{
    var_4 = self.damagetaken;

    if ( isdefined( self.paindamage ) )
        var_4 = self.paindamage;

    if ( scripts\common\utility::isdamageweapon( getcompleteweaponname( "iw7_sonic" ) ) && self.damagemod != "MOD_MELEE" && var_4 >= 75 )
        return 1;

    return 0;
}

isspecialpain( var_0, var_1, var_2, var_3 )
{
    return 1;
}

shouldreacttolight( var_0, var_1, var_2, var_3 )
{
    if ( isdefined( self.lightreaction_requesttime ) && self.lightreaction_requesttime >= gettime() - 1000 )
    {
        var_4 = getbasearchetype();

        if ( isspeedwithincqbrange( var_4, self aigetdesiredspeed() ) )
            return 1;
    }

    return 0;
}

chooselightreactionanim( var_0, var_1, var_2 )
{
    var_3 = "center";

    if ( !isdefined( self.lightreaction_lightorigin ) )
        return scripts\asm\asm::asm_lookupanimfromalias( var_1, var_3 );

    if ( isdefined( self.covernode ) )
    {
        var_4 = anglestoright( self.covernode.angles );
        var_5 = anglestoforward( self.covernode.angles );
        var_6 = vectornormalize( self.lightreaction_lightorigin - self.origin );
    }
    else
    {
        var_4 = anglestoright( self.angles );
        var_5 = anglestoforward( self.angles );
        var_6 = vectornormalize( self.lightreaction_lightorigin - self.origin );
    }

    var_7 = vectordot( var_4, var_6 ) >= 0;
    var_8 = vectordot( var_5, var_6 );

    if ( var_8 >= 0.866 )
        var_3 = "center";
    else if ( var_7 )
        var_3 = "right";
    else
        var_3 = "left";

    return scripts\asm\asm::asm_lookupanimfromalias( var_1, var_3 );
}

isshocked( var_0, var_1, var_2, var_3 )
{
    if ( isdefined( self.damagemod ) && self.damagemod == "MOD_IMPACT" )
        return 0;

    if ( scripts\common\utility::isdamageweapon( getcompleteweaponname( "emp" ) ) )
        return 1;

    if ( self.unittype == "c6" || self.unittype == "c8" )
    {
        if ( scripts\common\utility::isdamageweapon( getcompleteweaponname( "iw7_sonic" ) ) && scripts\common\utility::isweaponepic( self.damageweapon ) )
            return 1;
    }

    if ( scripts\common\utility::isdamageweapon( getcompleteweaponname( "iw7_atomizer" ) ) && self.damagemod != "MOD_MELEE" && self.health <= 0 )
        return 1;

    return 0;
}

getdamagedirstring()
{
    var_0 = -1 * self.damagedir;
    var_1 = anglestoforward( self.angles );
    var_2 = vectordot( var_1, var_0 );

    if ( var_2 > 0.707 )
        return "front";
    else if ( var_2 < -0.707 )
        return "back";
    else
    {
        var_3 = vectorcross( var_1, var_0 );

        if ( var_3[2] > 0 )
            return "left";
        else
            return "right";
    }
}

gethumandamagedirstring()
{
    var_0 = -1 * self.damagedir;
    var_1 = anglestoforward( self.angles );
    var_2 = vectordot( var_1, var_0 );

    if ( var_2 < -0.5 )
        return 1;

    return 0;
}

playanimandusegoalweight( var_0, var_1, var_2 )
{
    childthread setuseanimgoalweight( var_1, 0.2 );
    scripts\asm\asm::asm_playanimstate( var_0, var_1 );
}

animscriptedaction_terminate( var_0, var_1, var_2 )
{
    self orientmode( "face angle 3d", self.angles );
    self.gunposeoverride_internal = undefined;

    if ( isdefined( self.lookatatrnode ) )
    {
        var_3 = scripts\asm\asm::asm_getheadlookknobifexists();

        if ( isdefined( var_3 ) )
        {
            self clearanim( var_3, 0.2, self.lookatatrnode );
            self.lookatatrnode = undefined;
        }
    }
}

animsriptedactioncivilian_terminate( var_0, var_1, var_2 )
{
    if ( isdefined( self.lookatatrnode ) )
    {
        var_3 = scripts\asm\asm::asm_getheadlookknobifexists();

        if ( isdefined( var_3 ) )
        {
            self clearanim( var_3, 0.2, self.lookatatrnode );
            self.lookatatrnode = undefined;
        }
    }
}

cleanupanimscriptedheadlook()
{
    self.ht_on = undefined;
    scripts\common\utility::lookatentity();
}

animscriptedstartup( var_0, var_1, var_2 )
{
    self.ht_on = undefined;
    self stoplookat();
}

animscriptedcleanup( var_0, var_1, var_2 )
{
    cleanupanimscriptedheadlook();
}

animscriptedaction_cleanup( var_0, var_1, var_2 )
{
    cleanupanimscriptedheadlook();
}

disabledefaultfacialanims( var_0 )
{
    if ( !isdefined( self.headknob ) )
        self.headknob = scripts\asm\asm::asm_getxanim( "knobs", scripts\asm\asm::asm_lookupanimfromalias( "knobs", "head" ) );

    if ( !isdefined( var_0 ) || var_0 )
    {
        setfacialstate( "vignette" );

        if ( isai( self ) )
            self setfacialindex( "none" );
        else
            setfacialindexfornonai( "none" );
    }
    else
        clearfacialstate( "vignette" );
}

setfacialindexfornonai( var_0 )
{
    var_1 = [];
    var_1["none"] = 0;
    var_1["idle"] = 1;
    var_1["aim"] = 2;
    var_1["run"] = 3;
    var_1["pain"] = 4;
    var_1["death"] = 5;
    var_1["talk"] = 6;
    var_1["happy"] = 7;
    var_1["cheer"] = 8;
    var_1["scared"] = 9;
    var_1["angry"] = 10;
    var_1["gas_death"] = 11;
    self setcustomnodegameparameter( "animtime", self getentitynumber() );
    self setcustomnodegameparameterbyte( "facialindex", var_1[var_0] );
    var_2 = scripts\asm\asm::asm_lookupanimfromalias( "knobs", "head" );

    if ( var_0 == "none" )
        self clearanim( scripts\asm\asm::asm_getxanim( "knobs", var_2 ), 0.2 );
    else
        self setanim( scripts\asm\asm::asm_getxanim( "knobs", var_2 ), 1, 0.2, 1 );
}

setfacialstate( var_0 )
{
    self.facialstate = var_0;
}

clearfacialstate( var_0 )
{
    self.facialstate = "asm";

    if ( !isdefined( self.fakeactor_face_anim ) || !self.fakeactor_face_anim )
        scripts\asm\asm::asm_restorefacialanim();
}

isfacialstateallowed( var_0 )
{
    if ( !isai( self ) && ( !isdefined( self.fakeactor_face_anim ) || !self.fakeactor_face_anim ) )
        return 0;

    if ( !isdefined( self.facialstate ) )
        self.facialstate = "asm";

    var_1 = [];
    var_1["asm"] = 0;
    var_1["filler"] = 1;
    var_1["vignette"] = 2;

    if ( var_1[var_0] >= var_1[self.facialstate] )
        return 1;

    return 0;
}

getshootfrompos()
{
    if ( scripts\engine\utility::actor_is3d() || istrue( self.useeyetoshoot ) )
        return self geteye();
    else
    {
        if ( isdefined( self.usemuzzlesideoffset ) && self.usemuzzlesideoffset )
        {
            var_0 = self getmuzzlesideoffsetpos();

            if ( isdefined( self.usemuzzleheightoffset ) )
                return var_0;

            return ( var_0[0], var_0[1], self geteye()[2] );
        }

        if ( isai( self ) )
            return self getapproxeyepos();
        else
            return ( self.origin[0], self.origin[1], self geteye()[2] );
    }
}

decrementbulletsinclip()
{
    if ( self.bulletsinclip )
        self.bulletsinclip--;
}

grenadelauncherfirerate()
{
    return randomfloatrange( 5, 8 );
}

shotgunfirerate()
{
    if ( scripts\anim\utility_common.gsc::weapon_pump_action_shotgun() )
        return 1.0;

    if ( scripts\anim\weaponlist.gsc::usingautomaticweapon() )
        return scripts\anim\weaponlist.gsc::autoshootanimrate() * 0.7;

    return 0.4;
}

getsniperburstdelaytime()
{
    if ( isplayer( self.enemy ) )
        return randomfloatrange( self.enemy.gs.min_sniper_burst_delay_time, self.enemy.gs.max_sniper_burst_delay_time );
    else
        return randomfloatrange( anim.min_sniper_burst_delay_time, anim.max_sniper_burst_delay_time );
}

melee_checktimer( var_0, var_1 )
{
    if ( isdefined( self.meleeignoretimer ) && self.meleeignoretimer )
        return 1;

    if ( !isdefined( var_1 ) )
        var_1 = 0;

    if ( var_1 )
    {
        if ( !isdefined( anim.meleechargeplayertimers ) )
            return 1;

        if ( !isdefined( anim.meleechargeplayertimers[var_0] ) )
            return 1;

        return gettime() > anim.meleechargeplayertimers[var_0];
    }
    else
    {
        if ( !isdefined( anim.meleechargetimers ) )
            return 1;

        if ( !isdefined( anim.meleechargetimers[var_0] ) )
            return 1;

        return gettime() > anim.meleechargetimers[var_0];
    }
}

setup_run_n_gun()
{
    self.maxrunngunangle = 180;
}

setupsoldierdefaults()
{
    self.a = spawnstruct();
    self.a.laseron = 0;
    self.primaryweapon = self.weapon;
    self.currentpose = "stand";
    self.a.movement = "stop";
    self.a.special = "none";
    self.a.gunhand = "none";
    self.dropweapon = 1;
    self.minexposedgrenadedist = 750;
    self.a.needstorechamber = 0;
    self.a.combatendtime = gettime();
    self.a.lastenemytime = gettime();
    self.a.suppressingenemy = 0;
    self.a.disablelongdeath = !self isbadguy();
    self.a.paintime = 0;
    self.a.lastshoottime = 0;
    self.a.lastgrenadethrowtime = 0;
    self.a.nextgrenadetrytime = 0;
    self.a.reacttobulletchance = 0.8;
    self._animactive = 0;
    self._lastanimtime = 0;
    self.baseaccuracy = 1;
    self.a.misstime = 0;
    self.a.nodeath = 0;
    self.a.misstime = 0;
    self.a.misstimedebounce = 0;
    self.a.disablepain = 0;
    self.accuracystationarymod = 1;
    self.battlechatter = spawnstruct();
    self.chatinitialized = 0;
    self.sightpostime = 0;
    self.sightposleft = 1;
    self.needrecalculategoodshootpos = 1;
    self.defaultturnthreshold = 55;
    setfacialstate( "asm" );
    self.currentweaponpose = "gun_down";
    self.lookandaimdownpathdist = 120;
    self.combattraverseenabled = 0;
    self.speedscalemult = 0.95 + randomfloat( 0.15 );

    if ( !isdefined( self.script_forcegrenade ) )
        self.script_forcegrenade = 0;

    self.lastenemysighttime = 0;
    self.combattime = 0;
    self.suppressed = 0;
    self.suppressedtime = 0;

    if ( self.team == "allies" )
        self.suppressionthreshold = 0.5;
    else
        self.suppressionthreshold = 0.0;

    if ( self.team == "allies" )
        self.randomgrenaderange = 0;
    else
        self.randomgrenaderange = 256;

    self.ammocheatinterval = 8000;
    self.ammocheattime = 0;
    setup_run_n_gun();
}

getspeedmatchanimrate( var_0, var_1, var_2 )
{
    var_3 = length( self.velocity );

    if ( var_3 < 1 )
        return 1;

    var_4 = length( getmovedelta( var_0, var_1, var_2 ) );

    if ( var_4 < 1 )
        return 1;

    var_5 = getanimlength( var_0 ) * ( var_2 - var_1 );
    var_6 = var_4 / var_5;
    return var_3 / var_6;
}

isentasoldier()
{
    return self.unittype == "soldier" || self.unittype == "juggernaut";
}

isentnotabomber()
{
    return self.asmname != "suicidebomber" && self.asmname != "suicidebomber_cp";
}

demeanorhasblendspace()
{
    var_0 = scripts\asm\asm::asm_getdemeanor();
    return var_0 == "combat";
}

isfixednodeinbadplaceandshouldcrouch()
{
    if ( self.fixednode && !isdefined( self.node ) && isdefined( self.color_node ) && self isnodeinbadplace( self.color_node ) && self.color_node doesnodeallowstance( "crouch" ) )
        return 1;

    return 0;
}

gethighestallowedstance()
{
    var_0 = undefined;
    var_1 = 1;
    var_2 = 1;
    var_3 = 1;

    if ( isdefined( self.node ) && isatcovernode() )
    {
        var_1 = self.node doesnodeallowstance( "stand" );
        var_2 = self.node doesnodeallowstance( "crouch" );
        var_3 = self.node doesnodeallowstance( "prone" );
    }
    else if ( !scripts\asm\asm_bb::bb_moverequested() && istrue( self._blackboard.shootparams_valid ) && isdefined( self._blackboard.shootparams_pos ) )
    {
        var_4 = self isstanceallowed( "crouch" );

        if ( var_4 && isfixednodeinbadplaceandshouldcrouch() )
            return "crouch";

        var_5 = distancesquared( self.origin, self._blackboard.shootparams_pos );

        if ( var_5 > 262144 && var_4 && !scripts\engine\utility::actor_is3d() && !scripts\anim\utility_common.gsc::isusingsidearm() )
        {
            var_4 = 1;

            if ( isdefined( self.node ) && distancesquared( self.origin, self.node.origin ) < 16 && !self.node doesnodeallowstance( "crouch" ) )
                var_4 = abs( angleclamp180( self.node.angles[1] - self.angles[1] ) ) > 90;

            if ( var_4 )
            {
                if ( sighttracepassed( self.origin + ( 0, 0, 32 ), self._blackboard.shootparams_pos, 0, undefined ) )
                    return "crouch";
            }
        }
    }

    for (;;)
    {
        if ( self isstanceallowed( "stand" ) && var_1 )
            return "stand";

        if ( self isstanceallowed( "crouch" ) && var_2 )
            return "crouch";

        if ( self isstanceallowed( "prone" ) && var_3 )
            return "prone";

        if ( !var_1 || !var_2 || !var_3 )
        {
            var_1 = 1;
            var_2 = 1;
            var_3 = 1;
            continue;
        }

        break;
    }

    return "crouch";
}

determinerequestedstance()
{
    var_0 = gethighestallowedstance();
    var_1 = scripts\asm\asm_bb::bb_getrequestedstance();
    var_2 = [];
    var_2["prone"] = 0;
    var_2["crouch"] = 1;
    var_2["stand"] = 2;
    var_3 = scripts\aitypes\bt_util::bt_getdemeanor();

    if ( isdefined( self.pathgoalpos ) && distance2dsquared( self.pathgoalpos, self.origin ) > 1 )
        var_1 = "stand";

    if ( self._blackboard.bgrenadereturnthrow )
        var_1 = "stand";

    if ( !isdefined( var_0 ) )
        var_0 = var_1;

    if ( var_3 == "casual" || var_3 == "casual_gun" )
        var_1 = "stand";
    else if ( var_0 == "prone" && self.unittype == "c6" )
        var_1 = "crouch";
    else if ( var_2[var_0] < var_2[var_1] )
        var_1 = var_0;
    else if ( var_1 == "prone" && var_0 != var_1 )
        var_1 = var_0;
    else if ( var_1 == "crouch" && var_2[var_0] > var_2["crouch"] )
    {
        if ( scripts\asm\asm_bb::bb_isinbadcrouchspot() )
            var_1 = "stand";
    }

    return var_1;
}

mapangleindextonumpad( var_0 )
{
    var_1 = [ 2, 3, 6, 9, 8, 7, 4, 1, 2 ];
    return var_1[var_0];
}

toggle_poiauto( var_0, var_1, var_2, var_3, var_4 )
{
    if ( var_0 )
    {
        if ( !isdefined( self.poiauto ) )
        {
            poiauto_init( var_1, var_2, var_3, var_4 );
            thread poiauto_think();
            scripts\common\ai::set_gunpose( "disable" );
        }
    }
    else
    {
        self notify( "poiauto_disable" );
        self.poiauto = undefined;
        scripts\common\ai::set_gunpose( "automatic" );
        self stoplookat();
    }
}

set_poiauto_constraints( var_0, var_1, var_2, var_3 )
{
    if ( !isdefined( self.poiauto.og_yawmax ) )
        self.poiauto.og_yawmax = self.poiauto.yawmax;

    if ( !isdefined( self.poiauto.og_yawmin ) )
        self.poiauto.og_yawmin = self.poiauto.yawmin;

    if ( !isdefined( self.poiauto.og_pitchmin ) )
        self.poiauto.og_pitchmin = self.poiauto.pitchmin;

    if ( !isdefined( self.poiauto.og_pitchmax ) )
        self.poiauto.og_pitchmax = self.poiauto.pitchmax;

    self.poiauto.yawmax = var_0;
    self.poiauto.yawmin = var_1;
    self.poiauto.pitchmin = var_2;
    self.poiauto.pitchmax = var_3;
}

reset_poiauto_constraints()
{
    self.poiauto.yawmax = self.poiauto.og_yawmax;
    self.poiauto.yawmin = self.poiauto.og_yawmin;
    self.poiauto.pitchmin = self.poiauto.og_pitchmin;
    self.poiauto.pitchmax = self.poiauto.og_pitchmax;
}

toggle_poi( var_0, var_1 )
{
    self.currentpoi = undefined;
    self.nextpoi = undefined;
    self.doingpoi = var_0;
    self.disablelookdownpath = var_0;
    self.cqb_point_of_interest = undefined;

    if ( !var_0 )
    {
        level.poi_activeai = scripts\engine\utility::array_remove( level.poi_activeai, self );
        self.turnrate = scripts\engine\utility::ter_op( isdefined( self.poi_oldturnrate ), self.poi_oldturnrate, self.turnrate );
        self.gunadditiveoverride = undefined;
        self.disablelookdownpath = undefined;
        self._blackboard.forcestrafe = 0;
        self.gunposeoverride = undefined;
        self stoplookat();
    }
    else
    {
        var_2 = self aigetdesiredspeed();
        var_3 = getbasearchetype();
        var_4 = getnearestspeedthresholdname( var_3, "fast" );
        self aisetdesiredspeed( min( var_2, var_4 ) );

        if ( !isdefined( level.poi_activeai ) )
            level.poi_activeai = [];

        level.poi_activeai[level.poi_activeai.size] = self;

        if ( isdefined( level.fnfindcqbpointsofinterest ) && !istrue( level.alreadyfindingpoi ) )
        {
            level thread [[ level.fnfindcqbpointsofinterest ]]();
            level.alreadyfindingpoi = 1;
        }

        self.poi_oldturnrate = self.turnrate;
        self.turnrate = 0.25;
        self.leftaimlimit = 90;
        self.rightaimlimit = -90;
        self.poi_firstpoint = var_1;
        self.gunposeoverride = "disable";
    }
}

shouldinitiallyattackfromexposed( var_0 )
{
    if ( !isdefined( var_0 ) )
        var_0 = self.node;

    if ( isdefined( self._blackboard.shufflenode ) )
        return 0;

    if ( isdefined( scripts\asm\asm_bb::bb_getcovernode() ) )
        return 0;

    if ( isdefined( var_0 ) && ( var_0.type == "Conceal Stand" || var_0.type == "Conceal Crouch" ) )
    {
        var_1 = vectornormalize( var_0.origin - self.origin );
        var_2 = generateaxisanglesfromforwardvector( var_1, self.angles );
        var_3 = var_0.angles[1];
        var_4 = angleclamp180( var_3 - var_2[1] );
        var_5 = getangleindex( var_4, 22.5 );

        if ( var_5 == 0 || var_5 == 1 || var_5 == 7 || var_5 == 8 )
        {
            self._blackboard.shouldinitiallyattackfromexposed = 1;
            return 1;
        }
    }

    if ( isdefined( self.enemy ) && distancesquared( self.origin, self.enemy.origin ) < 302500 && self.bulletsinclip > 0 )
    {
        if ( !isplayer( self.enemy ) && !isai( self.enemy ) )
            return 0;

        if ( isdefined( self._blackboard.shouldinitiallyattackfromexposedtime ) && self._blackboard.shouldinitiallyattackfromexposedtime > gettime() )
            return self._blackboard.shouldinitiallyattackfromexposed;

        if ( isai( self.enemy ) && !isbot( self.enemy ) )
            var_6 = self.enemy getapproxeyepos();
        else
            var_6 = self.enemy geteye();

        var_7 = undefined;

        if ( isdefined( var_0 ) )
        {
            var_7 = var_0.origin + ( 0, 0, 56 );
            self._blackboard.shouldinitiallyattackfromexposed = sighttracepassed( var_7, var_6, 0, undefined );
        }
        else if ( istrue( self.brjugg_watchstartnotify ) )
        {
            var_8 = 0;

            if ( isdefined( self.pathgoalpos ) )
            {
                if ( issentient( self.enemy ) )
                    var_8 = enablegroundwarspawnlogic( self.pathgoalpos, self.enemy );
                else
                    var_8 = enablegroundwarspawnlogic( self.pathgoalpos, self.enemy.origin );
            }
            else if ( issentient( self.enemy ) )
                var_8 = self hastacvis( self.enemy );
            else
                var_8 = enablegroundwarspawnlogic( self.origin, self.enemy.origin );

            self._blackboard.shouldinitiallyattackfromexposed = var_8;
        }
        else
            return 0;

        self._blackboard.shouldinitiallyattackfromexposedtime = gettime() + 1000;
        return self._blackboard.shouldinitiallyattackfromexposed;
    }

    self._blackboard.shouldinitiallyattackfromexposed = 0;
    return 0;
}

cover_canattackfromexposed( var_0, var_1 )
{
    if ( !isplayer( self.enemy ) && !isai( self.enemy ) )
        return 1;

    if ( cover_canattackfromexposedcached() )
        return cover_canattackfromexposedgetcache();

    if ( !isdefined( var_1 ) )
        var_1 = self.covernode;

    if ( !isdefined( var_1 ) )
        var_1 = self.node;

    if ( !isdefined( var_1 ) )
        return 0;

    var_2 = gethighestallowedstance();
    var_3 = 56;

    if ( var_2 != "stand" )
        var_3 = 32;

    var_4 = var_1.origin + ( 0, 0, var_3 );

    if ( !isdefined( var_0 ) )
    {
        if ( isai( self.enemy ) && !isbot( self.enemy ) )
            var_0 = self.enemy getapproxeyepos();
        else
            var_0 = self.enemy geteye();
    }

    var_5 = 1000;
    self._blackboard.canattackfromexposed = sighttracepassed( var_4, var_0, 0, undefined );
    self._blackboard.canattackfromexposedtime = gettime() + var_5;
    return self._blackboard.canattackfromexposed;
}

cover_canattackfromexposedcached()
{
    return isdefined( self._blackboard.canattackfromexposedtime ) && self._blackboard.canattackfromexposedtime > gettime();
}

cover_canattackfromexposedgetcache()
{
    return self._blackboard.canattackfromexposed;
}

iscoverinvalidagainstenemy( var_0 )
{
    if ( !isdefined( var_0 ) )
        var_1 = iscovervalid();
    else
        var_1 = iscovernodevalid( var_0 );

    return !var_1 && !fixednodeshouldsticktocover( var_0 ) && cover_canattackfromexposed( undefined, var_0 );
}

fixednodeshouldsticktocover( var_0 )
{
    if ( !isdefined( var_0 ) )
        var_0 = self.node;

    if ( !self.fixednode )
        return 0;

    if ( isdefined( self.enemy.node ) && !nodesvisible( var_0, self.enemy.node ) )
        return 1;

    if ( !self seerecently( self.enemy, 8 ) )
        return 1;

    if ( scripts\engine\utility::actor_is3d() )
        return 1;

    if ( distancesquared( var_0.origin, self.enemy.origin ) > 4096.0 )
    {
        if ( !isdefined( self._blackboard.fixedshouldsticktocovertime ) || self._blackboard.fixedshouldsticktocovertime < gettime() )
        {
            var_1 = ( 0, 0, 50 );
            var_2 = vectornormalize( self.enemy.origin - var_0.origin );
            var_3 = var_0.origin + var_1;
            var_4 = var_3 + var_2 * 64.0;
            self._blackboard.fixedshouldsticktocovertime = gettime() + 1050;
            self._blackboard.fixedshouldsticktocovercached = !scripts\engine\trace::_bullet_trace_passed( var_3, var_4, 0, self );
        }

        return self._blackboard.fixedshouldsticktocovercached;
    }

    return 0;
}

iscovernodevalid( var_0 )
{
    return istrue( self.ignorecovervalidity ) || self iscovervalidagainstenemy( var_0 );
}

iscovervalid()
{
    return istrue( self.ignorecovervalidity ) || self iscovervalidagainstenemy();
}

addoverridearchetypepriority( var_0 )
{
    level.archetypeoverridepriorities[var_0] = level.archetypeoverridepriorities.size;
}

setupoverridearchetypeprioritytable()
{
    if ( isdefined( level.archetypeoverridepriorities ) )
        return;

    level.archetypeoverridepriorities = [];
    addoverridearchetypepriority( "base" );
    addoverridearchetypepriority( "default" );
    addoverridearchetypepriority( "weapon" );
    addoverridearchetypepriority( "casual_killer" );
    addoverridearchetypepriority( "vehicle" );
    addoverridearchetypepriority( "animscript" );
}

setoverridearchetype( var_0, var_1, var_2 )
{
    setupoverridearchetypeprioritytable();
    var_3 = level.archetypeoverridepriorities[var_0];

    if ( !isdefined( self.archetypeoverrides ) )
        setbasearchetype( self.asm.archetype );

    clearoverridearchetype( var_0, 1 );
    var_4 = spawnstruct();
    var_4.archetypepriority = var_3;
    var_4.archetype = var_1;
    self.archetypeoverrides = scripts\engine\utility::array_add( self.archetypeoverrides, var_4 );
    pickoverridearchetype( var_2 );
}

clearoverridearchetype( var_0, var_1, var_2 )
{
    if ( self.archetypeoverrides.size == 0 )
        return;

    var_3 = level.archetypeoverridepriorities[var_0];
    var_4 = [];

    foreach ( var_6 in self.archetypeoverrides )
    {
        if ( var_6.archetypepriority != var_3 )
            var_4[var_4.size] = var_6;
    }

    self.archetypeoverrides = var_4;

    if ( !istrue( var_1 ) )
        pickoverridearchetype( var_2 );
}

pickoverridearchetype( var_0 )
{
    self.changearchetype = undefined;
    var_1 = undefined;

    foreach ( var_3 in self.archetypeoverrides )
    {
        if ( !isdefined( var_1 ) || var_3.archetypepriority > var_1.archetypepriority )
            var_1 = var_3;
    }

    if ( self.asm.archetype == var_1.archetype )
        return;

    if ( istrue( var_0 ) )
    {
        self.animationarchetype = var_1.archetype;
        self.asm.archetype = var_1.archetype;
        self setanimset( var_1.archetype );
    }
    else
        self.changearchetype = var_1.archetype;
}

findoverridearchetype( var_0 )
{
    var_1 = level.archetypeoverridepriorities[var_0];

    foreach ( var_3 in self.archetypeoverrides )
    {
        if ( var_3.archetypepriority == var_1 )
            return var_3.archetype;
    }

    return undefined;
}

getbasearchetype()
{
    if ( !isdefined( self.archetypeoverrides ) )
        setbasearchetype( self.asm.archetype );

    return findoverridearchetype( "base" );
}

setbasearchetype( var_0 )
{
    if ( !isdefined( self.archetypeoverrides ) )
    {
        self.archetypeoverrides = [];
        setoverridearchetype( "default", self.asm.archetype );
    }

    setoverridearchetype( "base", var_0 );
    self.basearchetype = var_0;
}

poiauto_init( var_0, var_1, var_2, var_3 )
{
    if ( !isdefined( var_0 ) )
        var_0 = 15;

    if ( !isdefined( var_1 ) )
        var_1 = 35;

    if ( !isdefined( var_2 ) )
        var_2 = -20;

    if ( !isdefined( var_3 ) )
        var_3 = 0;

    self.poiauto = spawnstruct();
    self.poiauto.yawmax = var_1;
    self.poiauto.yawmin = var_0;
    self.poiauto.pitchmin = var_2;
    self.poiauto.pitchmax = var_3;
}

poiauto_think()
{
    self endon( "poiauto_disable" );
    self endon( "death" );
    var_0 = 500;
    var_1 = 0;
    var_2 = 0;
    var_3 = gettime() + 30000;

    if ( !isdefined( self.poiauto ) )
        poiauto_init();

    for (;;)
    {
        var_4 = 0;

        if ( var_3 <= gettime() )
        {
            self.poiauto_angles = ( 0, 0, 0 );

            if ( var_3 == var_1 )
                var_4 = 1;
        }

        if ( var_1 <= gettime() )
        {
            var_3 = gettime() + int( randomfloatrange( 0.8, 1.8 ) * 1000 );
            var_2 = gettime();
            poiauto_setnewaimangle( var_4 );
            var_5 = var_0 - gettime();
            var_6 = var_3 - gettime();

            if ( abs( var_6 - var_5 ) >= 550 && scripts\engine\utility::cointoss() )
                var_1 = var_3;
            else if ( var_5 > 3000 )
                var_1 = gettime() + randomintrange( 2000, 3000 );
            else
                var_1 = gettime() + var_5 + 550 + randomintrange( 1000, 2000 );
        }

        waitframe();
    }
}

poiauto_relativeangletopos( var_0 )
{
    var_1 = anglestoforward( var_0 );
    var_2 = rotatevector( var_1, self.angles );
    var_3 = self getapproxeyepos();
    var_4 = var_3 + var_2 * 128.0;
    return var_4;
}

poiauto_glancerandom()
{
    var_0 = randomfloatrange( -45, 45 );
    var_1 = randomfloatrange( -20, 20 );
    var_2 = poiauto_relativeangletopos( ( var_1, var_0, 0 ) );
    self.poiauto.glancing = 1;
    thread poiauto_glanceend();
    self glanceatpos( var_2 );
}

poiauto_glanceend()
{
    self notify( "poiauto_glanceend" );
    self endon( "poiauto_glanceend" );
    wait 0.55;
    self.poiauto.glancing = 0;
}

poiauto_isglancing()
{
    return istrue( self.poiauto.glancing );
}

poiauto_setnewaimangle( var_0 )
{
    if ( var_0 )
    {
        var_1 = randomfloatrange( self.poiauto_angles[1] + 5, self.poiauto_angles[1] + 10 );
        var_2 = randomfloatrange( 5, 10 );

        if ( scripts\engine\utility::cointoss() )
            var_2 = var_2 * -1;

        var_2 = self.poiauto_angles[0] + var_2;
    }
    else
    {
        var_3 = self.poiauto;
        var_1 = randomfloatrange( var_3.yawmin, var_3.yawmax );
        var_2 = randomfloatrange( var_3.pitchmin, var_3.pitchmax );
    }

    if ( scripts\engine\utility::cointoss() )
        var_1 = var_1 * -1;

    self.poiauto_nextangles = ( var_2, var_1, 0 );
    self.poiauto_nextaimtime = randomintrange( 100, 300 ) + gettime();
}

preventrecentanimindex( var_0, var_1, var_2 )
{
    var_3 = self.asm.archetype;

    if ( isdefined( self.animationarchetype ) )
        var_3 = self.animationarchetype;

    if ( !isdefined( anim.recentindices ) )
        anim.recentindices = [];

    var_4 = gettime();
    var_5 = 1000;
    var_6 = 2;
    var_7 = 0;
    var_8 = 1;
    var_9 = var_3 + var_0;

    if ( isdefined( anim.recentindices[var_9] ) )
    {
        var_10 = anim.recentindices[var_9][var_2];

        if ( var_4 - var_10[var_7] <= var_5 && var_10[var_8] >= var_6 )
        {
            var_11 = scripts\asm\asm::asm_getallanimindicesforalias( var_0, var_1 );
            var_12 = var_11[0];
            var_13 = var_11[var_11.size - 1];

            for ( var_14 = 1; var_14 < var_11.size; var_14++ )
            {
                var_15 = scripts\engine\math::wrap( var_12, var_13 - 1, var_2 + var_14 );

                if ( anim.recentindices[var_9][var_15][var_8] < var_6 )
                {
                    var_2 = var_15;
                    var_10 = anim.recentindices[var_9][var_2];
                    break;
                }
            }
        }

        if ( var_4 - var_10[var_7] > var_5 )
        {
            var_10[var_7] = var_4;
            var_10[var_8] = 1;
        }
        else
            var_10[var_8] = var_10[var_8] + 1;

        anim.recentindices[var_9][var_2] = var_10;
    }
    else
    {
        anim.recentindices[var_9] = [];
        var_16 = scripts\asm\asm::asm_getallanimsforstate( var_0 );

        for ( var_14 = 0; var_14 < var_16.size; var_14++ )
            anim.recentindices[var_9][var_14] = [ 0, 0 ];

        anim.recentindices[var_9][var_2][var_7] = var_4;
        anim.recentindices[var_9][var_2][var_8] = 1;
    }

    return var_2;
}

intro_addplayer( var_0, var_1, var_2, var_3 )
{
    if ( isdefined( self.intro_heli_animate_player ) )
        return self [[ self.intro_heli_animate_player ]]( var_0, var_1, var_2, var_3 );

    return 0;
}
