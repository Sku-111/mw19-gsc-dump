// IW8 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

init_battlechatter()
{
    level._battlechatter = spawnstruct();
    level._battlechatter.fnevaluatemoveevent = ::evaluatemoveevent;
    level._battlechatter.fnevaluatereloadevent = ::evaluatereloadevent;
    level._battlechatter.fnaddthreatevent = ::addthreatevent;
    level._battlechatter.fnevaluateattackevent = ::evaluateattackevent;
    level._battlechatter.fnplaybattlechatter = ::playbattlechatter;
    level._battlechatter.players = [];
    level._battlechatter.ai = [];
    level._battlechatter.nextsaytimes = [];
    level.heightforhighcallout = 96.0;
    level.mindistancecallout = 10.0;
    level.maxdistancecallout = 45.0;
    anim.threatcallouts = [];
    anim.eventchance = [];
    anim.eventtypeminwait = [];
    anim.threatcallouts["exposed"] = 25;
    anim.threatcallouts["ai_distance"] = 25;
    anim.threatcallouts["ai_obvious"] = 25;
    anim.threatcallouts["ai_contact_clock"] = 20;
    anim.threatcallouts["ai_casual_clock"] = 20;
    anim.threatcallouts["ai_target_clock"] = 20;
    anim.threatcallouts["ai_target_clock_high"] = 25;
    anim.threatcallouts["ai_cardinal"] = 10;
    anim.threatcallouts["concat_location"] = 90;
    anim.threatcallouts["player_location"] = 90;
    anim.threatcallouts["ai_location"] = 100;
    anim.threatcallouts["generic_location"] = 95;
    anim.eventchance["moveEvent"]["coverme"] = 70;
    anim.eventtypeminwait["moveEvent"] = [];
    anim.eventtypeminwait["threat"] = [];
    anim.eventtypeminwait["inform"] = [];
    anim.eventtypeminwait["order"] = [];
    anim.eventtypeminwait["moveEvent"]["coverme"] = 10000;
    anim.eventtypeminwait["inform"]["reloading"] = 20000;
    anim.eventtypeminwait["inform"]["attack"] = 9000;
    anim.eventtypeminwait["inform"]["incoming"] = 25000;
    anim.eventtypeminwait["threat"]["acquired"] = 7000;
    anim.eventtypeminwait["threat"]["sighted"] = 7000;
    anim.eventtypeminwait["threat"]["infantry"] = 7000;
    anim.eventtypeminwait["order"]["action"] = 9000;
    anim.eventtypeminwait["order"]["move"] = 3000;
    anim._id_13B42 = 120000;
    bcs_setup_countryids();
    level.dialog_system = 1;
}

bcs_setup_countryids()
{
    if ( !isdefined( anim.usedids ) )
    {
        anim.usedids = [];
        anim.flavorburstvoices = [];
        anim.countryids = [];
        bcs_setup_voice( "unitednations", "UN", 6, 1 );
        bcs_setup_voice( "unitednationshelmet", "UN", 6, 1 );
        bcs_setup_voice( "unitednationsfemale", "UN", 3, 1 );
        bcs_setup_voice( "setdef", "SD", 5 );
        bcs_setup_voice( "unitedstates", "USM", 3, 1 );
        bcs_setup_voice( "unitedstatesfemale", "USMF", 1, 1 );
        bcs_setup_voice( "sas", "USM", 3, 1 );
        bcs_setup_voice( "sasfemale", "USMF", 1, 1 );
        bcs_setup_voice( "fsa", "FSA", 3, 1 );
        bcs_setup_voice( "fsafemale", "FSAF", 1, 1 );

        switch ( getdvar( "bcs_forceEnglish" ) )
        {
            case "all":
            case "axis":
                bcs_setup_voice( "alqatala", "USM", 3 );
                bcs_setup_voice( "alqatalafemale", "USMF", 1 );
                bcs_setup_voice( "russian", "USM", 3 );
                break;
            default:
                bcs_setup_voice( "alqatala", "AQ", 3 );
                bcs_setup_voice( "alqatalafemale", "AQF", 1 );
                bcs_setup_voice( "russian", "RU", 3 );
                break;
        }
    }
}

bcs_setup_voice( var_0, var_1, var_2, var_3 )
{
    if ( !isdefined( var_3 ) )
        var_3 = 0;

    anim.usedids[var_0] = [];

    for ( var_4 = 0; var_4 < var_2; var_4++ )
    {
        anim.usedids[var_0][var_4] = spawnstruct();
        anim.usedids[var_0][var_4].count = 0;
        anim.usedids[var_0][var_4].npcid = "" + ( var_4 + 1 );
    }

    anim.countryids[var_0] = var_1;
    anim.flavorburstvoices[var_0] = var_3;
}

battlechatterenabled()
{
    return istrue( level.dialog_system );
}

autoassignquest( var_0 )
{
    var_0.battlechatterallowed = 1;
    level._battlechatter.ai[level._battlechatter.ai.size] = var_0;
    var_0.battlechatter = spawnstruct();
    var_0.battlechatter.countryid = anim.countryids[var_0.voice];
    var_0 setnpcid();
    thread _id_12BE5( var_0 );
    var_0 thread _id_11E60();
}

_id_12BC1( var_0 )
{
    level._battlechatter.ai = scripts\engine\utility::array_remove( level._battlechatter.ai, var_0 );
    var_0 notify( "removed from battleChatter" );
}

_id_12BE5( var_0 )
{
    var_0 waittill( "death" );
    _id_12BC1( var_0 );
}

setnpcid()
{
    var_0 = anim.usedids[self.voice];
    var_1 = var_0.size;
    var_2 = randomintrange( 0, var_1 );
    var_3 = var_2;

    for ( var_4 = 0; var_4 <= var_1; var_4++ )
    {
        if ( var_0[( var_2 + var_4 ) % var_1].count < var_0[var_3].count )
            var_3 = ( var_2 + var_4 ) % var_1;
    }

    thread npcidtracker( var_3 );
    self.battlechatter.npcid = var_0[var_3].npcid;
}

npcidtracker( var_0 )
{
    var_1 = self.voice;
    anim.usedids[var_1][var_0].count++;
    scripts\engine\utility::waittill_either( "death", "removed from battleChatter" );

    if ( !battlechatterenabled() )
        return;

    anim.usedids[var_1][var_0].count--;
}

_id_11E60()
{
    self endon( "death" );
    self endon( "removed from battleChatter" );

    for (;;)
    {
        self waittill( "enemy" );

        if ( isdefined( self.enemy ) && isalive( self.enemy ) )
            scripts\anim\battlechatter_wrapper.gsc::addthreatevent( "infantry", self.enemy );
    }
}

evaluatemoveevent( var_0 )
{
    self endon( "death" );
    self endon( "removed from battleChatter" );

    if ( !battlechatterenabled() || !isdefined( self.goalpos ) || !istrue( self.battlechatterallowed ) )
        return;

    if ( distancesquared( self.origin, self.goalpos ) < 22500 )
        return;

    if ( randomint( 100 ) < anim.eventchance["moveEvent"]["coverme"] )
        playorderevent( "action", "coverme", anim.player );
    else
        playorderevent( "move", "movecombat", anim.player );
}

addthreatevent( var_0, var_1, var_2 )
{
    if ( isplayer( var_1 ) || isdefined( var_1.aitype ) )
    {
        if ( isdefined( self._blackboard ) )
            self._blackboard.battlechatter_target = var_1;

        var_3 = threatinfantry( var_1, undefined );
    }
}

getthreatinfantrycallouttype( var_0 )
{
    var_1 = getdirectionfacingclock( self.angles, self.origin, var_0.origin );
    var_2 = var_1;
    var_3 = self;
    var_4 = getdistancemeters( var_3.origin, var_0.origin );
    self.possiblethreatcallouts = [];

    if ( isexposed( var_0 ) )
        addpossiblethreatcallout( "exposed" );

    var_5 = 0;

    if ( var_0.origin[2] - var_3.origin[2] >= level.heightforhighcallout )
    {
        if ( addpossiblethreatcallout( "ai_target_clock_high" ) )
            var_5 = 1;
    }

    addpossiblethreatcallout( "ai_casual_clock" );

    if ( !var_5 )
    {
        if ( var_2 == "12" )
        {
            addpossiblethreatcallout( "ai_distance" );

            if ( var_4 > level.mindistancecallout && var_4 < level.maxdistancecallout )
                addpossiblethreatcallout( "ai_obvious" );
        }

        addpossiblethreatcallout( "ai_contact_clock" );
        addpossiblethreatcallout( "ai_target_clock" );
        addpossiblethreatcallout( "ai_cardinal" );
    }

    if ( !self.possiblethreatcallouts.size )
        return undefined;

    var_6 = getweightedchanceroll( self.possiblethreatcallouts, anim.threatcallouts );
    var_7 = spawnstruct();
    var_7.type = var_6;
    return var_7;
}

addpossiblethreatcallout( var_0 )
{
    var_1 = 0;

    if ( !callouttypewillrepeat( var_0 ) )
        var_1 = 1;

    if ( !var_1 )
        return var_1;

    self.possiblethreatcallouts[self.possiblethreatcallouts.size] = var_0;
    return var_1;
}

setlastcallouttype( var_0 )
{
    level._battlechatter.watch_for_player_going_belowmap_or_oob = var_0;
    level._battlechatter.watch_for_player_in_gulag = gettime();
}

callouttypewillrepeat( var_0 )
{
    if ( !isdefined( level._battlechatter.watch_for_player_going_belowmap_or_oob ) )
        return 0;

    if ( !isdefined( level._battlechatter.watch_for_player_in_gulag ) )
        return 0;

    var_1 = level._battlechatter.watch_for_player_going_belowmap_or_oob;
    var_2 = level._battlechatter.watch_for_player_in_gulag;
    var_3 = anim._id_13B42;

    if ( var_0 == var_1 && gettime() - var_2 < var_3 )
        return 1;

    return 0;
}

isexposed( var_0 )
{
    if ( distancesquared( self.origin, var_0.origin ) > 2250000 )
        return 0;

    var_1 = var_0 bcgetclaimednode();

    if ( !isdefined( var_1 ) )
        return 1;

    if ( !var_0 isnodecoverorconceal() )
        return 0;

    return 1;
}

threatinfantryexposed( var_0 )
{
    var_1 = [];
    var_1 = scripts\engine\utility::array_add( var_1, "open" );
    var_1 = scripts\engine\utility::array_add( var_1, "breaking" );
    var_2 = var_1[randomint( var_1.size )];
    addthreatexposedalias( var_2 );
}

addthreatexposedalias( var_0 )
{
    if ( var_0 == "group" )
        var_0 = "movement_group";

    var_1 = self.owner getbattlechatteralias( "exposed_" + var_0 );
    self.soundaliases[self.soundaliases.size] = var_1;
    return 1;
}

addthreatobviousalias()
{
    var_0 = self.owner getbattlechatteralias( "order_suppress" );
    self.soundaliases[self.soundaliases.size] = var_0;
    return 1;
}

addthreatdistancealias( var_0 )
{
    var_1 = self.owner getbattlechatteralias( "contact_dist" ) + var_0;
    self.soundaliases[self.soundaliases.size] = var_1;
    return 1;
}

getdistancemeters( var_0, var_1 )
{
    var_2 = distance2d( var_0, var_1 );
    var_3 = 0.0254 * var_2;
    return var_3;
}

getdistancemetersnormalized( var_0, var_1 )
{
    var_2 = getdistancemeters( var_0, var_1 );

    if ( var_2 < 15.0 )
        return "10";
    else if ( var_2 < 25.0 )
        return "20";
    else if ( var_2 < 35.0 )
        return "30";
    else if ( var_2 < 45.0 )
        return "40";
    else if ( var_2 < 55.0 )
        return "50";
    else if ( var_2 < 65.0 )
        return "60";
    else if ( var_2 < 75.0 )
        return "70";
    else if ( var_2 < 85.0 )
        return "80";
    else if ( var_2 < 95.0 )
        return "90";
    else
        return "100";
}

getrelativeangles( var_0 )
{
    var_1 = var_0.angles;

    if ( !isplayer( var_0 ) )
    {
        var_2 = var_0 bcgetclaimednode();

        if ( isdefined( var_2 ) )
            var_1 = var_2.angles;
    }

    return var_1;
}

bcgetclaimednode()
{
    if ( isplayer( self ) )
        return self.node;
    else
        return scripts\anim\utility_common.gsc::getclaimednode();
}

isnodecoverorconceal()
{
    var_0 = self.node;

    if ( !isdefined( var_0 ) )
        return 0;

    if ( issubstr( var_0.type, "Cover" ) || issubstr( var_0.type, "Conceal" ) )
        return 1;

    return 0;
}

getdirectionfacingclock( var_0, var_1, var_2 )
{
    var_3 = anglestoforward( var_0 );
    var_4 = vectornormalize( var_3 );
    var_5 = vectortoangles( var_4 );
    var_6 = vectortoangles( var_2 - var_1 );
    var_7 = var_5[1] - var_6[1];
    var_7 = var_7 + 360;
    var_7 = int( var_7 ) % 360;

    if ( var_7 > 345 || var_7 < 15 )
        var_8 = "12";
    else if ( var_7 < 45 )
        var_8 = "1";
    else if ( var_7 < 75 )
        var_8 = "2";
    else if ( var_7 < 105 )
        var_8 = "3";
    else if ( var_7 < 135 )
        var_8 = "4";
    else if ( var_7 < 165 )
        var_8 = "5";
    else if ( var_7 < 195 )
        var_8 = "6";
    else if ( var_7 < 225 )
        var_8 = "7";
    else if ( var_7 < 255 )
        var_8 = "8";
    else if ( var_7 < 285 )
        var_8 = "9";
    else if ( var_7 < 315 )
        var_8 = "10";
    else
        var_8 = "11";

    return var_8;
}

getdegreeselevation( var_0, var_1 )
{
    var_2 = var_1[2] - var_0[2];
    var_3 = distance2d( var_0, var_1 );
    var_4 = atan( var_2 / var_3 );

    if ( var_4 < 15 || var_4 > 65 )
        return var_4;
    else if ( var_4 < 25 )
        return 20;
    else if ( var_4 < 35 )
        return 30;
    else if ( var_4 < 45 )
        return 40;
    else if ( var_4 < 55 )
        return 50;
    else if ( var_4 < 65 )
        return 60;
}

addthreatcalloutalias( var_0, var_1 )
{
    if ( !isdefined( var_1 ) )
        var_1 = "";

    var_2 = self.owner getbattlechatteralias( "threat_callout_" + var_0 ) + var_1;
    self.soundaliases[self.soundaliases.size] = var_2;
    return 1;
}

getdirectioncompass( var_0, var_1 )
{
    var_2 = vectortoangles( var_1 - var_0 );
    var_3 = var_2[1];
    var_4 = getnorthyaw();
    var_3 = var_3 - var_4;

    if ( var_3 < 0 )
        var_3 = var_3 + 360;
    else if ( var_3 > 360 )
        var_3 = var_3 - 360;

    if ( var_3 < 22.5 || var_3 > 337.5 )
        var_5 = "north";
    else if ( var_3 < 67.5 )
        var_5 = "northwest";
    else if ( var_3 < 112.5 )
        var_5 = "west";
    else if ( var_3 < 157.5 )
        var_5 = "southwest";
    else if ( var_3 < 202.5 )
        var_5 = "south";
    else if ( var_3 < 247.5 )
        var_5 = "southeast";
    else if ( var_3 < 292.5 )
        var_5 = "east";
    else if ( var_3 < 337.5 )
        var_5 = "northeast";
    else
        var_5 = "impossible";

    return var_5;
}

normalizecompassdirection( var_0 )
{
    var_1 = undefined;

    switch ( var_0 )
    {
        case "north":
            var_1 = "n";
            break;
        case "northwest":
            var_1 = "nw";
            break;
        case "west":
            var_1 = "w";
            break;
        case "southwest":
            var_1 = "sw";
            break;
        case "south":
            var_1 = "s";
            break;
        case "southeast":
            var_1 = "se";
            break;
        case "east":
            var_1 = "e";
            break;
        case "northeast":
            var_1 = "ne";
            break;
        case "impossible":
            var_1 = "impossible";
            break;
        default:
            return;
    }

    return var_1;
}

addthreatelevationalias( var_0 )
{
    var_1 = self.owner getbattlechatteralias( "contact_elev" ) + var_0;
    self.soundaliases[self.soundaliases.size] = var_1;
    return 1;
}

getweightedchanceroll( var_0, var_1 )
{
    var_2 = undefined;
    var_3 = -1;

    foreach ( var_5 in var_0 )
    {
        if ( var_1[var_5] <= 0 )
            continue;

        var_6 = randomint( var_1[var_5] );

        if ( isdefined( var_2 ) && var_1[var_2] >= 100 )
        {
            if ( var_1[var_5] < 100 )
                continue;
        }
        else
        {
            if ( var_1[var_5] >= 100 )
            {
                var_2 = var_5;
                var_3 = var_6;
                continue;
            }

            if ( var_6 > var_3 )
            {
                var_2 = var_5;
                var_3 = var_6;
            }
        }
    }

    return var_2;
}

threatinfantry( var_0, var_1 )
{
    self endon( "cancel speaking" );
    var_2 = createchatphrase();
    var_2.master = 1;
    var_2.threatent = var_0;
    var_3 = getthreatinfantrycallouttype( var_0 );

    if ( !isdefined( var_3 ) || isdefined( var_3 ) && !isdefined( var_3.type ) )
        return 0;

    var_4 = undefined;

    if ( isdefined( self.callout_type_override ) )
        var_4 = self.callout_type_override;
    else
        var_4 = var_3.type;

    switch ( var_4 )
    {
        case "exposed":
            var_5 = self;
            var_2 threatinfantryexposed( var_0 );
            break;
        case "ai_obvious":
            if ( isdefined( self._blackboard ) )
                self._blackboard.battlechatter_target = var_0;

            var_2 addthreatobviousalias();
            break;
        case "ai_distance":
            var_6 = self;
            var_7 = getdistancemetersnormalized( var_6.origin, var_0.origin );

            if ( isdefined( self._blackboard ) )
                self._blackboard.battlechatter_target = var_0;

            var_2 addthreatdistancealias( var_7 );
            break;
        case "ai_contact_clock":
            var_6 = self;
            var_8 = getrelativeangles( var_6 );
            var_9 = getdirectionfacingclock( var_8, var_6.origin, var_0.origin );
            var_2 addthreatcalloutalias( "contactclock", var_9 );

            if ( isdefined( self._blackboard ) )
                self._blackboard.battlechatter_target = var_0;

            break;
        case "ai_casual_clock":
            var_6 = self;
            var_8 = getrelativeangles( var_6 );
            var_9 = getdirectionfacingclock( var_8, var_6.origin, var_0.origin );
            var_2 addthreatcalloutalias( "contactclock", var_9 );

            if ( isdefined( self._blackboard ) )
                self._blackboard.battlechatter_target = var_0;

            break;
        case "ai_target_clock":
            var_6 = self;
            var_8 = getrelativeangles( var_6 );
            var_9 = getdirectionfacingclock( var_8, var_6.origin, var_0.origin );
            var_2 addthreatcalloutalias( "targetclock", var_9 );

            if ( isdefined( self._blackboard ) )
                self._blackboard.battlechatter_target = var_0;

            break;
        case "ai_target_clock_high":
            var_6 = self;
            var_8 = getrelativeangles( var_6 );
            var_9 = getdirectionfacingclock( var_8, var_6.origin, var_0.origin );
            var_10 = getdegreeselevation( var_6.origin, var_0.origin );

            if ( var_10 >= 20 && var_10 <= 60 )
            {
                var_2 addthreatcalloutalias( "targetclock_high", var_9 );
                var_2 addthreatelevationalias( var_10 );
            }
            else
                return 0;

            if ( isdefined( self._blackboard ) )
                self._blackboard.battlechatter_target = var_0;

            break;
        case "ai_cardinal":
            var_6 = self;
            var_11 = getdirectioncompass( var_6.origin, var_0.origin );
            var_12 = normalizecompassdirection( var_11 );

            if ( var_12 == "impossible" )
                return 0;

            var_2 addthreatcalloutalias( "cardinal", var_12 );

            if ( isdefined( self._blackboard ) )
                self._blackboard.battlechatter_target = var_0;

            break;
    }

    setlastcallouttype( var_3.type );
    var_5 = self;
    var_5.curevent = spawnstruct();
    var_5.curevent.eventaction = "threat";
    var_5.curevent.eventtype = "infantry";

    if ( isdefined( self._blackboard ) )
        self._blackboard.battlechatter_line_ok = 0;

    var_5 playphrase( var_2, self );

    if ( isdefined( self._blackboard ) )
    {
        self._blackboard.battlechatter_alias = undefined;
        self._blackboard.battlechatter_target = undefined;
    }

    return 1;
}

playbattlechatter( var_0 )
{

}

evaluatereloadevent()
{
    self endon( "death" );
    self endon( "removed from battleChatter" );

    if ( !battlechatterenabled() || !istrue( self.battlechatterallowed ) )
        return;

    thread playinformevent( "reloading", "generic" );
}

evaluateattackevent( var_0 )
{
    self endon( "death" );
    self endon( "removed from battleChatter" );

    if ( !battlechatterenabled() || !istrue( self.battlechatterallowed ) )
        return;

    var_1 = "frag";

    switch ( var_0 )
    {
        case "frag":
            var_1 = "frag";
            break;
        case "grenade":
            var_1 = "grenade";
            break;
        case "emp":
            var_1 = "shock";
            break;
        case "offhandshield":
            var_1 = "shield";
            break;
        case "guns":
            var_1 = "weapon_guns";
            break;
        case "missile":
            var_1 = "weapon_missile";
            break;
        case "flare":
            var_1 = "weapon_flare";
            break;
        case "molotov":
            var_1 = "molotov";
            break;
    }

    thread playinformevent( var_1, "attack" );
}

playinformevent( var_0, var_1 )
{
    var_2 = self;
    var_2 endon( "death" );
    var_2 endon( "removed from battleChatter" );
    var_3 = var_2 createchatphrase();
    var_3 addinformalias( var_0 );
    var_2.curevent = spawnstruct();
    var_2.curevent.eventaction = "inform";
    var_2.curevent.eventtype = var_1;
    var_2 playphrase( var_3, self );
}

playorderevent( var_0, var_1, var_2 )
{
    self endon( "death" );
    self endon( "removed from battleChatter" );
    var_3 = self;
    var_3.curevent = spawnstruct();
    var_3.curevent.eventaction = "order";
    var_3.curevent.eventtype = var_0;

    switch ( var_0 )
    {
        case "action":
            if ( isdefined( self._blackboard ) )
                self._blackboard.battlechatter_target = anim.player;

            _id_1213B( var_1, var_2 );
            break;
        case "move":
            _id_1213B( var_1, var_2 );
            break;
        case "displace":
            _id_1213B( var_1 );
            break;
    }

    if ( isdefined( self._blackboard ) )
    {
        self._blackboard.battlechatter_alias = undefined;
        self._blackboard.battlechatter_target = undefined;
    }

    self notify( "done speaking" );
}

_id_1213B( var_0, var_1 )
{
    var_2 = self;
    var_2 endon( "death" );
    var_2 endon( "removed from battleChatter" );
    var_3 = var_2 createchatphrase();
    var_3 addorderalias( "action", var_0 );
    var_2 playphrase( var_3, self );
}

createchatphrase()
{
    var_0 = spawnstruct();
    var_0.owner = self;
    var_0.soundevents = [];
    var_0.soundaliases = [];
    var_0.responsealiases = [];
    var_0.master = 0;
    return var_0;
}

addinformalias( var_0, var_1, var_2 )
{
    if ( !isdefined( var_1 ) )
        var_1 = "";
    else
        var_1 = "_" + var_1;

    if ( !isdefined( var_2 ) )
        var_2 = "";
    else
        var_2 = "_" + var_2;

    if ( !issubstr( var_1, "weapon" ) )
        var_0 = "inform_" + var_0;
    else
        var_0 = "";

    var_3 = self.owner getbattlechatteralias( var_0 + var_1 + var_2 );
    self.soundaliases[self.soundaliases.size] = var_3;
}

addorderalias( var_0, var_1 )
{
    if ( !isdefined( var_1 ) )
        var_1 = "";
    else
        var_1 = "_" + var_1;

    var_2 = self.owner getbattlechatteralias( "order" + var_1 );

    if ( !isdefined( var_2 ) )
        return 0;

    self.soundaliases[self.soundaliases.size] = var_2;
    return 1;
}

stop_speaking( var_0, var_1 )
{
    var_1 endon( "death" );
    self waittill( "death" );

    if ( isdefined( var_1 ) )
    {
        var_1 stopsounds();
        waitframe();

        if ( isdefined( var_1 ) )
        {
            var_1 notify( var_0 );
            var_1 delete();
        }
    }
}

isradioline( var_0, var_1 )
{
    if ( !isdefined( var_1 ) )
        var_1 = 0;

    if ( getsubstr( var_0, var_0.size - 2, var_0.size ) == "_r" )
        return 1;

    if ( issubstr( var_0, "_r_" ) )
        return 1;

    if ( issubstr( var_0, "_aql1r_" ) )
        return scripts\engine\utility::ter_op( var_1, "_aql1_", 1 );

    if ( issubstr( var_0, "_aql2r_" ) )
        return scripts\engine\utility::ter_op( var_1, "_aql2_", 1 );

    if ( issubstr( var_0, "_rul1r_" ) )
        return scripts\engine\utility::ter_op( var_1, "_rul1_", 1 );

    if ( issubstr( var_0, "_rul2r_" ) )
        return scripts\engine\utility::ter_op( var_1, "_rul2_", 1 );

    return 0;
}

dotypelimit( var_0, var_1 )
{
    if ( !isdefined( level._battlechatter.nextsaytimes[var_0] ) )
        level._battlechatter.nextsaytimes[var_0] = [];

    level._battlechatter.nextsaytimes[var_0][var_1] = gettime() + anim.eventtypeminwait[var_0][var_1];
}

cansay( var_0, var_1, var_2 )
{
    if ( !istrue( self.battlechatterallowed ) )
        return 0;

    if ( isdefined( level._battlechatter.nextsaytimes[var_0] ) && isdefined( level._battlechatter.nextsaytimes[var_0][var_1] ) && gettime() < level._battlechatter.nextsaytimes[var_0][var_1] )
        return 0;

    if ( issentient( self ) && self.ignoreall )
        return 0;

    if ( self isinscriptedstate() )
        return 0;

    return 1;
}

playphrase( var_0, var_1, var_2 )
{
    self endon( "death" );
    var_3 = 0;

    if ( isdefined( var_2 ) )
        return var_3;

    if ( isdefined( self.battlechatter.isspeaking ) && self.battlechatter.isspeaking )
        return var_3;

    if ( !var_1 cansay( var_1.curevent.eventaction, var_1.curevent.eventtype ) )
        return var_3;

    var_1 thread _id_13164( var_1.curevent.eventaction, var_1.curevent.eventtype );

    for ( var_4 = 0; var_4 < var_0.soundaliases.size; var_4++ )
    {
        if ( !self.battlechatterallowed )
            continue;

        if ( !isdefined( self._animactive ) || isdefined( self._animactive ) && self._animactive > 0 )
            continue;

        if ( !soundexists( var_0.soundaliases[var_4] ) )
            continue;

        var_5 = gettime();

        if ( isradioline( var_0.soundaliases[var_4] ) )
        {
            var_6 = spawn( "script_origin", self gettagorigin( "J_Hip_RI" ) );
            var_6 linkto( var_1 );
        }
        else
        {
            var_6 = spawn( "script_origin", self gettagorigin( "j_head" ) );
            var_6 linkto( var_1 );
        }

        thread stop_speaking( var_0.soundaliases[var_4], var_6 );
        self notify( var_0.soundaliases[var_4] + "_started" );
        var_3 = 1;
        var_6 playsound( var_0.soundaliases[var_4] );
        wait( lookupsoundlength( var_0.soundaliases[var_4] ) / 1000 );
        self notify( var_0.soundaliases[var_4] );
        var_6 delete();
    }

    self notify( "playPhrase_done" );
    return var_3;
}

_id_13164( var_0, var_1 )
{
    self.battlechatter.isspeaking = 1;
    scripts\engine\utility::_id_143A5( "playPhrase_done", "death" );

    if ( isdefined( self.battlechatter ) )
        self.battlechatter.isspeaking = 0;

    dotypelimit( var_0, var_1 );
}

getbcstate()
{
    return "combat";
}

bc_prefix( var_0 )
{
    if ( isdefined( var_0 ) && var_0 == "custom" )
        return tolower( "dx_vom_" + self.battlechatter.countryid + self.battlechatter.npcid + "_" );
    else if ( isdefined( var_0 ) && var_0 == "custom radio" )
        return tolower( "dx_vom" );
    else if ( getdvar( "bcs_otnCombat" ) != "off" )
    {
        if ( isarray( getdvar( "bcs_otnCombat" ) ) )
        {
            if ( isdefined( self.team ) && scripts\engine\utility::array_contains( getdvar( "bcs_otnCombat" ), self.team ) )
                return tolower( "dx_otn_" + self.battlechatter.countryid + self.battlechatter.npcid + "_" );
        }
        else if ( isdefined( self.team ) && self.team == getdvar( "bcs_otnCombat" ) )
            return tolower( "dx_otn_" + self.battlechatter.countryid + self.battlechatter.npcid + "_" );
        else
            return tolower( "dx_cbc_" + self.battlechatter.countryid + self.battlechatter.npcid + "_" );
    }
    else
        return tolower( "dx_cbc_" + self.battlechatter.countryid + self.battlechatter.npcid + "_" );
}

getbattlechatteralias( var_0 )
{
    var_1 = undefined;
    var_2 = bc_prefix();

    switch ( var_0 )
    {
        case "check_fire":
            var_1 = var_2 + "response_check_fire";
            break;
        case "concat_clock":
            var_1 = var_2 + getbcstate() + "_concat_clock_";
            break;
        case "concat_compass":
            var_1 = var_2 + getbcstate() + "_concat_compass_";
            break;
        case "concat_dist":
            var_1 = var_2 + getbcstate() + "_concat_dist_";
            break;
        case "concat_elev":
            var_1 = var_2 + getbcstate() + "_concat_elev_";
            break;
        case "concat_left":
            var_1 = var_2 + getbcstate() + "_concat_left";
            break;
        case "concat_right":
            var_1 = var_2 + getbcstate() + "_concat_right";
            break;
        case "concat_center":
            var_1 = var_2 + getbcstate() + "_concat_center";
            break;
        case "concat_target":
            var_1 = var_2 + getbcstate() + "_concat_target";
            break;
        case "contact_dist":
            var_1 = var_2 + "contact_dist_";
            break;
        case "contact_elev":
            var_1 = var_2 + "contact_elev_";
            break;
        case "contact_movement_group":
            var_1 = var_2 + "contact_movement_group";
            break;
        case "exposed_acquired":
            var_1 = var_2 + "exposed_acquired";
            break;
        case "exposed_breaking":
            var_1 = var_2 + "exposed_breaking";
            break;
        case "exposed_movement":
            var_1 = var_2 + "exposed_movement";
            break;
        case "exposed_movement_group":
            var_1 = var_2 + "exposed_movement_group";
            break;
        case "exposed_open":
            var_1 = var_2 + "exposed_open";
            break;
        case "inform_grenade":
        case "inform_frag":
            var_1 = var_2 + "inform_grenade";
            break;
        case "inform_incoming_grenade":
            var_1 = var_2 + "inform_incoming_grenade";
            break;
        case "inform_killfirm_soldier":
        case "inform_killfirm_juggernaut":
            var_1 = var_2 + "inform_killfirm_soldier";
            break;
        case "inform_molotov":
            var_1 = var_2 + "inform_molotov";
            break;
        case "inform_reloading":
            var_1 = var_2 + "inform_reloading";
            break;
        case "inform_taking_fire":
            var_1 = var_2 + "inform_taking_fire";
            break;
        case "location_response":
            var_1 = var_2 + getbcstate() + "_location_resp";
            break;
        case "order_coverme":
            var_1 = var_2 + "order_coverme";
            break;
        case "order_movecombat":
            var_1 = var_2 + "order_move_combat";
            break;
        case "order_movenoncombat":
            var_1 = var_2 + "order_move_noncombat";
            break;
        case "order_suppress":
            var_1 = var_2 + "order_suppress";
            break;
        case "reaction_casualty":
            var_1 = var_2 + "reaction_casualty";
            break;
        case "reaction_hostile_burst":
            var_1 = var_2 + "reaction_hostile_burst";
            break;
        case "response_ack_affirm":
            var_1 = var_2 + "response_ack_affirm";
            break;
        case "response_threat_affirm":
            var_1 = var_2 + "response_threat_affirm";
            break;
        case "response_threat_neg":
            var_1 = var_2 + "response_threat_neg";
            break;
        case "taunt":
            var_1 = var_2 + "taunt";
            break;
        case "threat_callout_acquired":
            var_1 = var_2 + "acquired_";
            break;
        case "threat_callout_cardinal":
            var_1 = var_2 + "cardinal_";
            break;
        case "threat_callout_contactclock":
            var_1 = var_2 + "contact_clock_";
            break;
        case "threat_callout_sighted":
            var_1 = var_2 + "sighted_";
            break;
        case "threat_callout_targetclock":
            var_1 = var_2 + "target_clock_";
            break;
        case "threat_callout_targetclock_high":
            var_1 = var_2 + "target_clock_high_";
            break;
        default:
    }

    return var_1;
}
