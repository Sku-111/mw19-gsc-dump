// IW8 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

asm_getfunction( var_0, var_1 )
{
    return anim.asmfuncs[var_0][var_1];
}

asm_getgenerichandler()
{
    return ::asm_generichandler;
}

asm_getparams( var_0, var_1 )
{
    return anim.asmparams[var_0][var_1];
}

asm_setupaim( var_0, var_1, var_2, var_3 )
{
    if ( isdefined( self.fnasm_setupaim ) )
        self [[ self.fnasm_setupaim ]]( var_0, var_1, var_2, var_3 );
}

asm_settransitionorientmode( var_0 )
{
    switch ( var_0 )
    {
        case "face node":
            var_1 = 1024.0;

            if ( scripts\engine\utility::actor_is3d() )
            {
                var_2 = self.angles;

                if ( isdefined( self.node ) && distancesquared( self.origin, self.node.origin ) < var_1 )
                    var_2 = scripts\asm\shared\utility::getnodeforwardangles( self.node );

                self orientmode( "face angle 3d", var_2 );
            }
            else
            {
                var_3 = self.angles[1];

                if ( isdefined( self.node ) && distancesquared( self.origin, self.node.origin ) < var_1 )
                    var_3 = scripts\asm\shared\utility::getnodeforwardyaw( self.node );

                self orientmode( "face angle", var_3 );
            }

            break;
        case "face current":
            self orientmode( "face angle 3d", self.angles );
            break;
        default:
            self orientmode( var_0 );
            break;
    }
}

asm_settransitionanimmode( var_0 )
{
    if ( isdefined( self.fnasm_setanimmode ) )
    {
        self [[ self.fnasm_setanimmode ]]( var_0 );
        return;
    }

    self animmode( var_0, 0 );
}

asm_generichandler( var_0, var_1, var_2, var_3, var_4 )
{
    switch ( var_0 )
    {
        case "orientmode":
            asm_settransitionorientmode( var_2 );
            break;
        case "setupaim":
            asm_setupaim( var_1, var_2, 0.2, undefined );
            break;
        case "setupgesture":
            if ( isdefined( self.fnasm_setupgesture ) )
                self [[ self.fnasm_setupgesture ]]( var_1, var_2 );

            break;
        case "archetype":
            self.asm.archetype = var_2;
            self.animationarchetype = var_2;
            break;
        case "note":
            var_5 = asm_getnotehandler( var_1, undefined );
            var_6 = [[ self.fnasm_handlenotetrack ]]( var_3, var_2, var_5, undefined );

            if ( !isdefined( var_6 ) )
                var_6 = asm_handlenewnotetracks( var_1, var_3, var_2 );

            if ( isdefined( var_6 ) && !asm_eventfired( var_1, "end" ) )
                asm_fireevent( var_1, "end" );

            break;
        case "waitfordooropen":
            thread scripts\asm\shared\utility::waitfordooropen( var_1, var_2, var_3 );
            break;
        case "move_threads":
            var_7 = var_2;
            thread scripts\asm\shared\utility::waitforcoverapproach( var_1, var_7 );
            thread scripts\asm\shared\utility::waitforsharpturn( var_1, var_7 );
            break;
        default:
            break;
    }
}

asm_setoverrideparams( var_0, var_1 )
{
    var_2 = 9999;
    anim.asmparams[var_0][var_2] = var_1;
    return var_2;
}

asm_globalinit()
{
    if ( isdefined( anim.asm ) )
        return;

    anim.asm = [];
}

asm_fireephemeralevent( var_0, var_1, var_2 )
{
    self asmfireephemeralevent( var_0, var_1, var_2 );
}

asm_init_blackboard()
{
    if ( isdefined( self._blackboard ) )
        return;

    self._blackboard = self getaiblackboard();
    self._blackboard.asm_events = [];
    self._blackboard.asm_ephemeral_events = [];
    self._blackboard.asm_ephemeral_event_watchlist = [];
    self._blackboard.bfire = 0;
}

asm_clearevents( var_0 )
{
    if ( isdefined( self._blackboard.asm_events[var_0] ) )
        self._blackboard.asm_events[var_0] = undefined;
}

asm_terminateandreplace( var_0, var_1 )
{
    self asmterminate();
    self clearaiblackboard();
    self._blackboard = undefined;
    self notify( "asm_terminated" );

    if ( !isdefined( var_1 ) )
        var_1 = self.asm.archetype;

    asm_init_blackboard();
    self [[ self.fnasm_init ]]( tolower( var_0 ), var_1 );
}

asm_getnotehandler( var_0, var_1 )
{
    var_2 = self asmgetnotehandler( var_0 );

    if ( var_2 != -1 )
        return anim.asmfuncs[var_0][var_2];

    return undefined;
}

asm_currentstatehasflag( var_0, var_1 )
{
    if ( isdefined( self.asm.forcetrackloop ) )
        return 1;

    return self asmcurrentstatehasflag( var_0, var_1 );
}

asm_fireevent_internal( var_0, var_1, var_2 )
{
    self asmfireevent( var_0, var_1, var_2 );
}

asm_fireevent( var_0, var_1, var_2 )
{
    asm_fireevent_internal( var_0, var_1, var_2 );

    if ( var_1 == "anim_will_finish" || var_1 == "finish" )
    {
        var_1 = "end";
        asm_fireevent_internal( var_0, var_1 );
    }
}

asm_addephemeraleventtowatchlist( var_0, var_1 )
{
    self._blackboard.asm_ephemeral_event_watchlist[var_0] = var_1;
}

asm_ephemeraleventfired( var_0, var_1, var_2 )
{
    var_3 = self asmephemeraleventfired( var_0, var_1 );

    if ( var_3 )
        return 1;

    if ( !isdefined( var_2 ) || var_2 )
        asm_addephemeraleventtowatchlist( var_0, var_1 );

    return 0;
}

asm_eventfiredrecently( var_0, var_1 )
{
    return self asmeventfiredwithin( var_0, var_1, 50 );
}

asm_geteventtime( var_0, var_1 )
{
    return self asmgeteventtime( var_0, var_1 );
}

asm_geteventdata( var_0, var_1 )
{
    return self asmgeteventdata( var_0, var_1 );
}

asm_getephemeraleventdata( var_0, var_1 )
{
    return self asmgetephemeraleventdata( var_0, var_1 );
}

asm_clearallephemeralevents()
{
    self asmclearephemeralevents();
}

asm_shouldpowerdown( var_0, var_1 )
{
    if ( !isdefined( self.bpowerdown ) || !self.bpowerdown )
        return 0;

    if ( isdefined( self.asm.bpowereddown ) && self.asm.bpowereddown )
        return 0;

    if ( !isalive( self ) )
        return 0;

    if ( scripts\asm\asm_bb::bb_isanimscripted() )
        return 0;

    if ( isdefined( self._blackboard.btraversing ) )
        return 0;

    if ( isdefined( self.melee ) )
        return 0;

    return 1;
}

asm_eventfired( var_0, var_1 )
{
    return self asmeventfired( var_0, var_1 );
}

asm_checktransitions( var_0, var_1, var_2 )
{
    self asmtick( 1 );
}

asm_setstate( var_0, var_1 )
{
    if ( self asmhasstate( self.asmname, var_0 ) )
        self asmsetstate( self.asmname, var_0, var_1 );
}

asm_tick()
{

}

highestallowedstance( var_0, var_1, var_2, var_3 )
{
    var_4 = scripts\asm\shared\utility::gethighestallowedstance();

    if ( isdefined( var_4 ) && var_4 != var_3 )
        return 0;

    return 1;
}

asm_getdemeanor()
{
    return self._blackboard.movetype;
}

asm_updatefrantic()
{
    if ( !isdefined( self.pathgoalpos ) || distancesquared( self.origin, self.pathgoalpos ) > 4096.0 )
        self.asm.frantic = scripts\asm\asm_bb::bb_isfrantic();
}

asm_isfrantic()
{
    return isdefined( self.asm ) && self.asm.frantic;
}

asm_iscrawlmelee()
{
    return isdefined( self.asm.crawlmelee );
}

asm_setcrawlmelee( var_0 )
{
    self.asm.crawlmelee = var_0;
}

asm_setdemeanoranimoverride( var_0, var_1, var_2 )
{
    self.asm.animoverrides[var_0][var_1] = var_2;
}

asm_cleardemeanoranimoverride( var_0, var_1 )
{
    if ( asm_hasdemeanoranimoverride( var_0, var_1 ) )
        self.asm.animoverrides[var_0][var_1] = undefined;
}

asm_hasdemeanoranimoverride( var_0, var_1 )
{
    return isdefined( self.asm.animoverrides[var_0] ) && isdefined( self.asm.animoverrides[var_0][var_1] );
}

asm_getdemeanoranimoverride( var_0, var_1 )
{
    return self.asm.animoverrides[var_0][var_1];
}

asm_getcurrentstate( var_0 )
{
    return self asmgetcurrentstate( var_0 );
}

asm_hasalias( var_0, var_1 )
{
    var_2 = undefined;

    if ( isdefined( self.animationarchetype ) )
        var_2 = self.animationarchetype;
    else
        var_2 = self.asm.archetype;

    var_3 = archetypegetrandomalias( var_2, var_0, var_1, asm_isfrantic() );
    return isdefined( var_3 );
}

asm_getanim( var_0, var_1, var_2 )
{
    if ( isarray( var_2 ) )
    {
        if ( var_2.size == 1 )
            return self asmgetanim( var_0, var_1, var_2[0] );
        else if ( var_2.size == 2 )
            return self asmgetanim( var_0, var_1, var_2[0], var_2[1] );
        else if ( var_2.size == 3 )
            return self asmgetanim( var_0, var_1, var_2[0], var_2[1], var_2[2] );
        else
        {

        }
    }
    else
        return self asmgetanim( var_0, var_1, var_2 );
}

asm_getrandomanim( var_0, var_1 )
{
    var_2 = asm_getrandomalias( var_1 );
    return asm_lookupanimfromalias( var_1, var_2 );
}

asm_getrandomalias( var_0 )
{
    var_1 = archetypegetaliases( self.asm.archetype, var_0 );
    return var_1[randomint( var_1.size )];
}

asm_lookupanimfromaliasifexists( var_0, var_1 )
{
    var_2 = undefined;

    if ( isdefined( self.animationarchetype ) )
        var_2 = self.animationarchetype;
    else
        var_2 = self.asm.archetype;

    var_3 = archetypegetrandomalias( var_2, var_0, var_1, asm_isfrantic() );
    return var_3;
}

asm_lookupanimfromalias( var_0, var_1 )
{
    var_2 = undefined;

    if ( isdefined( self.animationarchetype ) )
        var_2 = self.animationarchetype;
    else
        var_2 = self.asm.archetype;

    var_3 = archetypegetrandomalias( var_2, var_0, var_1, asm_isfrantic() );
    return var_3;
}

asm_getallanimsforstate( var_0 )
{
    var_1 = self.asm.archetype;
    var_2 = archetypegetaliases( var_1, var_0 );
    var_3 = [];

    foreach ( var_5 in var_2 )
    {
        var_6 = archetypegetalias( var_1, var_0, var_5, 0 );

        if ( isarray( var_6.anims ) )
        {
            var_3 = scripts\engine\utility::array_combine( var_3, var_6.anims );
            continue;
        }

        var_3[var_3.size] = var_6.anims;
    }

    return var_3;
}

asm_getallanimsforalias( var_0, var_1, var_2 )
{
    var_3 = archetypegetalias( var_0, var_1, var_2, 1 );

    if ( !isdefined( var_3 ) )
        return undefined;

    var_4 = var_3.anims;

    if ( !isarray( var_4 ) )
        var_4 = [ var_4 ];

    return var_4;
}

asm_getallanimindicesforalias( var_0, var_1 )
{
    return analyticsstreamerlogfileendstream( self.asm.archetype, var_0, var_1 );
}

asm_playanimstate( var_0, var_1, var_2 )
{
    self endon( var_1 + "_finished" );
    var_3 = asm_getanim( var_0, var_1 );
    self aisetanim( var_1, var_3 );
    asm_playfacialanim( var_0, var_1, asm_getxanim( var_1, var_3 ) );
    var_4 = asm_donotetracks( var_0, var_1, asm_getnotehandler( var_0, var_1 ) );

    if ( var_4 == "code_move" )
        var_4 = asm_donotetracks( var_0, var_1, asm_getnotehandler( var_0, var_1 ) );
}

asm_hasknobs()
{
    if ( isagent( self ) && !istrue( self.bsoldier ) && self.unittype != "civilian" )
        return 0;

    return 1;
}

asm_loopanimstate( var_0, var_1, var_2, var_3 )
{
    self endon( var_1 + "_finished" );

    if ( asm_hasknobs() )
    {
        var_4 = asm_getbodyknob();

        if ( isdefined( var_3 ) && var_3 )
        {
            var_5 = asm_lookupanimfromaliasifexists( "knobs", "move" );

            if ( isdefined( var_5 ) )
            {
                var_6 = asm_getxanim( "knobs", var_5 );
                self setmoveanimknob( var_6 );
            }
        }
    }

    var_7 = asm_getnotehandler( var_0, var_1 );
    var_8 = 0.2;
    var_9 = isdefined( var_3 ) && var_3;
    var_10 = 1;

    for (;;)
    {
        var_11 = asm_getanim( var_0, var_1 );
        var_12 = asm_getxanim( var_1, var_11 );

        if ( isdefined( var_3 ) && var_3 )
        {
            var_2 = asm_getmoveplaybackrate();
            self codemoveanimrate( var_2 );
        }

        if ( !var_9 )
            var_10 = self aigetanimweight( var_12 ) == 0;

        if ( isnumber( var_11 ) )
            self aisetanim( var_1, var_11, var_2 );
        else
        {
            var_13 = asm_lookupanimfromalias( var_1, "blank" );
            self aisetanim( var_1, var_13 );

            if ( var_10 )
                self setflaggedanimrestart( var_1, var_11, 1, 0.2, var_2 );
            else
                self setflaggedanim( var_1, var_11, 1, 0.2, var_2 );
        }

        if ( var_9 )
            var_10 = 0;

        asm_playfacialanim( var_0, var_1, var_12 );
        var_14 = getanimlength( var_12 );

        if ( var_14 <= 0.05 )
            return;

        var_15 = undefined;
        var_16 = var_2;

        while ( !isdefined( var_15 ) )
        {
            var_15 = asm_donotetrackswithtimeout( var_0, var_1, var_8, var_7 );

            if ( !isdefined( var_15 ) && var_9 )
            {
                var_2 = asm_getmoveplaybackrate();

                if ( var_2 != var_16 )
                {
                    self codemoveanimrate( var_2 );

                    if ( isnumber( var_11 ) )
                    {
                        self aisetanimrate( var_1, var_11, var_2 );
                        continue;
                    }

                    self setanimrate( var_12, var_2 );
                }
            }
        }
    }
}

asm_lookupdirectionalfootanim( var_0, var_1, var_2, var_3, var_4 )
{
    var_5 = "";

    if ( isdefined( var_4 ) )
        var_5 = var_4;

    if ( var_3 )
    {
        if ( asm_eventfiredrecently( var_1, "pass_left" ) )
            var_6 = var_5 + "left";
        else if ( asm_eventfiredrecently( var_1, "pass_right" ) )
            var_6 = var_5 + "right";
        else if ( self.asm.footsteps.foot == "right" )
            var_6 = var_5 + "right";
        else
            var_6 = var_5 + "left";
    }
    else
        var_6 = var_5;

    var_7 = asm_lookupanimfromaliasifexists( var_2, var_6 + var_0 );

    if ( isdefined( var_7 ) )
        return var_7;

    if ( var_5 != var_6 )
    {
        var_7 = asm_lookupanimfromaliasifexists( var_2, var_5 + var_0 );

        if ( isdefined( var_7 ) )
            return var_7;
    }

    return undefined;
}

asm_setmoveplaybackrate( var_0 )
{
    self.moveplaybackrate = var_0;
}

asm_getmoveplaybackrate()
{
    return self.moveplaybackrate;
}

asm_getcurrentstatename( var_0 )
{
    return self asmgetcurrentstate( var_0 );
}

asm_dosinglenotetrack( var_0, var_1, var_2, var_3, var_4 )
{
    var_5 = var_1;

    if ( isdefined( var_4 ) )
        var_5 = var_4;

    self waittill( var_5, var_6 );

    if ( !isdefined( var_6 ) )
        var_6 = [ "undefined" ];

    if ( !isarray( var_6 ) )
        var_6 = [ var_6 ];

    var_7 = undefined;

    foreach ( var_9 in var_6 )
    {
        asm_fireevent( var_0, var_9 );
        var_10 = [[ self.fnasm_handlenotetrack ]]( var_9, var_5, var_2, var_3 );

        if ( !isdefined( var_10 ) )
            var_10 = asm_handlenewnotetracks( var_0, var_9, var_1 );

        if ( isdefined( var_10 ) )
            var_7 = var_10;
    }

    return var_7;
}

asm_handlenewnotetracks( var_0, var_1, var_2 )
{
    if ( asm_tryhandledeathstatechangenotetrack( var_1 ) )
        return;

    switch ( var_1 )
    {
        case "start_aim":
            if ( asm_currentstatehasflag( var_0, "notetrackAim" ) )
                asm_setupaim( var_0, var_2, 0.2 );

            break;
    }
}

asm_tryhandledeathstatechangenotetrack( var_0 )
{
    if ( !scripts\engine\utility::string_starts_with( var_0, "ds " ) )
        return 0;

    var_1 = 3;
    self.asm.deathstateoverride = spawnstruct();
    var_1 = var_1 + 1;

    for ( var_2 = ""; var_1 < var_0.size && var_0[var_1] != "]"; var_1 = var_1 + 1 )
        var_2 = var_2 + var_0[var_1];

    self.asm.deathstateoverride.statename = var_2;
    var_1 = var_1 + 1;

    if ( var_1 < var_0.size )
    {
        var_1 = var_1 + 2;

        for ( var_3 = ""; var_1 < var_0.size && var_0[var_1] != "]"; var_1 = var_1 + 1 )
            var_3 = var_3 + var_0[var_1];

        self.asm.deathstateoverride.params = var_3;
    }

    return 1;
}

asm_donotetracksfortime( var_0, var_1, var_2, var_3, var_4 )
{
    var_5 = var_1 + "_timeout";
    self endon( var_5 );
    childthread asm_donotetracksfortime_helper( var_5, var_2 );

    for (;;)
        asm_dosinglenotetrack( var_0, var_1, var_3, var_4 );
}

asm_donotetrackswithtimeout_helper( var_0, var_1, var_2 )
{
    self endon( var_0 );
    wait( var_2 );
    self notify( var_1 );
}

asm_donotetrackswithtimeout( var_0, var_1, var_2, var_3, var_4 )
{
    var_5 = var_1 + "_timeout";
    var_6 = var_1 + "_endHelper";
    self endon( var_5 );
    childthread asm_donotetrackswithtimeout_helper( var_6, var_5, var_2 );
    var_7 = asm_donotetracks( var_0, var_1, var_3, var_4 );
    self notify( var_6 );
    return var_7;
}

asm_donotetracks( var_0, var_1, var_2, var_3, var_4, var_5 )
{
    if ( !isdefined( var_5 ) )
        var_5 = 1;

    for (;;)
    {
        var_6 = asm_dosinglenotetrack( var_0, var_1, var_2, var_3, var_4 );

        if ( isdefined( var_6 ) )
        {
            if ( var_5 && !asm_eventfired( var_0, "end" ) )
                asm_fireevent( var_0, "end" );

            return var_6;
        }
    }
}

asm_donotetrackswithinterceptor( var_0, var_1, var_2, var_3, var_4 )
{
    var_5 = var_1;

    if ( isdefined( var_4 ) )
        var_5 = var_4;

    for (;;)
    {
        self waittill( var_5, var_6 );

        if ( !isdefined( var_6 ) )
            var_6 = [ "undefined" ];

        if ( !isarray( var_6 ) )
            var_6 = [ var_6 ];

        var_7 = undefined;

        foreach ( var_9 in var_6 )
        {
            asm_fireevent( var_0, var_9 );
            var_10 = [[ var_2 ]]( var_1, var_9, var_3 );

            if ( isdefined( var_10 ) && var_10 )
                continue;

            var_11 = [[ self.fnasm_handlenotetrack ]]( var_9, var_1, undefined, undefined );

            if ( !isdefined( var_11 ) )
                var_11 = asm_handlenewnotetracks( var_0, var_9, var_1 );

            if ( isdefined( var_11 ) )
                var_7 = var_11;
        }

        if ( isdefined( var_7 ) )
            return var_7;
    }
}

asm_donotetrackssingleloop( var_0, var_1, var_2, var_3 )
{
    var_4 = var_1 + "_note_loop_end";
    self endon( var_4 );
    var_5 = getanimlength( var_2 );
    thread asm_donotetrackssingleloop_waiter( var_4, var_1 + "_finished", var_5 );
    asm_donotetracks( var_0, var_1, var_3 );
    self notify( var_4 );
}

asm_donotetrackssingleloop_waiter( var_0, var_1, var_2 )
{
    self endon( "death" );
    self endon( "terminate_ai_threads" );
    self endon( var_0 );
    self endon( var_1 );
    wait( var_2 );
    self notify( var_0 );
}

asm_donotetracksfortime_helper( var_0, var_1 )
{
    wait( var_1 );
    self notify( var_0 );
}

asm_waitforaimnotetrack( var_0, var_1, var_2 )
{
    self endon( var_1 + "_finished" );
    var_3 = 0;

    while ( !var_3 )
    {
        self waittill( var_1, var_4 );

        if ( !isarray( var_4 ) )
            var_4 = [ var_4 ];

        foreach ( var_6 in var_4 )
        {
            if ( var_6 == "start_aim" )
            {
                asm_setupaim( var_0, var_1, var_2 );
                var_3 = 1;
                break;
            }
        }
    }
}

asm_lookuprandomalias( var_0, var_1, var_2 )
{
    var_3 = self.asm.archetype;
    var_4 = archetypegetaliases( var_3, var_0 );
    var_5 = 0.0;
    var_6 = undefined;
    var_7 = -1;

    if ( isdefined( var_1 ) )
        var_7 = var_1.size;

    if ( !isdefined( var_4 ) )
        return undefined;

    foreach ( var_10 in var_4 )
    {
        if ( var_7 < 0 || getsubstr( var_10, 0, var_7 ) == var_1 )
        {
            var_5 = var_5 + 1.0;
            var_11 = 1.0 / var_5;

            if ( randomfloat( 1.0 ) <= var_11 )
                var_6 = var_10;
        }
    }

    return var_6;
}

asm_chooseanim( var_0, var_1, var_2 )
{
    if ( !isdefined( var_2 ) )
    {
        var_3 = asm_lookuprandomalias( var_1 );
        return asm_lookupanimfromalias( var_1, var_3 );
    }
    else
    {
        var_4 = undefined;
        var_5 = scripts\asm\asm_bb::bb_getprefixstring( var_2 );

        if ( isdefined( var_5 ) )
        {
            var_3 = asm_lookuprandomalias( var_1, var_5 );
            var_4 = asm_lookupanimfromalias( var_1, var_3 );
        }
        else
            var_4 = asm_lookupanimfromalias( var_1, var_2 );

        return var_4;
    }
}

asm_clearfacialanim()
{
    if ( self.facialstate != "filler" )
    {
        if ( isai( self ) )
            self setfacialindex( "none" );
        else
            scripts\asm\shared\utility::setfacialindexfornonai( "none" );
    }
}

asm_restorefacialanim()
{
    var_0 = self.asmname;
    var_1 = self asmgetcurrentstate( var_0 );

    if ( var_1 == "animscripted" )
        return;

    asm_playfacialanim( var_0, var_1, undefined );
}

asm_playfacialanim( var_0, var_1, var_2 )
{
    if ( isdefined( self.fnasm_playfacialanim ) )
        [[ self.fnasm_playfacialanim ]]( var_0, var_1, var_2 );
}

asm_getroot()
{
    var_0 = asm_lookupanimfromalias( "knobs", "root" );
    return asm_getxanim( "knobs", var_0 );
}

asm_getbodyknob()
{
    var_0 = asm_lookupanimfromalias( "knobs", "body" );
    return asm_getxanim( "knobs", var_0 );
}

asm_getinnerrootknob()
{
    var_0 = asm_lookupanimfromaliasifexists( "knobs", "inner_root" );

    if ( isdefined( var_0 ) )
        return asm_getxanim( "knobs", var_0 );

    return asm_getbodyknob();
}

asm_getfacialknob()
{
    var_0 = asm_lookupanimfromaliasifexists( "always_on", "facial" );

    if ( isdefined( var_0 ) )
        return asm_getxanim( "always_on", var_0 );
}

asm_getheadlookknobifexists()
{
    var_0 = asm_lookupanimfromaliasifexists( "knobs", "headlook" );

    if ( isdefined( var_0 ) )
        return asm_getxanim( "knobs", var_0 );

    return undefined;
}

asm_isweaponoverride()
{
    var_0 = self.weapon;
    var_1 = getweaponbasename( var_0 );
    var_2 = [ "iw7_cheytac", "iw7_kbs", "iw7_m1", "iw7_m8", "iw7_mauler", "iw7_sdflmg", "iw7_ameli", "iw7_steeldragon", "iw7_sonic", "iw7_sdfshotty", "iw7_spas" ];

    if ( isdefined( var_1 ) && scripts\engine\utility::array_contains( var_2, var_1 ) )
        return 1;

    return 0;
}

asm_getxanim( var_0, var_1 )
{
    if ( isnumber( var_1 ) )
    {
        var_2 = undefined;

        if ( !isdefined( self.asm ) )
            var_2 = self.animationarchetype;
        else
            var_2 = self.asm.archetype;

        return animsetgetallanimindicesforalias( var_2, var_0, var_1 );
    }
    else
        return var_1;
}

asm_playanimstatewithnotetrackinterceptor( var_0, var_1, var_2, var_3 )
{
    self endon( var_1 + "_finished" );
    var_4 = asm_getanim( var_0, var_1 );
    self aisetanim( var_1, var_4 );
    asm_playfacialanim( var_0, var_1, asm_getxanim( var_1, var_4 ) );
    var_5 = asm_donotetrackswithinterceptor( var_0, var_1, var_2, var_3 );

    if ( var_5 == "end" )
    {
        if ( !asm_eventfired( var_0, "end" ) )
            asm_fireevent( var_0, "end" );
    }
}

asm_playanimstatenotransition( var_0, var_1, var_2 )
{
    self endon( var_1 + "_finished" );
    var_3 = asm_getanim( var_0, var_1 );
    self aisetanim( var_1, var_3 );
    asm_playfacialanim( var_0, var_1, asm_getxanim( var_1, var_3 ) );
    var_4 = asm_donotetracks( var_0, var_1, asm_getnotehandler( var_0, var_1 ) );
}

asm_playadditiveanimloopstate( var_0, var_1, var_2 )
{
    [[ self.fnasm_playadditiveanimloopstate ]]( var_0, var_1, var_2 );
}

setup_level_ents()
{
    foreach ( var_1 in getnodearray( "traverse", "targetname" ) )
        var_1 traversethink();
}

processdoublejumpmantletraversal( var_0 )
{
    self.doublejumpmantlepos = var_0.origin;
    self.startnodeoriginalangles = self.angles;

    if ( isent( var_0 ) )
        var_0 delete();
    else
        scripts\engine\utility::deletestruct_ref( var_0 );
}

traversethink()
{
    var_0 = getent( self.target, "targetname" );

    if ( !isdefined( var_0 ) )
        var_0 = scripts\engine\utility::getstruct( self.target, "targetname" );

    var_1 = getnode( self.target, "targetname" );

    if ( !isdefined( var_0 ) )
        return;

    switch ( self.animscript )
    {
        case "wall_run":
            processwallruntraversal( var_0 );
            return;
        case "double_jump_mantle":
        case "double_jump_vault":
            processdoublejumpmantletraversal( var_0 );
            return;
        case "double_jump":
            self.startnodeoriginalangles = self.angles;

            if ( !isdefined( var_0 ) )
                return;

            self.jump_over_offset = var_0.origin - self.origin;
            self.jump_over_ent_origin = var_0.origin;
            break;
        case "rail_hop_double_jump_down":
            self.startnodeoriginalangles = self.angles;
            break;
        default:
            break;
    }

    if ( isdefined( var_0.target ) )
    {
        var_3 = getent( var_0.target, "targetname" );

        if ( !isdefined( var_3 ) )
            var_3 = scripts\engine\utility::getstruct( var_0.target, "targetname" );

        calculate_traverse_data( var_0.origin, var_1.origin, var_3.origin );
    }
    else
        calculate_traverse_data( var_0.origin, var_1.origin );

    if ( isdefined( self.parentname ) )
        store_original_traverse_data();

    if ( isent( var_0 ) )
        var_0 delete();
    else
        scripts\engine\utility::deletestruct_ref( var_0 );
}

store_original_traverse_data()
{
    self.original_data = spawnstruct();
    self.original_data.origin = self.origin;
    self.original_data.angles = self.angles;
    self.original_data.traverse_height = self.traverse_height;
    self.original_data.traverse_height_delta = self.traverse_height_delta;
    self.original_data.traverse_drop_height_delta = self.traverse_drop_height_delta;
    self.original_data.apex_delta = self.apex_delta;
    self.original_data.apex_delta_local = rotatevectorinverted( self.apex_delta, self.angles );

    if ( isdefined( self.across_delta ) )
    {
        self.original_data.across_delta = self.across_delta;
        self.original_data.across_delta_local = rotatevectorinverted( self.across_delta, self.angles );
    }

    var_0 = getnode( self.target, "targetname" );

    if ( isdefined( var_0 ) )
        self.original_data.endnode_pos = var_0.origin;
}

calculate_traverse_data( var_0, var_1, var_2 )
{
    self.traverse_height = var_0[2];
    self.traverse_height_delta = var_0[2] - self.origin[2];
    self.traverse_drop_height_delta = var_0[2] - var_1[2];
    self.apex_delta = var_0 - self.origin;

    if ( isdefined( var_2 ) )
        self.across_delta = var_2 - var_0;
}

re_calculate_traverse_data( var_0, var_1, var_2, var_3 )
{
    if ( !isdefined( var_1 ) )
        var_1 = self.origin + rotatevector( var_0.original_data.apex_delta_local, self.angles );

    if ( !isdefined( var_2 ) )
        var_2 = var_0.original_data.endnode_pos;

    if ( !isdefined( var_3 ) && isdefined( var_0.original_data.across_delta_local ) )
    {
        var_4 = rotatevector( var_0.original_data.across_delta_local, self.angles );
        var_3 = var_1 + var_4;
    }

    calculate_traverse_data( var_1, var_2, var_3 );
}

processwallruntraversal( var_0 )
{
    var_1 = getent( var_0.target, "targetname" );

    if ( !isdefined( var_1 ) )
        var_1 = scripts\engine\utility::getstruct( var_0.target, "targetname" );

    self.wall_info = spawnstruct();
    var_3 = var_0;
    var_4 = 0;
    self.wall_info.startnodeoriginalangles = self.angles;
    var_6 = undefined;

    while ( isdefined( var_3 ) )
    {
        self.wall_info.nodeoffsets[var_4] = var_3.origin - self.origin;
        var_4++;
        var_7 = scripts\engine\utility::getstruct( var_3.target, "targetname" );
        scripts\engine\utility::deletestruct_ref( var_3 );
        var_3 = var_7;
        self.wall_info.nodeoffsets[var_4] = var_3.origin - self.origin;
        var_4++;

        if ( isdefined( var_3.target ) )
            var_10 = scripts\engine\utility::getstruct( var_3.target, "targetname" );
        else
            var_10 = undefined;

        scripts\engine\utility::deletestruct_ref( var_3 );
        var_3 = var_10;

        if ( isdefined( var_3 ) && isdefined( var_3.script_wallrun_type ) )
        {
            if ( var_3.script_wallrun_type == "wallrun_mantle" )
            {
                self.wall_info.mantleoffset = var_3.origin - self.origin;

                if ( isdefined( var_3.angles ) )
                    self.wall_info.mantleangles = var_3.angles;

                scripts\engine\utility::deletestruct_ref( var_3 );
                break;
            }
            else if ( var_3.script_wallrun_type == "wallrun_vault" )
            {
                self.wall_info.mantleoffset = var_3.origin - self.origin;
                self.wall_info.bvaultover = 1;
                scripts\engine\utility::deletestruct_ref( var_3 );
                break;
            }
        }
    }
}
