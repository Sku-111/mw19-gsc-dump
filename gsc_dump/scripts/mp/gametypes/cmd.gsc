// IW8 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

main()
{
    if ( getdvar( "mapname" ) == "mp_background" )
        return;

    scripts\mp\globallogic::init();
    scripts\mp\globallogic::setupcallbacks();
    var_0[0] = "cop";
    scripts\mp\gameobjects::main( var_0 );

    if ( isusingmatchrulesdata() )
    {
        level.initializematchrules = ::initializematchrules;
        [[ level.initializematchrules ]]();
        level thread scripts\mp\utility\game::reinitializematchrulesonmigration();
    }
    else
    {
        scripts\mp\utility\game::registertimelimitdvar( scripts\mp\utility\game::getgametype(), 1200 );

        if ( 1 )
            scripts\mp\utility\game::registerscorelimitdvar( scripts\mp\utility\game::getgametype(), 5 );
        else
            scripts\mp\utility\game::registerscorelimitdvar( scripts\mp\utility\game::getgametype(), 0 );

        scripts\mp\utility\game::registerroundlimitdvar( scripts\mp\utility\game::getgametype(), 2 );
        scripts\mp\utility\game::registerroundswitchdvar( scripts\mp\utility\game::getgametype(), 0, 0, 1 );
        scripts\mp\utility\game::registerwinlimitdvar( scripts\mp\utility\game::getgametype(), 0 );
        scripts\mp\utility\game::registernumlivesdvar( scripts\mp\utility\game::getgametype(), 0 );
        scripts\mp\utility\game::registerhalftimedvar( scripts\mp\utility\game::getgametype(), 0 );
        scripts\mp\utility\game::setovertimelimitdvar( 300 );
    }

    updategametypedvars();
    level.objectivebased = 1;
    level.teambased = 1;
    level.disablebuddyspawn = 1;
    level.onstartgametype = ::onstartgametype;
    level.onplayerconnect = ::onplayerconnect;
    level.ontimelimit = ::ontimelimit;
    level.getspawnpoint = ::getspawnpoint;
    level.onplayerkilled = ::onplayerkilled;
    level.lastcaptime = gettime();
    level.resetuiomnvargamemode = scripts\mp\gametypes\obj_bombzone.gsc::resetuiomnvargamemode;
    level.alliescapturing = [];
    level.axiscapturing = [];
    level.cmdattackingteam = "neutral";
    level.cmddefendingteam = "neutral";
    level.timerstoppedforgamemode = 0;
    level.extratime = 0;
    game["dialog"]["gametype"] = "intro_start";

    if ( getdvarint( "OSMSLRTOP" ) )
        game["dialog"]["gametype"] = "hc_" + game["dialog"]["gametype"];
    else if ( getdvarint( "NOSLRNTRKL" ) )
        game["dialog"]["gametype"] = "thirdp_" + game["dialog"]["gametype"];

    game["dialog"]["bomb_achieve"] = "bomb_achieve";
    game["dialog"]["bomb_taken"] = "bomb_taken";
    game["dialog"]["bomb_lost"] = "bomb_enemyowns";
    game["dialog"]["bomb_defusing"] = "bomb_enemydefusing";
    game["dialog"]["bomb_defused"] = "bomb_defused";
    game["dialog"]["bomb_planted"] = "bomb_planted";
    game["dialog"]["enemy_bomb_a"] = "bomb_enemy_a";
    game["dialog"]["enemy_bomb_b"] = "bomb_enemy_b";
    game["dialog"]["enemy_bomb_defused"] = "bomb_enemydefused";
    game["dialog"]["enemy_bomb_planted"] = "bomb_enemyplanted";
    game["dialog"]["offense_obj"] = "cop_obj_clock";
    game["dialog"]["defense_obj"] = "cop_obj_clock";
    game["dialog"]["cop_obj_0_mp_faridah"] = "obj_embassy";
    game["dialog"]["cop_obj_0_attack_mp_faridah"] = "embassy_attack";
    game["dialog"]["cop_obj_0_mp_euphrates"] = "obj_compound";
    game["dialog"]["cop_obj_0_attack_mp_euphrates"] = "compound_attack";
    game["dialog"]["cop_obj_1_mp_faridah"] = "obj_school";
    game["dialog"]["cop_obj_1_attack_mp_faridah"] = "school_attack";
    game["dialog"]["cop_obj_1_defend_mp_faridah"] = "school_defend";
    game["dialog"]["cop_obj_1_enemy_cap_mp_faridah"] = "school_enemycapture";
    game["dialog"]["cop_obj_1_enemy_hold_mp_faridah"] = "school_enemycaptured";
    game["dialog"]["cop_obj_1_mp_euphrates"] = "obj_buses";
    game["dialog"]["cop_obj_1_attack_mp_euphrates"] = "buses_attack";
    game["dialog"]["cop_obj_1_defend_mp_euphrates"] = "buses_defend";
    game["dialog"]["cop_obj_1_enemy_cap_mp_euphrates"] = "buses_enemycapture";
    game["dialog"]["cop_obj_1_enemy_hold_mp_euphrates"] = "buses_enemycaptured";
    game["dialog"]["cop_obj_2_mp_faridah"] = "obj_clock";
    game["dialog"]["cop_obj_2_attack_mp_faridah"] = "clock_attack";
    game["dialog"]["cop_obj_2_defend_mp_faridah"] = "clock_defend";
    game["dialog"]["cop_obj_2_mp_euphrates"] = "obj_underpass";
    game["dialog"]["cop_obj_2_attack_mp_euphrates"] = "underpass_attack";
    game["dialog"]["cop_obj_2_defend_mp_euphrates"] = "underpass_defend";
    game["dialog"]["cop_obj_2_enemy_cap_mp_euphrates"] = "underpass_enemycapture";
    game["dialog"]["cop_obj_2_enemy_hold_mp_euphrates"] = "underpass_enemycaptured";
    game["dialog"]["cop_obj_3_mp_faridah"] = "obj_warehouse";
    game["dialog"]["cop_obj_3_attack_mp_faridah"] = "warehouse_attack";
    game["dialog"]["cop_obj_3_defend_mp_faridah"] = "warehouse_defend";
    game["dialog"]["cop_obj_3_enemy_cap_mp_faridah"] = "warehouse_enemycapture";
    game["dialog"]["cop_obj_3_enemy_hold_mp_faridah"] = "warehouse_enemycaptured";
    game["dialog"]["cop_obj_3_mp_euphrates"] = "obj_construction";
    game["dialog"]["cop_obj_3_attack_mp_euphrates"] = "construction_attack";
    game["dialog"]["cop_obj_3_defend_mp_euphrates"] = "construction_defend";
    game["dialog"]["cop_obj_3_enemy_cap_mp_euphrates"] = "construction_enemycapture";
    game["dialog"]["cop_obj_3_enemy_hold_mp_euphrates"] = "construction_enemycaptured";
    game["dialog"]["cop_obj_4_mp_faridah"] = "obj_compound";
    game["dialog"]["cop_obj_4_defend_mp_faridah"] = "compound_defend";
    game["dialog"]["cop_obj_4_mp_euphrates"] = "obj_fob";
    game["dialog"]["cop_obj_4_attack_mp_euphrates"] = "fob_attack";
    game["dialog"]["cop_obj_4_defend_mp_euphrates"] = "fob_defend";
    game["dialog"]["cop_target_active"] = "gamestate_targetactive";
    game["dialog"]["cop_obj_contested"] = "obj_contested";
    game["dialog"]["cop_enemy_sec"] = "enemy_capturingneutral";
    game["dialog"]["cop_hold"] = "confirm_copsecurewait";
    game["dialog"]["cop_outpostcaptured"] = "confirm_copsecureyes";
    game["dialog"]["cop_bombplanted_atenemy"] = "bombplanted_atenemycop";
    game["dialog"]["cop_bombplanted_atfriendly"] = "bombplanted_atfriendlycop";
    game["dialog"]["cop_bombdefused"] = "compound_bombdefused";
    game["dialog"]["sitrep_0_mp_faridah"] = "sitrep_embspawn";
    game["dialog"]["sitrep_1_mp_faridah"] = "sitrep_schoolspawn";
    game["dialog"]["sitrep_2_mp_faridah"] = "sitrep_clockspawn";
    game["dialog"]["sitrep_3_mp_faridah"] = "sitrep_whspawn";
    game["dialog"]["sitrep_4_mp_faridah"] = "sitrep_comspawn";
    game["dialog"]["sitrep_0_mp_euphrates"] = "sitrep_comspawn";
    game["dialog"]["sitrep_1_mp_euphrates"] = "sitrep_busesspawn";
    game["dialog"]["sitrep_2_mp_euphrates"] = "sitrep_undspawn";
    game["dialog"]["sitrep_3_mp_euphrates"] = "sitrep_constspawn";
    game["dialog"]["sitrep_4_mp_euphrates"] = "sitrep_fobspawn";
    game["dialog"]["cop_order_attack"] = "order_attack";
    game["dialog"]["cop_order_fallback"] = "order_fallback";
    game["dialog"]["cop_killstreak_bradley"] = "killstreak_bradley";
    game["dialog"]["cop_enemy_bradley"] = "enemy_bradley";
    game["dialog"]["cop_hostage_located"] = "hostage_located";
    game["dialog"]["cop_hostage_extraction"] = "hostage_extraction";
    game["dialog"]["cop_breach_plant"] = "breach_plant";
    thread ongameended();
    level._effect["vfx_smk_signal"] = loadfx( "vfx/_requests/mp_gameplay/vfx_smk_signal" );
}

initializematchrules()
{
    scripts\mp\utility\game::setcommonrulesfrommatchrulesdata();
    setdynamicdvar( "scr_cmd_cmdRules", getmatchrulesdata( "cmdData", "cmdRules" ) );
    setdynamicdvar( "scr_cmd_activationDelayCenter", getmatchrulesdata( "cmdData", "activationDelayCenter" ) );
    setdynamicdvar( "scr_cmd_activationDelayHalf", getmatchrulesdata( "cmdData", "activationDelayHalf" ) );
    setdynamicdvar( "scr_cmd_activationDelayBase", getmatchrulesdata( "cmdData", "activationDelayBase" ) );
    setdynamicdvar( "scr_cmd_captureDurationCenter", getmatchrulesdata( "cmdData", "captureDurationCenter" ) );
    setdynamicdvar( "scr_cmd_captureDurationHalf", getmatchrulesdata( "cmdData", "captureDurationHalf" ) );
    setdynamicdvar( "scr_cmd_captureDurationBase", getmatchrulesdata( "cmdData", "captureDurationBase" ) );
    setdynamicdvar( "scr_cmd_holdDurationCenter", getmatchrulesdata( "cmdData", "holdDurationCenter" ) );
    setdynamicdvar( "scr_cmd_holdDurationHalf", getmatchrulesdata( "cmdData", "holdDurationHalf" ) );
    setdynamicdvar( "scr_cmd_holdDurationBase", getmatchrulesdata( "cmdData", "holdDurationBase" ) );
    setdynamicdvar( "scr_cmd_juggSpawnBehavior", getmatchrulesdata( "cmdData", "juggSpawnBehavior" ) );
    setdynamicdvar( "scr_cmd_flagCaptureTime", getmatchrulesdata( "domData", "flagCaptureTime" ) );
    setdynamicdvar( "scr_cmd_flagNeutralization", getmatchrulesdata( "domData", "flagNeutralization" ) );
    setdynamicdvar( "scr_cmd_captureCondition", getmatchrulesdata( "ctfData", "captureCondition" ) );
    setdynamicdvar( "scr_dom_halftime", 0 );
    scripts\mp\utility\game::registerhalftimedvar( "dom", 0 );
}

updategametypedvars()
{
    scripts\mp\gametypes\common.gsc::updatecommongametypedvars();
    level.cmdrules = scripts\mp\utility\dvars::dvarintvalue( "cmdRules", 1, 1, 3 );
    level.tieractivationdelay = [];
    level.tieractivationdelay[0] = scripts\mp\utility\dvars::dvarfloatvalue( "activationDelayCenter", 15, 0, 60 );
    level.tieractivationdelay[1] = scripts\mp\utility\dvars::dvarfloatvalue( "activationDelayHalf", 15, 0, 60 );
    level.tieractivationdelay[2] = scripts\mp\utility\dvars::dvarfloatvalue( "activationDelayBase", 15, 0, 60 );
    level.tiercapturetime = [];
    level.tiercapturetime[0] = scripts\mp\utility\dvars::dvarfloatvalue( "captureDurationCenter", 10, 0, 60 );
    level.tiercapturetime[1] = scripts\mp\utility\dvars::dvarfloatvalue( "captureDurationHalf", 10, 0, 60 );
    level.tiercapturetime[2] = scripts\mp\utility\dvars::dvarfloatvalue( "captureDurationBase", 10, 0, 60 );
    level.tierholdtime = [];
    level.tierholdtime[0] = scripts\mp\utility\dvars::dvarfloatvalue( "holdDurationCenter", 30, 0, 60 );
    level.tierholdtime[1] = scripts\mp\utility\dvars::dvarfloatvalue( "holdDurationHalf", 30, 0, 60 );
    level.tierholdtime[2] = scripts\mp\utility\dvars::dvarfloatvalue( "holdDurationBase", 45, 0, 60 );
    level.juggspawnbehavior = scripts\mp\utility\dvars::dvarintvalue( "juggSpawnBehavior", 1, 0, 3 );
    level.flagcapturetime = scripts\mp\utility\dvars::dvarfloatvalue( "flagCaptureTime", 10, 0, 30 );
    level.flagneutralization = scripts\mp\utility\dvars::dvarintvalue( "flagNeutralization", 0, 0, 1 );
    level.hvtspawnpos = scripts\mp\utility\dvars::dvarintvalue( "captureCondition", 1, 0, 2 );
    level.overtime = scripts\mp\utility\dvars::dvarfloatvalue( "overtimeLimit", 300, 0, 300 );
    scripts\mp\utility\game::setovertimelimitdvar( level.overtime );
    level.persistentbombtimer = 0;
    level.persistentdomtimer = 1;

    if ( istrue( level.persistentbombtimer ) )
        level.bombtimer = 60;
    else
        level.bombtimer = 30;

    if ( level.cmdrules == 1 )
    {
        level.planttime = 2;
        level.defusetime = 2;
    }
    else
    {
        level.planttime = level.tiercapturetime[2];
        level.defusetime = level.tiercapturetime[2];
        level.bombtimer = 3;
    }

    level.controltoprogress = 1;
    setdvar( "NSOMOMMLML", 200.0 );
    level.forcedobjectiveindex = getdvarint( "scr_cmd_force_index", -1 );

    if ( level.forcedobjectiveindex != -1 )
    {
        setdynamicdvar( "scr_" + scripts\mp\utility\game::getgametype() + "_roundLimit", 2 );
        scripts\mp\utility\game::registerroundlimitdvar( scripts\mp\utility\game::getgametype(), 2 );
        setdynamicdvar( "scr_" + scripts\mp\utility\game::getgametype() + "_roundswitch", 1 );
        scripts\mp\utility\game::registerroundswitchdvar( scripts\mp\utility\game::getgametype(), 1, 0, 1 );
    }
}

ontimelimit()
{
    if ( level.cmdrules == 2 )
    {
        if ( level.cmddefendingteam != "neutral" )
            cmd_endgame( level.cmddefendingteam, game["end_reason"]["outpost_defended"] );
        else
            level thread scripts\mp\gamelogic::endgame( "tie", game["end_reason"]["time_limit_reached"] );
    }
    else if ( scripts\mp\utility\game::inovertime() )
        level thread scripts\mp\gamelogic::endgame( "tie", game["end_reason"]["time_limit_reached"] );
    else
        level thread scripts\mp\gamelogic::endgame( "overtime", game["end_reason"]["time_limit_reached"] );
}

seticonnames()
{
    level.iconcapture = "icon_waypoint_capture";
    level.iconcontested = "icon_waypoint_contested";
    level.icondefend = "icon_waypoint_defend";
    level.icondefusing = "icon_waypoint_defusing";
    level.iconlosing = "icon_waypoint_losing";
    level.iconneutral = "icon_waypoint_neutral";
    level.iconplanting = "icon_waypoint_planting";
    level.icontaking = "icon_waypoint_taking";
    level.icontarget = "icon_waypoint_target";
}

onstartgametype()
{
    seticonnames();

    if ( !isdefined( game["switchedsides"] ) )
        game["switchedsides"] = 0;

    if ( game["switchedsides"] )
    {
        var_0 = game["attackers"];
        var_1 = game["defenders"];
        game["attackers"] = var_1;
        game["defenders"] = var_0;
    }

    foreach ( var_3 in level.teamnamelist )
    {
        scripts\mp\utility\game::setobjectivetext( var_3, &"OBJECTIVES/DOM" );

        if ( level.splitscreen )
            scripts\mp\utility\game::setobjectivescoretext( var_3, &"OBJECTIVES/DOM" );
        else
            scripts\mp\utility\game::setobjectivescoretext( var_3, &"OBJECTIVES/DOM_SCORE" );

        scripts\mp\utility\game::setobjectivehinttext( var_3, &"OBJECTIVES/DOM_HINT" );
    }

    setclientnamemode( "auto_change" );
    initspecatatorcameras();
    thread loopspectatorlocations();
    setupobjectives();
    initspawns();
    setupdestructibledoors();

    if ( level.mapname == "mp_faridah" )
        init_mp_faridah();

    thread startgame();
    scripts\mp\gametypes\bradley_spawner.gsc::inittankspawns();
}

init_mp_faridah()
{
    initschoolmgturret();
    thread initksbonuscrates();
    thread initpropaganda();
}

initpropaganda()
{
    scripts\mp\flags::gameflagwait( "prematch_done" );
    var_0 = ( 435, 0, 625 );
    var_1 = ( 0, 0, 0 );
    level.propagandaent = scripts\engine\utility::spawn_tag_origin( var_0, var_1 );
    level.propagandaent show();
    level.propagandaent playloopsound( "tmp_emt_mp_faridah_propaganda_lp" );
}

initschoolmgturret()
{
    var_0 = ( 260, -1415, 150 );
    var_1 = ( 0, 90, 0 );
    var_2 = scripts\engine\utility::spawn_tag_origin( var_0, var_1 );
    var_3 = spawnturret( "misc_turret", var_2.origin, "tur_gun_faridah_mp", 0 );
    var_3.angles = var_2.angles;
    var_3 linkto( var_2, "tag_origin", ( 0, 0, 16 ), ( 0, 0, 0 ) );
    var_3 setmodel( "weapon_mg_bravo50_balcony" );
    var_3 makeunusable();
    var_3 setnodeploy( 1 );
    var_3 setdefaultdroppitch( 0 );
    var_4 = getcompleteweaponname( "tur_gun_faridah_mp" );
    var_3.objweapon = var_4;
    var_5 = var_3 gettagorigin( "tag_turret_pitch" );
    var_6 = scripts\mp\gameobjects::createhintobject( var_5, "HINT_BUTTON", "hud_icon_turret", &"KILLSTREAKS_HINTS/SENTRY_USE_GL" );
    var_6 linkto( var_3, "tag_turret_pitch", ( 0, 0, 5 ), ( 0, 0, 0 ) );
    var_6 thread turretthink( var_3 );
    var_3.killcament = spawn( "script_model", ( 255, -1425, 210 ) );
}

turretthink( var_0 )
{
    for (;;)
    {
        self waittill( "trigger", var_1 );
        self makeunusable();
        var_1.prevweapon = var_1 getcurrentweapon();
        var_1.useweapon = "tur_gun_faridah_mp";
        var_1 scripts\cp_mp\utility\inventory_utility::_giveweapon( var_1.useweapon, undefined, undefined, 1 );

        while ( var_1 scripts\cp_mp\utility\inventory_utility::domonitoredweaponswitch( var_1.useweapon, 1 ) == 0 )
            waitframe();

        var_1 controlturreton( var_0 );
        thread endturretusewatch( var_1, var_0 );
        thread endturretonplayer( var_1 );
        self waittill( "end_turret_use" );

        if ( isdefined( var_1 ) )
        {
            var_1 controlturretoff( var_0 );
            var_1 switchtoweaponimmediate( var_1.prevweapon );
            var_1 scripts\cp_mp\utility\inventory_utility::_takeweapon( var_1.useweapon );
        }

        self makeusable();
    }
}

endturretusewatch( var_0, var_1 )
{
    var_0 endon( "death_or_disconnect" );

    while ( var_0 usebuttonpressed() )
        waitframe();

    for (;;)
    {
        if ( var_0 usebuttonpressed() )
        {
            self notify( "end_turret_use" );
            break;
        }

        waitframe();
    }
}

endturretonplayer( var_0 )
{
    var_0 waittill( "death_or_disconnect" );
    self notify( "end_turret_use" );
}

initksbonuscrates()
{
    wait 2.0;
    var_0 = ( 1125, -1675, 100 );
    givekscratetoteam( "allies", var_0, "cruise_predator" );
    var_0 = ( -1150, -575, 100 );
    givekscratetoteam( "allies", var_0, "chopper_gunner" );
}

initspecatatorcameras()
{
    level.spectatorcameras = [];
    level.currentspectatorcamref = "cop_2";
    var_0 = scripts\engine\utility::getstructarray( "tac_ops_map_config", "targetname" );

    foreach ( var_2 in var_0 )
    {
        var_3 = var_2.script_noteworthy;
        var_4 = scripts\engine\utility::getstructarray( var_2.target, "targetname" );

        foreach ( var_6 in var_4 )
        {
            switch ( var_6.script_label )
            {
                case "to_allies_camera":
                    setteammapposition( var_3, game["attackers"], var_6 );
                    break;
                case "to_axis_camera":
                    setteammapposition( var_3, game["defenders"], var_6 );
                    break;
            }
        }
    }
}

setteammapposition( var_0, var_1, var_2 )
{
    if ( !isdefined( level.spectatorcameras[var_0] ) )
        level.spectatorcameras[var_0] = [];

    level.spectatorcameras[var_0][var_1] = var_2;
}

loopspectatorlocations()
{
    var_0 = 0;

    for (;;)
    {
        if ( getdvarint( "scr_cmd_camera_debug", 0 ) == 1 )
        {
            if ( isalive( level.players[0] ) )
                level.players[0] suicide();

            var_1 = getdvarint( "scr_cmd_camera_index", -1 );

            if ( var_1 != -1 )
                var_0 = var_1;

            updatespectatorcamera( "cop_" + var_0 );
            var_2 = getdvarfloat( "scr_cmd_camera_delay", 1.0 );
            wait( var_2 );
            var_0++;

            if ( var_0 > 4 )
                var_0 = 0;

            if ( getdvarint( "scr_cmd_camera_debug", 0 ) == 0 )
                level.players[0] notify( "force_spawn" );

            continue;
        }

        waitframe();
    }
}

setupdestructibledoors()
{
    if ( !isdefined( level.destructibles ) || !isdefined( level.destructibles["destructible_door"] ) )
        return;

    foreach ( var_1 in level.destructibles["destructible_door"] )
    {
        var_2 = getdoorowner( var_1.ents[0].origin );
        var_1 scripts\mp\destructible::assigninteractteam( scripts\mp\utility\teams::getenemyteams( var_2 ) );
    }
}

getdoorowner( var_0 )
{
    var_1 = undefined;
    var_2 = undefined;

    foreach ( var_4 in level.objectives )
    {
        if ( !isdefined( var_4.defaultownerteam ) )
            continue;

        var_5 = distance2dsquared( var_0, var_4.curorigin );

        if ( !isdefined( var_1 ) || var_5 < var_2 )
        {
            var_1 = var_4;
            var_2 = var_5;
        }
    }

    return var_1.defaultownerteam;
}

initspawns()
{
    level.spawnmins = ( 0, 0, 0 );
    level.spawnmaxs = ( 0, 0, 0 );
    scripts\mp\spawnlogic::setactivespawnlogic( "Default", "Crit_Default" );
    scripts\mp\spawnlogic::addstartspawnpoints( "mp_cmd_spawn_allies_start" );
    scripts\mp\spawnlogic::addstartspawnpoints( "mp_cmd_spawn_axis_start" );
    scripts\mp\spawnlogic::addspawnpoints( game["attackers"], "mp_cmd_spawn_allies", 1 );
    scripts\mp\spawnlogic::addspawnpoints( game["defenders"], "mp_cmd_spawn_axis", 1 );
    level.mapcenter = scripts\mp\spawnlogic::findboxcenter( level.spawnmins, level.spawnmaxs );
    setmapcenter( level.mapcenter );

    foreach ( var_1 in level.objectives )
    {
        var_1.spawnpoints = [];
        var_1.spawnpoints[game["attackers"]] = [];
        var_1.spawnpoints[game["defenders"]] = [];
    }

    foreach ( var_4 in level.spawnpoints )
    {
        if ( isdefined( var_4.script_noteworthy ) )
        {
            var_5 = var_4.script_noteworthy;

            if ( var_4.classname == "mp_cmd_spawn_allies" )
                level.objectives[var_5].spawnpoints[game["attackers"]][level.objectives[var_5].spawnpoints[game["attackers"]].size] = var_4;
            else if ( var_4.classname == "mp_cmd_spawn_axis" )
                level.objectives[var_5].spawnpoints[game["defenders"]][level.objectives[var_5].spawnpoints[game["defenders"]].size] = var_4;
        }
    }

    foreach ( var_8, var_1 in level.objectives )
    {
        var_1.spawnsets = [];
        var_1.spawnsets[game["attackers"]] = "objSpawn_allies_" + var_8;
        scripts\mp\spawnlogic::registerspawnset( var_1.spawnsets[game["attackers"]], var_1.spawnpoints[game["attackers"]] );
        var_1.spawnsets[game["defenders"]] = "objSpawn_axis_" + var_8;
        scripts\mp\spawnlogic::registerspawnset( var_1.spawnsets[game["defenders"]], var_1.spawnpoints[game["defenders"]] );
    }
}

getspawnpoint()
{
    var_0 = self.pers["team"];

    if ( scripts\mp\spawnlogic::shoulduseteamstartspawn() )
    {
        if ( game["switchedsides"] )
            var_0 = scripts\mp\utility\game::getotherteam( var_0 )[0];

        var_1 = scripts\mp\spawnlogic::getspawnpointarray( "mp_cmd_spawn_" + var_0 + "_start" );
        var_2 = scripts\mp\spawnlogic::getspawnpoint_startspawn( var_1 );
        self.startspawnpoint = var_2;
    }
    else
        var_2 = scripts\mp\spawnlogic::getspawnpoint( self, var_0, level.currentobjective.spawnsets[var_0] );

    return var_2;
}

setupobjectives()
{
    level.currentobjective = undefined;
    level.objectives = [];
    setupbombzones();
    setupflags();
    setupareabrushes();
    setupteamoobtriggers();
    validateobjectives();
    thread ui_updatecmdprogress();
    thread disableobjectiveongameended();
    thread setupcaptureflares();
}

setupbombzones()
{
    var_0 = getentarray( "cop_bombzone", "targetname" );

    if ( var_0.size == 0 )
        return;

    level._effect["bomb_explosion"] = loadfx( "vfx/iw8_mp/gamemode/vfx_search_bombsite_destroy.vfx" );
    level._effect["vehicle_explosion"] = loadfx( "vfx/core/expl/small_vehicle_explosion_new.vfx" );
    level._effect["building_explosion"] = loadfx( "vfx/iw7/_requests/mp/vfx_debug_warning.vfx" );
    level._effect["faridah_bomb_explosion"] = loadfx( "vfx/iw8_mp/killstreak/vfx_cruise_predator_explosion_large_2.vfx" );
    level.ddbombmodel = [];
    level.multibomb = 1;
    level.bombsplanted = 0;
    level.bombexploded = 0;
    level.bombplanted = 0;
    level.aplanted = 0;
    level.bplanted = 0;

    foreach ( var_2 in var_0 )
    {
        var_3 = var_2.script_noteworthy;

        if ( var_3 == "5" )
            var_3 = "_b";
        else
            var_3 = "_a";

        var_2.objectivekey = var_3;
        var_2 mapobjectiveicon();
        var_4 = scripts\mp\gametypes\obj_bombzone.gsc::setupobjective( var_2 );
        var_4 bombzone_ondisableobjective();
        var_4 scripts\mp\gameobjects::releaseid();
        level.objectives[var_4.objectivekey] = var_4;
        var_4.onbeginuse = ::bombzone_onbeginuse;
        var_4.onenduse = ::bombzone_onenduse;
        var_4.onuse = ::bombzone_onuseplantobject;
        var_4.ondisableobjective = ::bombzone_ondisableobjective;
        var_4.onenableobjective = ::bombzone_onenableobjective;
        var_4.onactivateobjective = ::bombzone_onactivateobjective;

        if ( var_3 == "_a" )
        {
            var_4 scripts\mp\gameobjects::setownerteam( game["attackers"] );
            continue;
        }

        var_4 scripts\mp\gameobjects::setownerteam( game["defenders"] );
    }
}

setupflags()
{
    var_0 = getentarray( "cop_flag", "targetname" );
    var_1 = getentarray( "cop_flag_override", "targetname" );

    if ( var_0.size == 0 )
        return;

    var_2 = [];

    for ( var_3 = 0; var_3 < var_0.size; var_3++ )
        var_2[var_2.size] = var_0[var_3];

    var_4 = [];

    if ( var_1.size > 0 )
    {
        foreach ( var_6 in var_1 )
        {
            var_7 = var_6.script_noteworthy;
            var_4[var_7] = var_6;
        }
    }

    foreach ( var_6 in var_2 )
    {
        var_7 = var_6.script_noteworthy;

        if ( isdefined( var_4[var_7] ) )
            var_6 = var_4[var_7];

        var_6.objectivekey = var_7;
        var_6 mapobjectiveicon( var_7 );
        var_10 = scripts\mp\gametypes\obj_dom.gsc::setupobjective( var_6 );
        var_10.flagmodel delete();
        var_10.flagmodel = undefined;
        var_10.outlineent = undefined;
        var_10 dompoint_ondisableobjective();
        level.objectives[var_10.objectivekey] = var_10;
        var_10.onbeginuse = ::dompoint_onbeginuse;
        var_10.onuse = ::dompoint_onuse;
        var_10.onenduse = ::dompoint_onenduse;
        var_10.oncontested = ::dompoint_oncontested;
        var_10.onuncontested = ::dompoint_onuncontested;
        var_10.ondisableobjective = ::dompoint_ondisableobjective;
        var_10.onenableobjective = ::dompoint_onenableobjective;
        var_10.onactivateobjective = ::dompoint_onactivateobjective;
        var_10 thread scripts\mp\gametypes\obj_dom.gsc::updateflagstate( "off", 0 );
    }
}

disabledomflagscriptable()
{
    thread scripts\mp\gametypes\obj_dom.gsc::updateflagstate( "off", 0 );
}

setupareabrushes()
{
    var_0 = getentarray( "cop_zone_visual", "targetname" );
    var_1 = getentarray( "cop_zone_visual_contest", "targetname" );
    var_2 = getentarray( "cop_zone_visual_friend", "targetname" );
    var_3 = getentarray( "cop_zone_visual_enemy", "targetname" );
    var_4 = getentarray( "cop_zone_visual_friend_pulse", "targetname" );
    var_5 = getentarray( "cop_zone_visual_enemy_pulse", "targetname" );

    foreach ( var_7 in level.objectives )
    {
        if ( isdefined( var_7.scriptable ) )
        {
            var_7.scriptable delete();
            var_7.scriptable = undefined;
        }
    }

    if ( isdefined( var_0 ) )
    {
        foreach ( var_10 in var_0 )
        {
            var_11 = var_10.script_noteworthy;

            if ( !isdefined( level.objectives[var_11].neutralbrush ) )
                level.objectives[var_11].neutralbrush = [];

            level.objectives[var_11].neutralbrush[level.objectives[var_11].neutralbrush.size] = var_10;
            var_10 hide();
        }

        foreach ( var_10 in var_1 )
        {
            var_11 = var_10.script_noteworthy;

            if ( !isdefined( level.objectives[var_11].contestedbrush ) )
                level.objectives[var_11].contestedbrush = [];

            level.objectives[var_11].contestedbrush[level.objectives[var_11].contestedbrush.size] = var_10;
            var_10 hide();
        }

        foreach ( var_10 in var_2 )
        {
            var_11 = var_10.script_noteworthy;

            if ( !isdefined( level.objectives[var_11].friendlybrush ) )
                level.objectives[var_11].friendlybrush = [];

            level.objectives[var_11].friendlybrush[level.objectives[var_11].friendlybrush.size] = var_10;
            var_10 hide();
        }

        foreach ( var_10 in var_3 )
        {
            var_11 = var_10.script_noteworthy;

            if ( !isdefined( level.objectives[var_11].enemybrush ) )
                level.objectives[var_11].enemybrush = [];

            level.objectives[var_11].enemybrush[level.objectives[var_11].enemybrush.size] = var_10;
            var_10 hide();
        }

        foreach ( var_10 in var_4 )
        {
            var_11 = var_10.script_noteworthy;

            if ( !isdefined( level.objectives[var_11].friendlypulsebrush ) )
                level.objectives[var_11].friendlypulsebrush = [];

            level.objectives[var_11].friendlypulsebrush[level.objectives[var_11].friendlypulsebrush.size] = var_10;
            var_10 hide();
        }

        foreach ( var_10 in var_5 )
        {
            var_11 = var_10.script_noteworthy;

            if ( !isdefined( level.objectives[var_11].enemypulsebrush ) )
                level.objectives[var_11].enemypulsebrush = [];

            level.objectives[var_11].enemypulsebrush[level.objectives[var_11].enemypulsebrush.size] = var_10;
            var_10 hide();
        }
    }
}

setupteamoobtriggers()
{
    var_0 = getentarray( "cop_outofbounds", "targetname" );

    if ( !isdefined( var_0 ) )
        return;

    foreach ( var_2 in var_0 )
    {
        var_3 = var_2.script_noteworthy;

        if ( !isdefined( level.objectives[var_3].oobtriggers ) )
            level.objectives[var_3].oobtriggers = [];

        if ( isdefined( var_2.target ) )
        {
            var_4 = getscriptablearray( var_2.target, "targetname" );
            var_5 = [];

            foreach ( var_7 in var_4 )
            {
                var_8 = var_5.size;
                var_5[var_8] = var_7;

                if ( isdefined( var_7.script_noteworthy ) )
                {
                    var_5[var_8].drawcount = int( var_7.script_noteworthy );
                    continue;
                }

                var_5[var_8].drawcount = 1;
            }

            var_2.visuals = var_5;
            var_2 thread updateoobvisuals( "off" );
        }

        level.objectives[var_3].oobtriggers[var_2.script_label] = var_2;
    }
}

validateobjectives()
{
    if ( level.objectives.size == 0 )
    {

    }
    else if ( ( level.objectives.size - 2 ) % 2 == 0 )
    {

    }

    level.midpointobjectiveindex = int( floor( ( level.objectives.size - 2 ) / 2 ) );
    level.currentobjectiveindex = level.midpointobjectiveindex;
    level.previousobjectiveindex = level.currentobjectiveindex;

    foreach ( var_1 in level.objectives )
    {
        if ( level.cmdrules == 1 )
        {
            if ( var_1.objectivekey == "_a" || var_1.objectivekey == "_b" )
                continue;
        }

        var_2 = int( var_1.objectivekey );
        var_3 = int( clamp( floor( abs( var_2 - 2 ) ), 0, 2 ) );
        var_1.tierindex = var_3;
        var_1.activationdelay = level.tieractivationdelay[var_3];
        var_1.captureduration = level.tiercapturetime[var_3];
        var_1.holdtime = level.tierholdtime[var_3];
        var_1 scripts\mp\gameobjects::disableobject();
        var_1.firsttime = 1;

        if ( level.cmdrules == 1 )
        {
            switch ( var_3 )
            {
                case 1:
                case 0:
                    var_1 scripts\mp\gameobjects::setcapturebehavior( "persistent" );
                    var_1.ignorestomp = 1;
                    break;
                case 2:
                    if ( var_2 < level.midpointobjectiveindex )
                        var_1.defaultownerteam = game["defenders"];
                    else
                        var_1.defaultownerteam = game["attackers"];

                    break;
            }

            continue;
        }

        var_1.firsttime = 1;
        var_1 scripts\mp\gameobjects::setcapturebehavior( "normal" );

        if ( var_2 == level.midpointobjectiveindex )
            continue;

        if ( var_2 < level.midpointobjectiveindex )
        {
            var_1.defaultownerteam = game["defenders"];
            continue;
        }

        var_1.defaultownerteam = game["attackers"];
    }
}

startgame()
{
    level endon( "game_ended" );
    setomnvar( "ui_objective_timer_stopped", 1 );
    setomnvar( "ui_hardpoint_timer", 0 );
    scripts\mp\flags::gameflagwait( "prematch_done" );
    updateteamscores();
    setomnvar( "ui_objective_timer_stopped", 0 );

    if ( level.cmdrules == 2 )
        level scripts\mp\gamelogic::pausetimer();

    updatecurrentobjective( level.currentobjectiveindex );
}

updatecurrentobjective( var_0 )
{
    if ( level.forcedobjectiveindex != -1 )
        var_0 = level.forcedobjectiveindex;

    if ( !isdefined( level.objectives[scripts\engine\utility::string( var_0 )] ) )
        return;

    if ( isdefined( level.currentobjective ) && isdefined( level.currentobjective.ondisableobjective ) )
        level.currentobjective [[ level.currentobjective.ondisableobjective ]]();

    level.previousobjectiveindex = level.currentobjectiveindex;
    level.currentobjectiveindex = var_0;
    updatespectatorcamera( "cop_" + level.currentobjectiveindex );
    level.currentobjective = level.objectives[scripts\engine\utility::string( var_0 )];
    setomnvar( "ui_cmd_current_obj", var_0 );
    updateoobtriggers();

    if ( isdefined( level.currentobjective.onenableobjective ) )
        level.currentobjective [[ level.currentobjective.onenableobjective ]]();

    thread ui_updatecmdholdprogress();
    updateteamscores();

    if ( level.currentobjective.activationdelay > 0 )
    {
        if ( level.cmdrules == 2 && level.currentobjectiveindex == level.midpointobjectiveindex )
            level scripts\mp\gamelogic::pausetimer();

        level.activationdelaystarttime = gettime();
        var_1 = level.currentobjective.activationdelay;
        ui_updatezonetimer( var_1 );
        ui_updatezonetimerpausedness( 0 );
        ui_updatecmdownerteam( "zone_activation_delay" );
        ui_updatecmdcapturestatus( "zone_activation_delay", 0 );
        wait 3.0;
        showsplashtoteam( "all", "cop_target" );
        scripts\mp\utility\dialog::statusdialog( getvoforobjective( "allies", "next" ), "allies", 1 );
        scripts\mp\utility\dialog::statusdialog( getvoforobjective( "axis", "next" ), "axis", 1 );
        level.currentobjective.firsttime = 0;
        var_2 = gettime();

        foreach ( var_4 in level.players )
            var_4.lastsitreptime = var_2;

        wait( var_1 - 3.0 );
        level.activationdelaystarttime = undefined;
    }

    if ( level.cmdrules == 2 && level.currentobjectiveindex == level.midpointobjectiveindex )
        level scripts\mp\gamelogic::resumetimer();

    if ( isdefined( level.currentobjective.onactivateobjective ) )
        level.currentobjective [[ level.currentobjective.onactivateobjective ]]();

    showsplashtoteam( "all", "cop_activate" );
    var_6 = 0;

    switch ( level.currentobjective.tierindex )
    {
        case 0:
            var_6 = 0;
            break;
        case 1:
            var_6 = 5;
            break;
        case 2:
            var_6 = 10;
            break;
    }

    scripts\mp\gamelogic::updatewavespawndelay( var_6 );
    scripts\mp\utility\dialog::statusdialog( "cop_target_active", "allies", 0 );
    scripts\mp\utility\dialog::statusdialog( "cop_target_active", "axis", 0 );
}

getfirsttimevoforobjective( var_0 )
{
    var_1 = "cop_obj_" + level.currentobjectiveindex + "_" + level.mapname;
    return var_1;
}

getvoforobjective( var_0, var_1 )
{
    var_2 = "";
    var_3 = 0;
    var_4 = var_0 == "allies" && level.previousobjectiveindex > level.currentobjectiveindex || var_0 == "axis" && level.previousobjectiveindex < level.currentobjectiveindex;

    if ( var_1 == "next" && level.currentobjective.firsttime )
        var_2 = getfirsttimevoforobjective( var_0 );
    else
    {
        switch ( level.currentobjectiveindex )
        {
            case 4:
            case 0:
                var_3 = 0;

                switch ( var_1 )
                {
                    case "next":
                        var_2 = "cop_obj_" + level.currentobjectiveindex + scripts\engine\utility::ter_op( var_4, "_attack_", "_defend_" ) + level.mapname;
                        break;
                    case "bomb_planted":
                        if ( level.currentobjectiveindex == 0 )
                            var_2 = "cop_bombplanted" + scripts\engine\utility::ter_op( var_0 == "allies", "_atenemy", "_atfriendly" );
                        else
                            var_2 = "cop_bombplanted" + scripts\engine\utility::ter_op( var_0 == "axis", "_atenemy", "_atfriendly" );

                        break;
                    case "bomb_defused":
                        var_3 = 1;
                        break;
                }

                break;
            case 3:
            case 2:
            case 1:
                switch ( var_1 )
                {
                    case "next":
                        var_2 = "cop_obj_" + level.currentobjectiveindex + scripts\engine\utility::ter_op( var_4, "_attack_", "_defend_" ) + level.mapname;
                        break;
                    case "hold_confirmed":
                    case "enemy_sec":
                    case "hold":
                        var_3 = 1;
                        break;
                }

                break;
        }

        if ( var_2 == "" )
        {
            if ( var_3 )
                var_2 = "cop_" + var_1;
            else
                var_2 = "cop_obj_" + level.currentobjectiveindex + "_" + var_1 + "_" + level.mapname;
        }
    }

    return var_2;
}

onplayerkilled( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8, var_9 )
{
    if ( !isplayer( var_1 ) || var_1.team == self.team )
        return;

    if ( isdefined( var_4 ) && scripts\mp\utility\weapon::iskillstreakweapon( var_4.basename ) )
        return;

    switch ( level.currentobjective.id )
    {
        case "domFlag":
            scripts\mp\gametypes\obj_dom.gsc::awardgenericmedals( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8, var_9 );
            break;
        case "bomb_zone":
            scripts\mp\gametypes\obj_bombzone.gsc::bombzone_awardgenericbombzonemedals( var_1, self );
            break;
    }
}

onplayerconnect( var_0 )
{
    var_0.ui_dom_securing = undefined;
    var_0.ui_dom_stalemate = undefined;

    foreach ( var_2 in level.objectives )
    {
        if ( isdefined( var_2.neutralbrush ) )
            var_2 hidebrushes( var_0 );
    }

    var_0 thread updatefloorbrushwaitforjoined();
}

decayholdtime( var_0 )
{
    self endon( "domPoint_HoldTimer" );

    for (;;)
    {
        if ( isdefined( var_0 ) )
        {
            self.teamholdtimers[var_0] = self.teamholdtimers[var_0] - level.framedurationseconds;

            if ( self.teamholdtimers[var_0] <= 0.0 )
            {
                self.teamholdtimers[var_0] = 0.0;
                break;
            }
        }

        waitframe();
    }
}

dompoint_holdtimer( var_0, var_1 )
{
    level endon( "gameEnded" );
    self notify( "domPoint_HoldTimer" );
    self endon( "domPoint_HoldTimer" );
    level.inobjectiveot = 0;
    ui_updatecmdownerteam( var_0 );

    if ( istrue( level.persistentdomtimer ) )
    {
        var_2 = self.teamholdtimers[var_0];
        self.holdteam = var_0;
    }
    else
        var_2 = level.currentobjective.holdtime;

    var_3 = scripts\mp\utility\game::getotherteam( var_0 )[0];

    if ( var_2 > 0 )
    {
        thread decayholdtime( var_0 );
        scripts\mp\utility\dialog::statusdialog( getvoforobjective( var_3, "enemy_hold" ), var_3, 1 );
        var_4 = 0;

        if ( level.currentobjectiveindex != 2 && var_2 > 5.0 )
        {
            var_5 = getclosestplayeronteam( level.currentobjective.trigger.origin, var_0 );

            if ( isdefined( var_5 ) )
            {
                level thread scripts\mp\battlechatter_mp::trysaylocalsound( var_5, getcapturedialog( "captured" ) );
                var_4 = var_4 + var_5 getselfobjcaptureddialog( "captured" );
            }
        }

        if ( var_4 > 0 )
            wait( var_4 );

        var_6 = 0;
        var_5 = getclosestplayeronteam( level.currentobjective.trigger.origin, var_0 );

        if ( isdefined( var_5 ) && var_2 > 5.0 + var_4 )
        {
            var_6 = level thread scripts\mp\battlechatter_mp::trysaylocalsound( var_5, "cop_confirm_copsecureask" );

            if ( !isdefined( var_6 ) )
                var_6 = 0;
        }

        var_4 = var_4 + var_6;
        wait( var_6 );

        if ( var_2 > 5.0 + var_4 )
            scripts\mp\utility\dialog::statusdialog( getvoforobjective( var_0, "hold" ), var_0, 1 );

        if ( var_2 - var_4 > 0 )
            wait( var_2 - var_4 );
        else
            wait( var_2 );

        var_3 = scripts\mp\utility\game::getotherteam( var_0 )[0];

        if ( istrue( level.controltoprogress ) && level.currentobjective.touchlist[var_3].size > 0 )
        {
            level.inobjectiveot = 1;
            ui_updatecmdcapturestatus( "overtime", level.currentobjective.stalemate );

            for (;;)
            {
                if ( level.currentobjective.touchlist[var_3].size == 0 )
                    break;

                waitframe();
            }

            level.inobjectiveot = 0;
        }
    }

    var_7 = 0;
    var_8 = level.currentobjectiveindex;

    if ( var_0 == game["attackers"] )
    {
        var_8--;

        if ( level.currentobjectiveindex <= level.midpointobjectiveindex )
        {
            var_7 = 1;

            if ( level.currentobjective.tierindex == 1 )
            {
                spawnjuggcate( var_0, "attacker" );
                spawnjuggcate( scripts\mp\utility\game::getotherteam( var_0 )[0], "defender" );
            }
            else if ( level.currentobjective.tierindex == 0 )
            {
                if ( isdefined( level.propagandaent ) )
                    level.propagandaent stoploopsound();
            }
        }
    }
    else
    {
        var_8++;

        if ( level.currentobjectiveindex >= level.midpointobjectiveindex )
        {
            var_7 = 1;

            if ( level.currentobjective.tierindex == 1 )
            {
                spawnjuggcate( var_0, "attacker" );
                spawnjuggcate( scripts\mp\utility\game::getotherteam( var_0 )[0], "defender" );
            }
            else if ( level.currentobjective.tierindex == 0 )
            {
                if ( isdefined( level.propagandaent ) )
                    level.propagandaent playloopsound( "tmp_emt_mp_faridah_propaganda_lp" );
            }
        }
    }

    if ( 0 && var_7 )
        scripts\mp\gamescore::giveteamscoreforobjective( var_0, 1, 0 );

    if ( self.tierindex == 0 )
    {
        if ( isdefined( var_1 ) )
            var_1 thread givekillstreak( "uav", 1 );
        else
        {
            var_5 = getclosestplayeronteam( level.currentobjective.trigger.origin, var_0 );
            var_5 thread givekillstreak( "uav", 1 );
        }
    }

    updateteamscores();

    if ( var_2 > 0 )
        scripts\mp\utility\dialog::statusdialog( getvoforobjective( var_0, "hold_confirmed" ), var_0, 1 );

    showsplashtoteam( var_0, "cop_captured_friendly" );
    showsplashtoteam( var_3, "cop_captured_enemy" );

    if ( level.forcedobjectiveindex != -1 )
    {
        scripts\mp\gamescore::giveteamscoreforobjective( var_0, 1, 0 );
        cmd_endgame( var_0, game["end_reason"]["target_destroyed"] );
    }
    else if ( scripts\mp\utility\game::inovertime() )
        scripts\mp\gamescore::giveteamscoreforobjective( var_0, 1, 0 );
    else
    {
        if ( level.cmdrules == 2 && level.currentobjectiveindex == level.midpointobjectiveindex )
        {
            level.extratime = level.extratime + 90;
            var_9 = scripts\mp\gamelogic::gettimeremaining();
            setgameendtime( gettime() + int( var_9 ) );
            level scripts\mp\gamelogic::resumetimer();
        }

        updatecurrentobjective( var_8 );
    }
}

dompoint_cancelholdtimer()
{
    if ( !istrue( level.persistentdomtimer ) )
        return;

    var_0 = scripts\mp\gameobjects::getownerteam();

    if ( isdefined( self.holdteam ) && self.holdteam == var_0 )
    {
        ui_updatezonetimerpausedness( 1 );
        self notify( "domPoint_HoldTimer" );
        self.holdteam = undefined;
    }
}

givekscratetoteam( var_0, var_1, var_2 )
{

}

createkscrate( var_0, var_1, var_2 )
{

}

cratethink( var_0, var_1 )
{
    self endon( "restarting_physics" );
    self endon( "death" );
    var_2 = scripts\engine\utility::drop_to_ground( self.origin + ( 7, 9, 0 ), 50, -200, ( 0, 0, 1 ) );
    var_3 = spawn( "script_model", var_2 + ( 0, 0, 0 ) );
    var_3 setmodel( "offhand_wm_grenade_smoke" );
    var_3.angles = self.angles + ( -80, 120, 90 );
    var_4 = spawn( "script_model", var_3.origin );
    var_4 setmodel( "tag_origin" );
    var_4.angles = self.angles + ( 0, 30, 0 );
    var_4 playloopsound( "mp_flare_burn_lp" );
    waitframe();
    playfxontag( level._effect["vfx_smk_signal"], var_4, "tag_origin" );
    var_5 = &"KILLSTREAKS_HINTS/CRATE_PICKUP";
    var_6 = undefined;

    switch ( var_1 )
    {
        case "juggernaut":
            var_5 = &"KILLSTREAKS_HINTS/JUGGERNAUT_PICKUP_GL";
            var_6 = "icon_ks_jugg";
            break;
        case "cruise_predator":
            var_5 = &"KILLSTREAKS_HINTS/CRUISE_PREDATOR_PICKUP_GL";
            var_6 = "hud_icon_killstreak_cruise_missile";
            break;
        case "chopper_gunner":
            var_5 = &"KILLSTREAKS_HINTS/CHOPPER_GUNNER_PICKUP_GL";
            var_6 = "hud_icon_killstreak_apache";
            break;
    }

    self.useobj = scripts\mp\gameobjects::createhintobject( self.origin + anglestoup( self.angles ) * 24, "HINT_BUTTON", var_6, var_5, -1, undefined, "show", 250, 360, 100, 360 );
    self.useobj linkto( self );

    if ( var_1 == "juggernaut" )
    {
        thread gainedjuggupdater( var_0 );
        thread removedjuggupdater( var_0 );
    }

    for (;;)
    {
        self waittill( "captured", var_7 );

        if ( isplayer( var_7 ) )
        {
            var_7 setclientomnvar( "ui_securing", 0 );
            var_7.ui_securing = undefined;
        }

        switch ( var_1 )
        {
            case "juggernaut":
                if ( !var_7 thread givejuggernaut() )
                    continue;

                break;
            case "cruise_predator":
                var_7 thread givekillstreak( "cruise_predator", 1 );
                wait 3.0;
                break;
            case "chopper_gunner":
                var_7 thread givekillstreak( "chopper_gunner", 1 );
                wait 3.0;
                break;
        }

        var_7 playlocalsound( "ammo_crate_use" );
        stopfxontag( level._effect["vfx_smk_signal"], var_4, "tag_origin" );
        var_4 stoploopsound();
        var_4 delete();
        var_4 = undefined;
        var_3 delete();
        var_3 = undefined;
        scripts\cp_mp\killstreaks\airdrop::destroycrate();
    }
}

gainedjuggupdater( var_0 )
{
    self endon( "death" );

    foreach ( var_2 in level.players )
    {
        if ( var_2.team == var_0 && istrue( var_2.isjuggernaut ) )
            self disableplayeruse( var_2 );
    }

    for (;;)
    {
        level waittill( "gained_juggernaut", var_2 );

        if ( var_2.team == var_0 )
            self disableplayeruse( var_2 );
    }
}

removedjuggupdater( var_0 )
{
    self endon( "death" );

    for (;;)
    {
        level waittill( "removed_juggernaut", var_1 );

        if ( var_1.team == var_0 )
            self enableplayeruse( var_1 );
    }
}

givekillstreak( var_0, var_1 )
{
    var_2 = scripts\mp\killstreaks\killstreaks::createstreakitemstruct( var_0 );
    scripts\mp\killstreaks\killstreaks::awardkillstreakfromstruct( var_2, "other" );

    if ( istrue( var_1 ) )
    {
        wait 0.1;
        self notify( "ks_action_4" );
    }
}

bombzone_warningklaxon()
{
    level endon( "game_ended" );
    thread scripts\mp\music_and_dialog::stopsuspensemusic();
    var_0 = game["music"]["cop_finalpush"].size;
    var_1 = randomint( var_0 );

    foreach ( var_3 in level.players )
        var_3 setplayermusicstate( game["music"]["cop_finalpush"][var_1] );

    wait 2.0;
    wait 16.0;
}

bombzone_holdtimer( var_0 )
{
    if ( !isdefined( level.currentobjective ) )
        return;

    level endon( "gameEnded" );
    level endon( "bomb_planted" );
    self notify( "bombZone_HoldTimer" );
    self endon( "bombZone_HoldTimer" );
    var_1 = level.currentobjective.defaultownerteam;
    var_2 = scripts\mp\utility\game::getotherteam( level.currentobjective.defaultownerteam )[0];
    scripts\mp\objidpoolmanager::objective_show_team_progress( level.currentobjective.objidnum, var_2 );
    level.timelimitoverride = 0;

    if ( var_0 > 0 )
    {
        ui_updatezonetimer( var_0 );
        wait( var_0 );

        if ( istrue( level.controltoprogress ) )
        {
            var_2 = scripts\mp\utility\game::getotherteam( level.currentobjective.defaultownerteam )[0];
            var_3 = 0;

            for (;;)
            {
                if ( !var_3 )
                {
                    var_3 = 1;
                    ui_updatecmdcapturestatus( "overtime", level.currentobjective.stalemate );
                }

                if ( level.currentobjective.touchlist[var_2].size == 0 )
                    break;

                waitframe();
            }
        }
    }

    foreach ( var_5 in level.players )
        var_5 setplayermusicstate( "mus_mp_cop_bombplant_end" );

    thread scripts\mp\music_and_dialog::suspensemusic();
    var_7 = level.currentobjectiveindex;
    var_8 = level.currentobjective scripts\mp\gameobjects::getownerteam();

    if ( var_8 == game["attackers"] )
        var_7--;
    else
        var_7++;

    updatecurrentobjective( var_7 );
}

bombhandler( var_0, var_1, var_2 )
{
    if ( level.gameended )
        return;

    if ( var_1 == "explode" )
    {
        self.bombexploded = 1;
        level.currentobjective [[ level.currentobjective.ondisableobjective ]]();
        scripts\mp\gamescore::giveteamscoreforobjective( var_2, 1, 0 );
        cmd_endgame( var_2, game["end_reason"]["target_destroyed"] );
    }
    else
    {

    }
}

resetbombzone()
{
    scripts\mp\gameobjects::setusetime( level.planttime );
    scripts\mp\gameobjects::setvisibleteam( "none" );
    self.id = "bomb_zone";
    self.useweapon = getcompleteweaponname( "briefcase_bomb_mp" );
    self.bombexploded = undefined;
}

cmd_endgame( var_0, var_1 )
{
    level.docmdoutro = 1;
    var_2 = undefined;

    if ( level.mapname == "mp_faridah" )
    {
        var_2 = spawnstruct();

        if ( var_0 == "allies" )
        {
            var_2.origin = ( -207, -4711, 211 );
            var_2.angles = ( 7, 64, 0 );
        }
        else if ( var_0 == "axis" )
        {
            var_2.origin = ( 1945, 4423, 670 );
            var_2.angles = ( 15, 244, 0 );
        }
        else
        {

        }
    }

    foreach ( var_4 in level.players )
    {
        if ( !isai( var_4 ) )
            var_4 setclientomnvar( "ui_objective_state", 0 );

        var_4 thread playendofmatchtransition( var_2 );
    }

    var_6 = game["teamScores"][var_0];
    var_7 = game["teamScores"][scripts\mp\utility\game::getotherteam( var_0 )[0]];

    if ( var_7 > var_6 )
    {
        var_8 = var_7 - var_6 + 1;
        scripts\mp\gamescore::giveteamscoreforobjective( var_0, var_8, 0 );
    }

    thread scripts\mp\gamelogic::endgame( var_0, var_1 );
    wait 0.65;
    level notify( "allow_bomb_explosion" );
    wait 5.0;
    level notify( "cmd_continue_game_end" );
}

dompoint_onbeginuse( var_0 )
{
    dompoint_cancelholdtimer();
    scripts\mp\gametypes\obj_dom.gsc::dompoint_onusebegin( var_0 );
    self.didstatusnotify = 1;
    thread updateflares( var_0.team );
    ui_updatecmdcapturestatus( var_0.team, self.stalemate );

    if ( var_0.team == game["attackers"] )
    {
        if ( level.currentobjectiveindex == 0 || level.currentobjectiveindex == 4 )
        {
            var_1 = scripts\mp\gameobjects::getownerteam();

            if ( var_0.team != var_1 )
            {
                level thread scripts\mp\battlechatter_mp::trysaylocalsound( var_0, getcapturedialog( "capturing" ) );
                var_0 getselfobjcaptureddialog( "planting" );
            }
            else
                var_0 getselfobjcaptureddialog( "defusing" );
        }
        else
            level thread scripts\mp\battlechatter_mp::trysaylocalsound( var_0, getcapturedialog( "capturing" ) );
    }

    var_2 = scripts\mp\utility\game::getotherteam( var_0.team )[0];

    if ( var_2 == scripts\mp\gameobjects::getownerteam() )
        scripts\mp\utility\dialog::statusdialog( getvoforobjective( var_0.team, "enemy_cap" ), var_2, 0 );
    else
        scripts\mp\utility\dialog::statusdialog( getvoforobjective( var_0.team, "enemy_sec" ), var_2, 0 );

    foreach ( var_0 in level.players )
        updatefloorbrush( var_0 );
}

dompoint_onuse( var_0 )
{
    if ( istrue( level.persistentdomtimer ) )
    {
        ui_updatezonetimerpausedness( 0 );
        self.lastcaptime = gettime();
        self.firstcapture = 0;
    }

    scripts\mp\gametypes\obj_dom.gsc::dompoint_onuse( var_0 );
    var_1 = scripts\mp\gameobjects::getownerteam();
    thread updateflares( var_1 );

    foreach ( var_3 in level.players )
        updatefloorbrush( var_3 );

    level.usestartspawns = 0;
    var_5 = scripts\mp\utility\game::getotherteam( var_1 )[0];
    thread scripts\mp\utility\print::printandsoundoneveryone( var_1, var_5, undefined, undefined, "mp_dom_flag_captured", "mp_dom_flag_lost", var_0 );

    if ( level.cmdrules == 2 )
    {
        if ( level.currentobjectiveindex == level.midpointobjectiveindex )
        {
            level.cmdattackingteam = var_1;
            level.cmddefendingteam = var_5;
            level scripts\mp\gamelogic::pausetimer();
        }
        else
        {
            level.extratime = level.extratime + 90;
            var_6 = scripts\mp\gamelogic::gettimeremaining();
            setgameendtime( gettime() + int( var_6 ) );
        }
    }

    if ( level.currentobjectiveindex == 0 )
    {
        var_7 = level.objectives["_b"] scripts\mp\gameobjects::getownerteam();

        if ( var_1 != var_7 )
            level.objectives["_b"] bombzone_onuseplantobject( var_0 );
        else
            level.objectives["_b"] bombzone_onusedefuseobject( var_0 );
    }
    else if ( level.currentobjectiveindex == 4 )
    {
        var_7 = level.objectives["_a"] scripts\mp\gameobjects::getownerteam();

        if ( var_1 != var_7 )
            level.objectives["_a"] bombzone_onuseplantobject( var_0 );
        else
            level.objectives["_a"] bombzone_onusedefuseobject( var_0 );
    }
    else
    {
        thread dompoint_holdtimer( var_1, var_0 );
        showsplashtoteam( var_1, "cop_hold_friendly" );
        showsplashtoteam( var_5, "cop_hold_enemy" );
    }

    if ( self == level.currentobjective )
        ui_updatecmdcapturestatus( "neutral", 0 );
}

dompoint_onenduse( var_0, var_1, var_2 )
{
    if ( self != level.currentobjective )
        return;

    scripts\mp\gametypes\obj_dom.gsc::dompoint_onuseend( var_0, var_1, var_2 );
    var_3 = scripts\mp\gameobjects::getownerteam();
    var_4 = scripts\engine\utility::ter_op( var_3 == "neutral", "idle", var_3 );
    thread updateflares( var_4 );

    if ( level.cmdrules == 2 )
    {
        if ( level.currentobjectiveindex == level.midpointobjectiveindex )
        {
            var_3 = scripts\mp\gameobjects::getownerteam();
            ui_updatecmdcapturestatus( "neutral", 0 );

            if ( istrue( level.persistentdomtimer ) && self.objectivekey != "0" && self.objectivekey != "4" )
            {
                if ( var_3 != "neutral" )
                {
                    ui_updatezonetimerpausedness( 0 );
                    self.lastcaptime = gettime();
                    thread dompoint_holdtimer( var_3 );
                }
            }
        }
    }
    else if ( !var_2 )
    {
        var_3 = scripts\mp\gameobjects::getownerteam();
        ui_updatecmdcapturestatus( "neutral", 0 );

        if ( istrue( level.persistentdomtimer ) && self.objectivekey != "0" && self.objectivekey != "4" )
        {
            if ( var_3 != "neutral" )
            {
                ui_updatezonetimerpausedness( 0 );
                self.lastcaptime = gettime();
                thread dompoint_holdtimer( var_3 );
            }
        }
    }

    foreach ( var_1 in level.players )
        updatefloorbrush( var_1 );
}

dompoint_oncontested()
{
    if ( self != level.currentobjective )
        return;

    dompoint_cancelholdtimer();
    scripts\mp\gametypes\obj_dom.gsc::dompoint_oncontested();
    thread updateflares( "contested" );
    var_0 = scripts\mp\gameobjects::getownerteam();

    if ( var_0 == "neutral" )
    {
        if ( level.cmdrules == 2 && level.currentobjectiveindex == level.midpointobjectiveindex )
            level scripts\mp\gamelogic::resumetimer();
    }

    ui_updatecmdcapturestatus( var_0, 1 );
    var_1 = var_0;

    if ( var_0 == "neutral" )
        var_1 = self.claimteam;

    if ( var_1 != "none" )
        scripts\mp\utility\dialog::statusdialog( "cop_obj_contested", var_1, 0 );

    foreach ( var_3 in level.players )
        updatefloorbrush( var_3 );
}

dompoint_onuncontested( var_0 )
{
    if ( self != level.currentobjective )
        return;

    scripts\mp\gametypes\obj_dom.gsc::dompoint_onuncontested( var_0 );
    self.didstatusnotify = 1;
    var_1 = scripts\mp\gameobjects::getownerteam();

    if ( var_1 == "neutral" )
    {
        if ( level.cmdrules == 2 && level.currentobjectiveindex == level.midpointobjectiveindex )
            level scripts\mp\gamelogic::resumetimer();
    }

    var_2 = scripts\engine\utility::ter_op( var_1 == "neutral", "idle", var_1 );
    thread updateflares( var_2 );

    if ( level.cmdrules == 2 )
    {
        if ( level.currentobjectiveindex == level.midpointobjectiveindex )
        {
            if ( var_1 != "neutral" && self.touchlist[scripts\mp\utility\game::getotherteam( var_1 )[0]].size == 0 )
            {
                ui_updatezonetimerpausedness( 0 );
                self.lastcaptime = gettime();
                thread dompoint_holdtimer( var_1 );
            }
        }
    }
    else if ( istrue( level.persistentdomtimer ) && level.currentobjectiveindex != 0 && level.currentobjectiveindex != 4 )
    {
        if ( var_1 != "neutral" && self.touchlist[scripts\mp\utility\game::getotherteam( var_1 )[0]].size == 0 )
        {
            ui_updatezonetimerpausedness( 0 );
            self.lastcaptime = gettime();
            thread dompoint_holdtimer( var_1 );
        }
    }

    ui_updatecmdcapturestatus( "neutral", 0 );

    foreach ( var_4 in level.players )
        updatefloorbrush( var_4 );
}

dompoint_ondisableobjective()
{
    scripts\mp\gameobjects::allowuse( "none" );
    scripts\mp\gameobjects::disableobject();
    scripts\mp\gameobjects::resetcaptureprogress();
    scripts\mp\gameobjects::releaseid();
    scripts\engine\utility::delaythread( 0.1, ::disabledomflagscriptable );
    thread updateflares( "off" );

    foreach ( var_1 in level.players )
        updatefloorbrush( var_1, 1 );
}

dompoint_onenableobjective()
{
    scripts\mp\gameobjects::requestid( 1, 1 );
    scripts\mp\objidpoolmanager::objective_set_play_intro( self.objidnum, 1 );
    scripts\mp\objidpoolmanager::objective_set_play_outro( self.objidnum, 1 );
    scripts\mp\gameobjects::enableobject();
    scripts\mp\gameobjects::setvisibleteam( "any" );
    scripts\mp\gameobjects::allowuse( "none" );
    scripts\mp\gameobjects::setobjectivestatusicons( level.icontarget );

    if ( istrue( level.persistentdomtimer ) )
    {
        if ( !isdefined( self.teamholdtimers ) )
            self.teamholdtimers = [];

        self.teamholdtimers["allies"] = self.holdtime;
        self.teamholdtimers["axis"] = self.holdtime;
        self.firstcapture = 1;
        self.holdteam = undefined;
    }

    if ( isdefined( self.defaultownerteam ) )
    {
        scripts\mp\gameobjects::setownerteam( self.defaultownerteam );
        thread scripts\mp\gametypes\obj_dom.gsc::updateflagstate( self.defaultownerteam, 0 );
        thread updateflares( self.defaultownerteam );
    }
    else
    {
        scripts\mp\gameobjects::setownerteam( "neutral" );
        thread scripts\mp\gametypes\obj_dom.gsc::updateflagstate( "idle", 0 );
        thread updateflares( "idle" );
    }

    if ( level.currentobjectiveindex == 0 || level.currentobjectiveindex == 4 )
        thread bombzone_warningklaxon();

    if ( getdvarint( "scr_bradley_spawner", 0 ) != 0 )
        scripts\mp\gametypes\bradley_spawner.gsc::tryspawnneutralbradleycmd( level.currentobjectiveindex );

    foreach ( var_1 in level.players )
        updatefloorbrush( var_1 );
}

dompoint_onactivateobjective()
{
    scripts\mp\utility\sound::playsoundonplayers( "mp_combat_outpost_activateobj" );
    var_0 = scripts\mp\gameobjects::getownerteam();
    ui_updatecmdownerteam( var_0 );
    ui_updatecmdcapturestatus( "neutral", 0 );
    scripts\mp\gameobjects::allowuse( "enemy" );
    thread awardcapturepoints();
    level.flagcapturetime = self.captureduration;

    if ( self.tierindex == 2 )
    {
        if ( level.cmdrules == 1 )
            level.flagcapturetime = 5.0;

        scripts\mp\gameobjects::setobjectivestatusicons( level.icondefend, level.iconcapture );
    }
    else
        scripts\mp\gameobjects::setobjectivestatusicons( level.iconneutral );

    if ( level.cmdrules == 1 )
    {
        if ( level.currentobjectiveindex == 0 || level.currentobjectiveindex == 4 )
            thread bombzone_holdtimer( self.holdtime );
    }
}

bombzone_onbeginuse( var_0 )
{
    scripts\mp\gametypes\obj_bombzone.gsc::bombzone_onbeginuse( var_0 );
}

bombzone_onenduse( var_0, var_1, var_2 )
{
    scripts\mp\gametypes\obj_bombzone.gsc::bombzone_onenduse( var_0, var_1, var_2 );
}

bombzone_onuseplantobject( var_0 )
{
    var_1 = scripts\mp\gameobjects::getownerteam();
    var_2 = scripts\mp\utility\game::getotherteam( var_1 )[0];
    scripts\mp\objidpoolmanager::objective_show_team_progress( level.currentobjective.objidnum, var_1 );
    showsplashtoteam( "all", "cop_planted" );
    level.flagcapturetime = 15.0;

    if ( istrue( level.persistentbombtimer ) )
    {
        if ( !isdefined( level.basefusetimers ) )
        {
            level.basefusetimers = [];
            level.basefusetimers["allies"] = level.bombtimer;
            level.basefusetimers["axis"] = level.bombtimer;
        }

        level.bombtimer = level.basefusetimers[var_1];
        level.lastbombplanttime = gettime();
    }

    scripts\mp\gametypes\obj_bombzone.gsc::bombzone_onuseplantobject( var_0 );
    var_3 = game["music"]["cop_bombplant"].size;
    var_4 = randomint( var_3 );

    foreach ( var_6 in level.players )
        var_6 setplayermusicstate( game["music"]["cop_bombplant"][var_4] );

    if ( var_0.team == "allies" )
        level thread scripts\mp\battlechatter_mp::trysaylocalsound( var_0, getcapturedialog( "planted" ) );

    if ( 0 )
        scripts\mp\gamescore::giveteamscoreforobjective( var_0.team, 1, 0 );

    scripts\mp\utility\dialog::statusdialog( getvoforobjective( var_1, "bomb_planted" ), var_1, 1 );
    scripts\mp\utility\dialog::statusdialog( getvoforobjective( var_2, "bomb_planted" ), var_2, 1 );

    if ( isdefined( level.zoneendtime ) )
        level.zoneendtime = int( level.zoneendtime - gettime() );

    if ( level.cmdrules == 1 )
        ui_updatebombtimer();

    ui_updatecmdownerteam( var_0.team );
}

bombzone_onusedefuseobject( var_0 )
{
    if ( !level.bombplanted )
        return;

    showsplashtoteam( "all", "cop_defused" );
    var_1 = scripts\mp\gameobjects::getownerteam();
    var_2 = scripts\mp\utility\game::getotherteam( var_1 )[0];
    level.flagcapturetime = 5.0;

    if ( istrue( level.persistentbombtimer ) )
        level.basefusetimers[var_1] = level.basefusetimers[var_1] - ( gettime() - level.lastbombplanttime ) / 1000;

    level.bombsplanted = level.bombsplanted - 1;

    if ( self.objectivekey == "_a" )
        level.aplanted = 0;
    else
        level.bplanted = 0;

    scripts\mp\gametypes\obj_bombzone.gsc::bombzone_onusedefuseobject( var_0 );

    if ( scripts\mp\utility\game::getotherteam( var_0.team )[0] == "allies" )
    {
        var_3 = getclosestplayeronteam( level.currentobjective.trigger.origin, scripts\mp\utility\game::getotherteam( var_0.team )[0] );

        if ( isdefined( var_3 ) )
            level thread scripts\mp\battlechatter_mp::trysaylocalsound( var_3, getcapturedialog( "defused" ) );
    }

    scripts\mp\gameobjects::setvisibleteam( "none" );
    scripts\mp\utility\dialog::statusdialog( getvoforobjective( var_1, "bomb_defused" ), var_1, 1 );
    scripts\mp\utility\dialog::statusdialog( getvoforobjective( var_2, "bomb_defused" ), var_2, 1 );
    var_0 notify( "bomb_defused" + self.objectivekey );
    self notify( "defused" );
    resetbombzone();

    if ( isdefined( level.zoneendtime ) )
        thread bombzone_holdtimer( level.zoneendtime / 1000 );

    ui_updatecmdownerteam( var_0.team );
}

bombzone_ondisableobjective()
{
    scripts\mp\gameobjects::disableobject();
    scripts\mp\gameobjects::allowuse( "none" );
}

bombzone_onenableobjective()
{
    scripts\mp\gameobjects::enableobject();
    scripts\mp\gameobjects::setvisibleteam( "any" );
    scripts\mp\gameobjects::allowuse( "none" );
    scripts\mp\gameobjects::setobjectivestatusicons( level.icontarget );
}

bombzone_onactivateobjective()
{
    scripts\mp\utility\sound::playsoundonplayers( "mp_combat_outpost_activateobj" );
    ui_updatecmdownerteam( "neutral" );
    ui_updatecmdcapturestatus( "neutral", 0 );
    level.planttime = self.captureduration;
    level.defusetime = self.captureduration;
    scripts\mp\gameobjects::setobjectivestatusicons( level.icondefend, level.iconcapture );
    scripts\mp\gameobjects::allowuse( "enemy" );
    thread bombzone_holdtimer( self.holdtime );
}

ui_updatezonetimer( var_0 )
{
    level.zoneendtime = int( gettime() + 1000 * var_0 );
    setomnvar( "ui_hardpoint_timer", level.zoneendtime );
}

ui_updatebombtimer()
{
    var_0 = int( gettime() + 1000 * level.bombtimer );
    setomnvar( "ui_hardpoint_timer", var_0 );
}

ui_updatezonetimerpausedness( var_0 )
{
    setomnvar( "ui_objective_timer_stopped", var_0 );
}

getownerteamplayer( var_0 )
{
    var_1 = undefined;

    foreach ( var_3 in level.players )
    {
        if ( var_3.team == var_0 )
            return var_3;
    }

    return var_1;
}

ui_updatecmdcapturestatus( var_0, var_1 )
{
    var_2 = -1;

    if ( istrue( level.inobjectiveot ) )
    {
        if ( var_1 )
            var_2 = -4;
        else
            var_2 = -5;
    }
    else if ( var_1 )
        var_2 = -2;
    else
    {
        switch ( var_0 )
        {
            case "allies":
                var_2 = 2;
                break;
            case "axis":
                var_2 = 1;
                break;
            case "zone_activation_delay":
                var_2 = -3;
                break;
            case "overtime":
                var_2 = -4;
                break;
            case "zone_shift":
            default:
                break;
        }
    }

    setomnvar( "ui_cmd_capture_team", var_2 );
}

ui_updatecmdownerteam( var_0 )
{
    var_1 = -1;

    switch ( var_0 )
    {
        case "allies":
            var_1 = 2;
            break;
        case "axis":
            var_1 = 1;
            break;
        case "zone_activation_delay":
            var_1 = -3;
            break;
        case "zone_shift":
        default:
            break;
    }

    setomnvar( "ui_cmd_owner_team", var_1 );
}

ui_updatecmdprogress()
{
    for (;;)
    {
        if ( isdefined( level.currentobjective ) )
            setomnvar( "ui_cmd_capture_progress", level.currentobjective scripts\mp\gameobjects::getcaptureprogress() );
        else
            setomnvar( "ui_cmd_capture_progress", 0 );

        waitframe();
    }
}

ui_updatecmdholdprogress()
{
    self notify( "ui_updateCMDHoldProgress" );
    self endon( "ui_updateCMDHoldProgress" );

    for (;;)
    {
        if ( isdefined( level.currentobjective ) && isdefined( level.currentobjective.teamholdtimers ) && isdefined( level.currentobjective.holdtime ) && level.currentobjective.holdtime > 0 )
        {
            setomnvar( "ui_cmd_owner_progress_allies", 1.0 - level.currentobjective.teamholdtimers["allies"] / level.currentobjective.holdtime );
            setomnvar( "ui_cmd_owner_progress_axis", 1.0 - level.currentobjective.teamholdtimers["axis"] / level.currentobjective.holdtime );
        }
        else
        {
            setomnvar( "ui_cmd_owner_progress_allies", 0 );
            setomnvar( "ui_cmd_owner_progress_axis", 0 );
        }

        waitframe();
    }
}

getcurrentvalue()
{
    if ( !isdefined( level.currentobjective ) )
        return 0.5;

    var_0 = getcenterfrac( level.currentobjectiveindex );
    var_1 = 0.0;
    var_2 = level.currentobjective scripts\mp\gameobjects::getownerteam();
    var_3 = 0.0;
    var_4 = 0.03;
    var_5 = 0.0;

    if ( isdefined( level.activationdelaystarttime ) && level.previousobjectiveindex != level.currentobjectiveindex )
    {
        if ( isdefined( level.currentobjective.defaultownerteam ) )
        {
            var_1 = var_4;

            if ( var_2 == "allies" )
                var_1 = var_1 * -1.0;

            var_4 = var_4 * 2;
        }

        var_3 = 1.0;
        var_6 = gettime();
        var_7 = ( var_6 - level.activationdelaystarttime ) / ( level.currentobjective.activationdelay * 1000 );
        var_5 = ( abs( getcenterfrac( level.previousobjectiveindex ) - var_0 ) - var_4 ) * var_7;

        if ( level.currentobjectiveindex < level.previousobjectiveindex )
        {
            var_5 = var_5 * -1.0;
            var_4 = var_4 * -1.0;
        }

        var_0 = getcenterfrac( level.previousobjectiveindex );
    }
    else
    {
        var_2 = level.currentobjective scripts\mp\gameobjects::getownerteam();

        if ( var_2 != "neutral" )
        {
            var_1 = var_4;

            if ( var_2 == "allies" )
                var_1 = var_1 * -1.0;

            if ( isdefined( level.currentobjective.claimteam ) && level.currentobjective.claimteam != "none" )
            {
                if ( level.currentobjective.claimteam != var_2 )
                {
                    var_4 = var_4 * 2;
                    var_3 = level.currentobjective scripts\mp\gameobjects::getcaptureprogress();

                    if ( level.currentobjective.claimteam == "allies" )
                        var_3 = var_3 * -1.0;
                }
            }
        }
        else
        {
            var_3 = level.currentobjective scripts\mp\gameobjects::getcaptureprogress();

            if ( isdefined( level.currentobjective.claimteam ) && level.currentobjective.claimteam != "none" )
            {
                if ( level.currentobjective.claimteam == "allies" )
                    var_3 = var_3 * -1.0;
            }
            else if ( isdefined( level.currentobjective.lastclaimteam ) )
            {
                if ( level.currentobjective.lastclaimteam == "allies" )
                    var_3 = var_3 * -1.0;
            }
        }
    }

    return var_0 + var_1 + var_3 * var_4 + var_5;
}

getcenterfrac( var_0 )
{
    var_1 = 0.0;

    switch ( var_0 )
    {
        case 0:
            var_1 = 0.0;
            break;
        case 1:
            var_1 = 0.25;
            break;
        case 2:
            var_1 = 0.5;
            break;
        case 3:
            var_1 = 0.75;
            break;
        case 4:
            var_1 = 1.0;
            break;
    }

    return var_1;
}

updateteamscores()
{
    if ( 1 )
    {
        scripts\mp\gamescore::_setteamscore( "allies", 0, 0 );
        scripts\mp\gamescore::_setteamscore( "axis", 0, 0 );
    }
}

spawnjuggcate( var_0, var_1 )
{
    var_2 = level.juggspawnbehavior;

    if ( var_1 == "attacker" && var_2 != 1 && var_2 != 3 )
        return;

    if ( var_1 == "defender" && var_2 != 2 && var_2 != 3 )
        return;

    if ( !isdefined( level.juggcrates ) )
    {
        level.juggcrates = [];
        level.juggcrates["allies"] = [];
        level.juggcrates["axis"] = [];
    }

    if ( isdefined( level.juggcrates[var_0][var_1] ) )
        return;

    var_3 = undefined;

    switch ( level.mapname )
    {
        case "mp_faridah":
            if ( var_1 == "attacker" )
            {
                if ( var_0 == "allies" )
                    var_3 = ( 250, -2040, 215 );
                else
                    var_3 = ( 786, 2413, 260 );
            }
            else if ( var_1 == "defender" )
            {
                if ( var_0 == "allies" )
                    var_3 = ( 25, -4630, 10 );
                else
                    var_3 = ( 1480, 4375, -40 );
            }

            break;
        case "mp_anvil":
            if ( var_1 == "attacker" )
            {
                if ( var_0 == "allies" )
                    var_3 = ( 2775, 2375, 360 );
                else
                    var_3 = ( -60, -260, 450 );
            }
            else if ( var_1 == "defender" )
            {
                if ( var_0 == "allies" )
                    var_3 = ( -2680, -855, 250 );
                else
                    var_3 = ( 2365, 4360, 360 );
            }

            break;
    }

    if ( isdefined( var_3 ) )
    {
        level.juggcrates[var_0][var_1] = givekscratetoteam( var_0, var_3, "juggernaut" );
        level.juggcrates[var_0][var_1] thread removeondeath( var_0, var_1 );
    }
}

removeondeath( var_0, var_1 )
{
    level endon( "game_ended" );
    self waittill( "death" );
    level.juggcrates[var_0][var_1] = undefined;
}

givejuggernaut()
{
    if ( !isplayer( self ) )
        return 0;

    if ( istrue( self.isjuggernaut ) )
        return 0;

    if ( isdefined( self.lightarmorhp ) )
        scripts\mp\perks\perkfunctions::unsetlightarmor();

    scripts\mp\lightarmor::setlightarmorvalue( self, 500, 1, 0 );
    self disableweaponpickup();
    scripts\mp\weapons::setplantedequipmentuse( 0 );
    scripts\common\utility::allow_offhand_weapons( 0 );

    if ( scripts\mp\utility\perk::_hasperk( "specialty_explosivebullets" ) )
        scripts\mp\utility\perk::removeperk( "specialty_explosivebullets" );

    scripts\cp_mp\utility\inventory_utility::_takeweapon( self.primaryweapon );
    scripts\cp_mp\utility\inventory_utility::_takeweapon( self.secondaryweapon );
    var_0 = "iw8_lm_kilo121_mp";
    scripts\cp_mp\utility\inventory_utility::_giveweapon( var_0 );
    self givemaxammo( var_0 );
    scripts\cp_mp\utility\inventory_utility::_switchtoweapon( var_0 );
    scripts\mp\juggernaut::jugg_setmodel();
    self.juggoverlay = newclienthudelem( self );
    self.juggoverlay.x = 0;
    self.juggoverlay.y = 0;
    self.juggoverlay.alignx = "left";
    self.juggoverlay.aligny = "top";
    self.juggoverlay.horzalign = "fullscreen";
    self.juggoverlay.vertalign = "fullscreen";
    self.juggoverlay setshader( "gasmask_overlay_delta", 640, 480 );
    self.juggoverlay.sort = -10;
    self.juggoverlay.archived = 1;
    self.juggoverlay.alpha = 1.0;
    self.health = self.maxhealth;
    self.isjuggernaut = 1;
    self.movespeedscaler = 0.75;
    scripts\mp\utility\perk::giveperk( "specialty_scavenger" );
    scripts\mp\utility\perk::giveperk( "specialty_quickdraw" );
    scripts\mp\utility\perk::giveperk( "specialty_sharp_focus" );
    thread juggernautsounds();
    thread juggremover();
    level notify( "gained_juggernaut", self );
    return 1;
}

juggernautsounds()
{
    level endon( "game_ended" );
    self endon( "death_or_disconnect" );
    self endon( "jugg_removed" );

    for (;;)
        wait 3.0;
}

juggremover()
{
    self endon( "disconnect" );
    thread removejuggongameended();
    thread removejuggonteamchangeordeath();
    self waittill( "should_remove_jugg" );

    if ( isdefined( self.lightarmorhp ) )
        scripts\mp\perks\perkfunctions::unsetlightarmor();

    self enableweaponpickup();
    scripts\mp\weapons::setplantedequipmentuse( 1 );
    scripts\common\utility::allow_offhand_weapons( 1 );
    self.juggoverlay destroy();
    scripts\cp_mp\utility\inventory_utility::_takeweapon( "iw8_lm_kilo121_mp" );
    scripts\cp_mp\utility\inventory_utility::_giveweapon( self.primaryweapon );
    scripts\cp_mp\utility\inventory_utility::_giveweapon( self.secondaryweapon );
    scripts\cp_mp\utility\inventory_utility::_switchtoweapon( self.primaryweapon );
    self.movespeedscaler = 1.0;
    scripts\mp\utility\perk::removeperk( "specialty_scavenger" );
    scripts\mp\utility\perk::removeperk( "specialty_quickdraw" );
    scripts\mp\utility\perk::removeperk( "specialty_sharp_focus" );
    self.isjuggernaut = 0;
    level notify( "removed_juggernaut", self );
    self notify( "jugg_removed" );
}

removejuggongameended()
{
    self endon( "disconnect" );
    self endon( "jugg_removed" );
    level waittill( "game_ended" );
    self notify( "should_remove_jugg" );
}

removejuggonteamchangeordeath()
{
    level endon( "game_ended" );
    self endon( "disconnect" );
    self endon( "jugg_removed" );
    scripts\engine\utility::_id_143A7( "death", "joined_team", "joined_spectators", "lost_juggernaut" );
    self notify( "should_remove_jugg" );
}

updatefloorbrush( var_0, var_1 )
{
    if ( !isdefined( self.neutralbrush ) )
        return;

    var_2 = self.ownerteam;
    var_3 = self.claimteam;
    var_4 = var_0.team;
    var_5 = var_0 ismlgspectator();

    if ( var_5 )
        var_4 = var_0 getmlgspectatorteam();

    if ( istrue( var_1 ) )
        hidebrushes( var_0 );
    else if ( istrue( self.stalemate ) )
        showcontestedbrush( var_0 );
    else if ( var_2 == "neutral" )
    {
        if ( var_3 != "none" )
        {
            if ( var_4 == var_3 )
                showfriendlybrush( var_0 );
            else
                showenemybrush( var_0 );
        }
        else
            showneutralbrush( var_0 );
    }
    else if ( var_4 == var_2 )
        showfriendlybrush( var_0 );
    else
        showenemybrush( var_0 );

    updatecapturebrush( var_0 );
}

updatecapturebrush( var_0 )
{
    if ( 1 )
        return;

    if ( !isdefined( self.neutralbrush ) )
        return;

    var_1 = scripts\mp\gameobjects::getclaimteam();
    var_2 = var_0.team;
    var_3 = var_0 ismlgspectator();

    if ( var_3 )
        var_2 = var_0 getmlgspectatorteam();

    if ( istrue( self.stalemate ) )
        hidecapturebrush( var_0 );
    else if ( var_1 == "none" )
        hidecapturebrush( var_0 );
    else if ( var_2 == var_1 )
        showfriendlycapturebrush( var_0 );
    else
        showenemycapturebrush( var_0 );
}

showneutralbrush( var_0 )
{
    foreach ( var_2 in self.friendlybrush )
        var_2 hidefromplayer( var_0 );

    foreach ( var_2 in self.enemybrush )
        var_2 hidefromplayer( var_0 );

    foreach ( var_2 in self.contestedbrush )
        var_2 hidefromplayer( var_0 );

    foreach ( var_2 in self.neutralbrush )
        var_2 showtoplayer( var_0 );
}

showfriendlybrush( var_0 )
{
    foreach ( var_2 in self.friendlybrush )
        var_2 showtoplayer( var_0 );

    foreach ( var_2 in self.enemybrush )
        var_2 hidefromplayer( var_0 );

    foreach ( var_2 in self.contestedbrush )
        var_2 hidefromplayer( var_0 );

    foreach ( var_2 in self.neutralbrush )
        var_2 hidefromplayer( var_0 );
}

showenemybrush( var_0 )
{
    foreach ( var_2 in self.friendlybrush )
        var_2 hidefromplayer( var_0 );

    foreach ( var_2 in self.enemybrush )
        var_2 showtoplayer( var_0 );

    foreach ( var_2 in self.contestedbrush )
        var_2 hidefromplayer( var_0 );

    foreach ( var_2 in self.neutralbrush )
        var_2 hidefromplayer( var_0 );
}

showcontestedbrush( var_0 )
{
    foreach ( var_2 in self.friendlybrush )
        var_2 hidefromplayer( var_0 );

    foreach ( var_2 in self.enemybrush )
        var_2 hidefromplayer( var_0 );

    foreach ( var_2 in self.contestedbrush )
        var_2 showtoplayer( var_0 );

    foreach ( var_2 in self.neutralbrush )
        var_2 hidefromplayer( var_0 );
}

hidebrushes( var_0 )
{
    foreach ( var_2 in self.friendlybrush )
        var_2 hidefromplayer( var_0 );

    foreach ( var_2 in self.enemybrush )
        var_2 hidefromplayer( var_0 );

    foreach ( var_2 in self.contestedbrush )
        var_2 hidefromplayer( var_0 );

    foreach ( var_2 in self.neutralbrush )
        var_2 hidefromplayer( var_0 );
}

showfriendlycapturebrush( var_0 )
{
    foreach ( var_2 in self.friendlypulsebrush )
        var_2 showtoplayer( var_0 );

    foreach ( var_2 in self.enemypulsebrush )
        var_2 hidefromplayer( var_0 );
}

showenemycapturebrush( var_0 )
{
    foreach ( var_2 in self.friendlypulsebrush )
        var_2 hidefromplayer( var_0 );

    foreach ( var_2 in self.enemypulsebrush )
        var_2 showtoplayer( var_0 );
}

hidecapturebrush( var_0 )
{
    foreach ( var_2 in self.friendlypulsebrush )
        var_2 hidefromplayer( var_0 );

    foreach ( var_2 in self.enemypulsebrush )
        var_2 hidefromplayer( var_0 );
}

updatefloorbrushwaitforjoined()
{

}

applythermal()
{
    self visionsetthermalforplayer( "proto_apache_flir_mp" );
    self thermalvisionon();
}

removethermal()
{
    self thermalvisionoff();
}

startspectatorview()
{
    waitframe();
    scripts\mp\utility\player::updatesessionstate( "spectator" );
    scripts\mp\spectating::setdisabled();

    if ( isdefined( self.lastdeathangles ) )
        self setplayerangles( self.lastdeathangles );

    wait 0.1;
    scripts\mp\utility\player::setdof_default();
    var_0 = level.spectatorcameras[level.currentspectatorcamref][self.team];
    var_1 = var_0.origin;
    var_2 = var_0.angles;
    self.deathspectatepos = var_1;
    self.deathspectateangles = var_2;
    var_3 = spawn( "script_model", self getvieworigin() );
    var_3 setmodel( "tag_origin" );
    var_3.angles = var_2;
    self.spectatorcament = var_3;
    self.isusingtacopsmapcamera = 1;
    self cameralinkto( var_3, "tag_origin", 1 );
    thread dohalfwayflash();
    var_3 movecameratomappos( self, var_1, var_2 );
}

dohalfwayflash()
{
    wait 0.4;
    thread playslamzoomflash();
    applythermal();
}

endspectatorview()
{
    if ( !isdefined( self.spectatorcament ) )
        return;

    removethermal();
    thread runslamzoomonspawn();
}

updatespectatorcamera( var_0 )
{
    level.currentspectatorcamref = var_0;

    foreach ( var_2 in level.players )
    {
        if ( isdefined( var_2.spectatorcament ) )
        {
            var_3 = var_2.team;
            var_4 = getdvarint( "scr_cmd_camera_team", -1 );

            if ( var_4 != -1 )
                var_3 = scripts\engine\utility::ter_op( var_4 == 0, "allies", "axis" );

            var_5 = level.spectatorcameras[level.currentspectatorcamref][var_3];
            var_2.spectatorcament movecameratomappos( var_2, var_5.origin, var_5.angles );
        }
    }
}

movecameratomappos( var_0, var_1, var_2 )
{
    var_0 endon( "spawned_player" );
    var_3 = 1.0;
    var_4 = 1.0;
    self moveto( var_1, 1.0, 0.5, 0.5 );
    var_0 playlocalsound( "mp_cmd_camera_zoom_out" );
    var_0 setclienttriggeraudiozonepartialwithfade( "spawn_cam", 0.5, "mix" );
    self rotateto( var_2, 1.0, 0.5, 0.5 );
    var_0 thread startoperatorsound();
    wait 1.1;
    var_5 = anglestoforward( var_2 ) * 300;
    var_5 = var_5 * ( 1, 1, 0 );

    if ( isdefined( var_0 ) && isdefined( var_0.spectatorcament ) )
    {
        self moveto( var_1 + var_5, 15.0, 1.0, 1.0 );
        var_0 earthquakeforplayer( 0.03, 15.0, var_1 + var_5, 1000 );
    }
}

runslamzoomonspawn()
{
    self waittill( "spawned_player" );
    var_0 = self geteye();
    var_1 = self.angles;
    scripts\mp\utility\player::updatesessionstate( "spectator" );
    self cameralinkto( self.spectatorcament, "tag_origin", 1 );
    self visionsetnakedforplayer( "tac_ops_slamzoom", 0.2 );
    self.spectatorcament moveto( var_0, 0.5 );
    self playlocalsound( "mp_cmd_camera_zoom_in" );
    self clearclienttriggeraudiozone( 0.5 );
    self.spectatorcament rotateto( var_1, 0.5, 0.5 );
    wait 0.5;
    self visionsetnakedforplayer( "", 0 );
    thread playslamzoomflash();
    scripts\mp\utility\player::updatesessionstate( "playing" );
    self cameraunlink();
    self.spectatorcament delete();
    wait 1.0;
    var_2 = gettime();

    if ( !isdefined( self.lastsitreptime ) || var_2 < self.lastsitreptime + 30000 || var_2 < level.lastteamstatustime[self.team] + 5000 )
        return;

    scripts\mp\utility\dialog::sitrepdialogonplayer( getsitreplocname() );
    thread playselfbattlechatter( self, "plrresponse_affirm", "cop_affirm_2d", 2.5, 1 );
}

playslamzoomflash()
{
    var_0 = newclienthudelem( self );
    var_0.x = 0;
    var_0.y = 0;
    var_0.alignx = "left";
    var_0.aligny = "top";
    var_0.sort = 1;
    var_0.horzalign = "fullscreen";
    var_0.vertalign = "fullscreen";
    var_0.alpha = 1;
    var_0.foreground = 1;
    var_0 setshader( "white", 640, 480 );
    var_0 fadeovertime( 0.4 );
    var_0.alpha = 0.0;
    wait 0.4;
    var_0 destroy();
}

startoperatorsound()
{
    self endon( "game_ended" );
    self waittill( "spawned_player" );
    wait 0.5;
}

ongameended()
{
    level waittill( "game_ended" );

    foreach ( var_1 in level.objectives )
        var_1 scripts\mp\gameobjects::setvisibleteam( "none" );
}

playendofmatchtransition( var_0 )
{
    self setclientomnvar( "ui_total_fade", 0 );
    waitframe();
    var_1 = 10;
    var_2 = var_1;

    for ( var_2 = 1; var_2 <= var_1; var_2++ )
    {
        waitframe();
        self setclientomnvar( "ui_total_fade", var_2 / var_1 );
    }

    if ( scripts\mp\utility\player::isreallyalive( self ) && !scripts\mp\utility\player::isusingremote() && isdefined( var_0 ) )
    {
        var_3 = distance2dsquared( self.origin, var_0.origin );

        if ( var_3 > 40000 )
        {
            var_4 = self cloneplayer( 0 );
            var_4 startragdoll( 1 );
        }
    }

    thread scripts\mp\playerlogic::spawnintermission( var_0, "spectator" );
    waitframe();
    var_1 = 4;
    var_2 = var_1;

    for ( var_2 = var_1 - 1; var_2 >= 0; var_2-- )
    {
        waitframe();
        self setclientomnvar( "ui_total_fade", var_2 / var_1 );
    }
}

getsitreplocname()
{
    var_0 = "sitrep_" + level.currentobjectiveindex + "_" + level.mapname;
    return var_0;
}

getcapturedialog( var_0 )
{
    var_1 = "cop_obj_" + level.currentobjectiveindex + "_" + var_0 + "_" + level.mapname;
    return var_1;
}

getselfobjcaptureddialog( var_0 )
{
    var_1 = "";
    var_2 = "";
    var_3 = 0;

    switch ( level.currentobjectiveindex )
    {
        case 0:
            if ( var_0 == "planting" )
            {
                var_1 = "arming_bomb";
                var_2 = "cop_arming_bomb_2d";
                var_3 = 1;
            }
            else if ( var_0 == "defusing" )
            {
                var_1 = "bomb_defusing";
                var_2 = "cop_bomb_defusing_2d";
                var_3 = 1;
            }

            break;
        case 1:
            if ( var_0 == "capturing" )
                var_2 = "";
            else if ( var_0 == "captured" )
            {
                if ( self.team == "axis" )
                {
                    var_1 = "objsecured_generic";
                    var_2 = "cop_generic_captured_2d";
                }
                else if ( level.mapname == "mp_faridah" )
                {
                    var_1 = "objsecured_school";
                    var_2 = "cop_school_captured_2d";
                }
                else
                {
                    var_1 = "objsecured_generic";
                    var_2 = "cop_generic_captured_2d";
                }
            }

            break;
        case 2:
            if ( var_0 == "capturing" )
                var_2 = "";
            else if ( var_0 == "captured" )
            {
                var_1 = "objsecured_generic";
                var_2 = "cop_generic_captured_2d";
            }

            break;
        case 3:
            if ( var_0 == "capturing" )
                var_2 = "";
            else if ( var_0 == "captured" )
            {
                if ( level.mapname == "mp_faridah" )
                {
                    var_1 = "objsecured_warehouse";
                    var_2 = "cop_warehouse_captured_2d";
                }
                else
                {
                    var_1 = "objsecured_generic";
                    var_2 = "cop_generic_captured_2d";
                }
            }

            break;
        case 4:
            if ( var_0 == "planting" )
            {
                var_1 = "arming_bomb";
                var_2 = "cop_arming_bomb_2d";
                var_3 = 1;
            }
            else if ( var_0 == "defusing" )
            {
                var_1 = "bomb_defusing";
                var_2 = "cop_bomb_defusing_2d";
                var_3 = 1;
            }

            break;
    }

    var_4 = 0;

    if ( var_3 && !scripts\mp\battlechatter_mp::saidtoorecently( var_2 ) )
    {
        scripts\mp\battlechatter_mp::updatechatter( var_2 );
        thread playselfbattlechatter( self, var_1, var_2, 1.5 );
    }
    else if ( !var_3 )
        thread playselfbattlechatter( self, var_1, var_2, 1.5 );

    var_5 = scripts\engine\utility::ter_op( self.team == "allies", "usp1", "abp1" );

    if ( level.mapname == "mp_faridah" )
        var_5 = scripts\engine\utility::ter_op( self.team == "allies", "usp1", "afp1" );

    var_6 = "dx_mpp_" + var_5 + "_" + var_1;
    return lookupsoundlength( var_6 ) / 1000;
}

playselfbattlechatter( var_0, var_1, var_2, var_3, var_4 )
{
    if ( isai( self ) )
        return;

    level endon( "game_ended" );
    self endon( "death" );

    if ( isdefined( var_3 ) )
        wait( var_3 );

    var_5 = scripts\engine\utility::ter_op( self.team == "allies", "usp1", "abp1" );

    if ( level.mapname == "mp_faridah" )
        var_5 = scripts\engine\utility::ter_op( var_0.team == "allies", "usp1", "afp1" );

    var_6 = "dx_mpp_" + var_5 + "_" + var_1;

    if ( isdefined( var_4 ) )
    {
        var_7 = var_6;

        if ( soundexists( var_7 ) )
            var_6 = var_7;
    }

    var_0 queuedialogforplayer( var_6, var_2, 2 );
}

getclosestplayeronteam( var_0, var_1 )
{
    var_2 = undefined;
    var_3 = undefined;

    foreach ( var_5 in level.players )
    {
        if ( var_5.team == var_1 && scripts\mp\utility\player::isreallyalive( var_5 ) )
        {
            var_6 = distance2dsquared( var_5.origin, var_0 );

            if ( !isdefined( var_3 ) || var_6 < var_3 )
            {
                var_2 = var_5;
                var_3 = var_6;
            }
        }
    }

    return var_2;
}

disableobjectiveongameended()
{
    level waittill( "game_ended" );

    if ( isdefined( level.currentobjective ) && isdefined( level.currentobjective.ondisableobjective ) )
        level.currentobjective [[ level.currentobjective.ondisableobjective ]]();
}

setupcaptureflares()
{
    if ( getdvarint( "scr_cop_flares", 0 ) != 1 )
        return;

    wait 2.0;
    var_0 = [];
    var_0[var_0.size] = spawnflare( ( 350, -3580, -35 ), ( 0, -151, 0 ) );
    var_0[var_0.size] = spawnflare( ( 345, -3650, -35 ), ( 0, 140, 0 ) );
    var_0[var_0.size] = spawnflare( ( 235, -3655, -35 ), ( 0, 50, 0 ) );
    var_0[var_0.size] = spawnflare( ( 230, -3575, -35 ), ( 0, -40, 0 ) );
    level.objectives["0"].scriptables = var_0;
    var_1 = [];
    var_1[var_1.size] = spawnflare( ( -457, -2006, 204 ), ( 0, 331, 0 ), 0 );
    var_1[var_1.size] = spawnflare( ( -31, -1915, 192 ), ( 45, 48, 0 ), 0 );
    var_1[var_1.size] = spawnflare( ( -319, -1706, 209 ), ( 0, 130, 0 ), 0 );
    var_1[var_1.size] = spawnflare( ( -545, -1805, 207 ), ( 0, 130, 0 ), 0 );
    var_1[var_1.size] = spawnflare( ( -302, -2137, 152 ), ( 0, 234, 0 ) );
    level.objectives["1"].scriptables = var_1;
    var_2 = [];
    var_2[var_2.size] = spawnflare( ( 420, -23, 17 ), ( 5, 208, 0 ) );
    var_2[var_2.size] = spawnflare( ( 458, 59, 109 ), ( 0, 342, 0 ), 0 );
    var_2[var_2.size] = spawnflare( ( 380, -267, 17 ), ( 0, 186, 0 ) );
    var_2[var_2.size] = spawnflare( ( 210, 126, 18 ), ( 5, 125, 0 ) );
    var_2[var_2.size] = spawnflare( ( 675, 118, 18 ), ( 0, 41, 0 ) );
    var_2[var_2.size] = spawnflare( ( 638, -180, 18 ), ( 5, 356, 0 ) );
    var_2[var_2.size] = spawnflare( ( 417, 105, 69 ), ( 75, 285, 0 ), 0 );
    var_2[var_2.size] = spawnflare( ( 426, -177, 17 ), ( 5, 73, 0 ), 0 );
    var_2[var_2.size] = spawnflare( ( 509, -116, 69 ), ( 55, 82, 0 ), 0 );
    var_2[var_2.size] = spawnflare( ( 331, 60, 63 ), ( 0, 309, 0 ), 0 );
    var_2[var_2.size] = spawnflare( ( 578, 65, 62 ), ( 40, 197, 0 ), 0 );
    level.objectives["2"].scriptables = var_2;
    var_3 = [];
    var_3[var_3.size] = spawnflare( ( 812, 2074, 222 ), ( 35, 326, 0 ), 0 );
    var_3[var_3.size] = spawnflare( ( 431, 1882, 241 ), ( 5, 86, 0 ), 0 );
    var_3[var_3.size] = spawnflare( ( 762, 2333, 226 ), ( 15, 345, 0 ), 0 );
    var_3[var_3.size] = spawnflare( ( 609, 1861, 223 ), ( 65, 339, 0 ), 0 );
    var_3[var_3.size] = spawnflare( ( 580, 2150, 212 ), ( 0, 272, 0 ), 0 );
    level.objectives["3"].scriptables = var_3;
    var_4 = [];
    var_4[var_4.size] = spawnflare( ( 1300, 3335, 12 ), ( 0, 40, 0 ) );
    var_4[var_4.size] = spawnflare( ( 1305, 3430, -2 ), ( 0, -47, 0 ) );
    var_4[var_4.size] = spawnflare( ( 1430, 3435, -3 ), ( 0, -135, 0 ) );
    var_4[var_4.size] = spawnflare( ( 1430, 3350, 3 ), ( 0, 140, 0 ) );
    level.objectives["4"].scriptables = var_4;

    if ( getdvarint( "scr_cop_flares_debug", 0 ) == 1 )
        thread debugcaptureflares();
}

spawnflare( var_0, var_1, var_2 )
{
    var_3 = var_0;

    if ( !isdefined( var_2 ) )
        var_2 = 1;

    if ( var_2 )
        var_3 = scripts\engine\utility::drop_to_ground( var_0, 50, -200, ( 0, 0, 1 ) );

    var_4 = spawn( "script_model", var_3 + ( 0, 0, 2 ) );
    var_4.angles = var_1 + ( 0, 180, 0 );
    var_4 setmodel( "cop_marker_scriptable" );
    return var_4;
}

updateflares( var_0 )
{
    if ( getdvarint( "scr_cop_flares", 0 ) != 1 )
        return;

    self notify( "updateFlares" );
    self endon( "updateFlares" );

    while ( !isdefined( self.scriptables ) )
        waitframe();

    foreach ( var_2 in self.scriptables )
        var_2 setscriptablepartstate( "marker", var_0 );
}

debugcaptureflares()
{
    var_0 = 0;

    for (;;)
    {
        var_1 = 0;

        switch ( var_0 )
        {
            case 0:
                var_1 = "allies";
                break;
            case 1:
                var_1 = "axis";
                break;
            case 2:
                var_1 = "contested";
                break;
            case 3:
                var_1 = "idle";
                break;
        }

        foreach ( var_3 in level.objectives )
        {
            if ( !isdefined( var_3.scriptables ) )
                continue;

            foreach ( var_5 in var_3.scriptables )
                var_5 setscriptablepartstate( "marker", var_1 );
        }

        var_0++;

        if ( var_0 > 3 )
            var_0 = 0;

        wait 3.0;
    }
}

mapobjectiveicon( var_0 )
{
    switch ( level.mapname )
    {
        case "mp_faridah":
            switch ( self.objectivekey )
            {
                case "0":
                    self.iconname = "_bombsite";
                    break;
                case "1":
                    self.iconname = "_school";
                    break;
                case "2":
                    self.iconname = "_clocktower";
                    break;
                case "3":
                    self.iconname = "_warehouse";
                    break;
                case "4":
                    self.iconname = "_bombsite";
                    break;
                default:
                    self.iconname = "";
                    break;
            }

            break;
        default:
            switch ( self.objectivekey )
            {
                case "0":
                    self.iconname = "_generic";
                    break;
                case "1":
                    self.iconname = "_generic";
                    break;
                case "2":
                    self.iconname = "_generic";
                    break;
                case "3":
                    self.iconname = "_generic";
                    break;
                case "4":
                    self.iconname = "_generic";
                    break;
                default:
                    self.iconname = "";
                    break;
            }

            break;
    }
}

updateoobtriggers()
{
    if ( !isdefined( level.currentobjective.oobtriggers ) )
        return;

    level notify( "updateOOBTriggers" );

    foreach ( var_1 in level.players )
    {
        if ( isdefined( level.currentobjective.oobtriggers["allies"] ) )
            level.currentobjective.oobtriggers["allies"] thread updateoobvisuals( "axis" );

        if ( isdefined( level.currentobjective.oobtriggers["axis"] ) )
            level.currentobjective.oobtriggers["axis"] thread updateoobvisuals( "allies" );
    }
}

updateoobvisuals( var_0 )
{
    self notify( "updateOOBVisuals" );
    self endon( "updateOOBVisuals" );

    while ( !isdefined( self.visuals ) )
        waitframe();

    foreach ( var_2 in self.visuals )
    {
        for ( var_3 = 0; var_3 < var_2.drawcount; var_3++ )
            var_2 setscriptablepartstate( "chevron_" + var_3, var_0 );
    }

    level waittill( "updateOOBTriggers" );

    foreach ( var_2 in self.visuals )
    {
        for ( var_3 = 0; var_3 < var_2.drawcount; var_3++ )
            var_2 setscriptablepartstate( "chevron_" + var_3, "off" );
    }
}

awardcapturepoints()
{
    level endon( "game_ended" );
    level notify( "awardCapturePointsRunning" );
    level endon( "awardCapturePointsRunning" );
    var_0 = 1;
    var_1 = 1;

    while ( !level.gameended )
    {
        var_2 = 0.0;

        while ( var_2 < var_0 )
        {
            waitframe();
            scripts\mp\hostmigration::waittillhostmigrationdone();
            var_2 = var_2 + level.framedurationseconds;

            if ( self.stalemate )
                var_2 = 0.0;
        }

        var_3 = self.claimteam;

        if ( var_3 == "none" )
            continue;

        if ( !self.stalemate )
        {
            foreach ( var_5 in self.touchlist[var_3] )
                var_5.player thread scripts\mp\utility\points::giveunifiedpoints( "cop_in_obj" );
        }
    }
}

showsplashtoteam( var_0, var_1 )
{
    foreach ( var_3 in level.players )
    {
        if ( var_0 == "all" || var_3.team == var_0 )
            var_3 thread scripts\mp\hud_message::showsplash( var_1 );
    }
}
